[
  {
    "filePath": "C:\\cliniio3.0\\src\\App.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 215,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\n\n// ‚ö†Ô∏è TEMPORARY: force cleanup of stale realtime subscriptions\n// import '@/debug/runRealtimeCleanup';\n\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route,\n  Navigate,\n} from 'react-router-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { NavigationProvider } from './contexts/NavigationContext';\nimport { UserProvider } from './contexts/UserContext';\nimport { FacilityProvider } from './contexts/FacilityContext';\nimport { ErrorBoundary } from './components/ErrorBoundary';\nimport { ProtectedRoute } from './components/ProtectedRoute';\nimport GlobalBIFailureBanner from './components/Sterilization/GlobalBIFailureBanner';\n\n// CRITICAL: Import realtime auto-optimizer to prevent database overload\nimport './services/_core/realtimeCompatibility';\n\n// Direct imports for pages\nimport HomePage from './pages/Home';\nimport SterilizationPage from './pages/Sterilization/Sterilization';\nimport ScannerPage from './pages/Sterilization/ScannerPage';\nimport InventoryPage from './pages/Inventory';\nimport InventoryScannerPage from './pages/Inventory/ScannerPage';\nimport EnvironmentalCleanPage from './pages/EnvironmentalClean/page';\nimport EnvironmentalCleanScannerPage from './pages/EnvironmentalClean/ScannerPage';\nimport KnowledgeHubPage from './pages/KnowledgeHub';\nimport LibraryPage from './pages/library/page';\n\nimport SettingsPage from './pages/Settings';\nimport ContentBuilderPage from './pages/ContentBuilder';\nimport LoginPage from './pages/Login';\nimport IntelligencePage from './pages/Intelligence';\n\n// BEGIN PostgREST runtime guard (safe, no-UI side effects)\ninterface ExtendedWindow extends Window {\n  __postgrestGuardInstalled?: boolean;\n  __postgrestGuardLogged?: boolean;\n  __facilityIdCache?: { id: string; timestamp: number };\n}\n\n// Cache for facility ID to avoid async calls in fetch guard\nlet facilityIdCache: { id: string; timestamp: number } | null = null;\nconst FACILITY_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nasync function updateFacilityIdCache() {\n  try {\n    // Dynamic import to avoid circular dependencies\n    const { FacilityService } = await import('./services/facilityService');\n    const facilityId = await FacilityService.getCurrentFacilityId();\n    facilityIdCache = { id: facilityId, timestamp: Date.now() };\n  } catch (error) {\n    console.warn('Failed to update facility ID cache:', error);\n    // Keep existing cache if available, otherwise use development fallback\n    if (!facilityIdCache) {\n      facilityIdCache = {\n        id: '550e8400-e29b-41d4-a716-446655440000',\n        timestamp: Date.now(),\n      };\n    }\n  }\n}\n\nfunction getCurrentFacilityId(): string {\n  const now = Date.now();\n\n  // Return cached ID if still valid\n  if (\n    facilityIdCache &&\n    now - facilityIdCache.timestamp < FACILITY_CACHE_DURATION\n  ) {\n    return facilityIdCache.id;\n  }\n\n  // If cache is stale, trigger async update but return current cached value\n  if (facilityIdCache) {\n    updateFacilityIdCache(); // Fire and forget\n    return facilityIdCache.id;\n  }\n\n  // Do not fallback to dev facility ID in production\n  if (!facilityIdCache) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn('Using dev facility fallback in development mode');\n      return '550e8400-e29b-41d4-a716-446655440000';\n    }\n    throw new Error(\n      'Facility ID lookup failed ‚Äî no fallback allowed in production.'\n    );\n  }\n}\n\nfunction installPostgrestFetchGuard() {\n  const extWindow = window as ExtendedWindow;\n  if (typeof window === 'undefined' || extWindow.__postgrestGuardInstalled)\n    return;\n\n  // Check if fetch is available (for test environments)\n  if (typeof window.fetch === 'undefined') return;\n\n  extWindow.__postgrestGuardInstalled = true;\n\n  const SUPABASE_REST_MARKER = '.supabase.co/rest/v1/';\n  const nativeFetch = window.fetch.bind(window);\n\n  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n    try {\n      let url = typeof input === 'string' ? input : (input as URL).toString();\n      if (url.includes(SUPABASE_REST_MARKER)) {\n        const u = new URL(url);\n\n        // Helper: strip a trailing \":1\" token that some builders append to values\n        const stripTrailingColonOne = (val: string) =>\n          val.endsWith(':1') ? val.slice(0, -2) : val;\n\n        // 1) Pass 1 ‚Äì normalize/clean each param\n        const pendingDeletes: string[] = [];\n        const pendingSets: Array<[string, string]> = [];\n        for (const [k, vRaw] of u.searchParams.entries()) {\n          const v = vRaw.trim();\n\n          // Remove any empty eq filter: key=eq. / eq / eq: / eq:. / .\n          if (\n            v === 'eq.' ||\n            v === 'eq' ||\n            v === 'eq:' ||\n            v === 'eq:.' ||\n            v === '.'\n          ) {\n            pendingDeletes.push(k);\n            continue;\n          }\n\n          // Fix facility_id special case eq.:1 ‚Üí eq.<UUID>\n          if (\n            k === 'facility_id' &&\n            (v === 'eq.:1' || v === 'eq:1' || v === ':1' || v === 'eq.:')\n          ) {\n            const currentFacilityId = getCurrentFacilityId();\n            pendingSets.push(['facility_id', `eq.${currentFacilityId}`]);\n            continue;\n          }\n\n          // Generic fix: if any value ends with \":1\", strip it (e.g., date=eq.2025-08-15:1)\n          const vStripped = stripTrailingColonOne(v);\n          if (vStripped !== v) {\n            pendingSets.push([k, vStripped]);\n            continue;\n          }\n\n          // Remove the illegal column-vs-column comparison\n          if (k === 'quantity' && v === 'lt.reorder_point') {\n            pendingDeletes.push(k);\n            continue;\n          }\n        }\n        pendingDeletes.forEach((k) => u.searchParams.delete(k));\n        pendingSets.forEach(([k, v]) => {\n          u.searchParams.set(k, v);\n        });\n\n        // 2) Belt-and-suspenders raw replacements for edge cases\n        // facility_id=eq.:1 ‚Üí eq.<UUID>\n        if (u.search.includes('facility_id=eq.:1')) {\n          const currentFacilityId = getCurrentFacilityId();\n          u.search = u.search.replace(\n            'facility_id=eq.:1',\n            `facility_id=eq.${currentFacilityId}`\n          );\n        }\n        // Remove any lingering key=eq. pairs produced by odd joiners\n        u.search = u.search.replace(\n          /(^|&)([^=&]+)=eq\\.(?=(&|$))/g,\n          (_m, p1) => {\n            // drop the whole pair\n            return p1 ? p1.slice(0, -1) : '';\n          }\n        );\n        // Strip trailing \":1\" from any param value (ultra-safe catch-all)\n        u.search = u.search.replace(/(:1)(?=(&|$))/g, '');\n        // Remove literal quantity=lt.reorder_point if present\n        u.search = u.search.replace(\n          /(^|&)quantity=lt\\.reorder_point(?=(&|$))/g,\n          (_m, p1) => (p1 ? p1.slice(0, -1) : '')\n        );\n\n        // 3) Deduplicate params\n        const deduped = new URL(u.toString());\n        const seen = new Map<string, string>();\n        for (const [k, v] of deduped.searchParams.entries()) seen.set(k, v);\n        deduped.search = '';\n        for (const [k, v] of seen.entries()) deduped.searchParams.append(k, v);\n\n        if (deduped.toString() !== url) {\n          if (!extWindow.__postgrestGuardLogged) {\n            extWindow.__postgrestGuardLogged = true;\n            console.info('üõ°Ô∏è PostgREST guard rewrote URL:', {\n              from: url,\n              to: deduped.toString(),\n            });\n          }\n          url = deduped.toString();\n          input = url;\n        }\n      }\n    } catch (err) { console.error(err); throw err; }\n      // If anything goes wrong, fall through to native fetch untouched\n    }\n    return nativeFetch(input, init);\n  };\n}\n// END PostgREST runtime guard\n\n// Create a client\nconst queryClient = new QueryClient();\n\nfunction App() {\n  // Initialize services and install guards once on client\n  React.useEffect(() => {\n    // Initialize inventory service facade\n    import('./services/inventory/InventoryServiceFacade').then(\n      ({ inventoryServiceFacade }) => {\n        inventoryServiceFacade.initialize().catch((error) => {\n          console.error(\n            'Failed to initialize inventory service facade:',\n            error\n          );\n        });\n      }\n    );\n\n    // Initialize facility ID cache for fetch guard\n    updateFacilityIdCache();\n\n    // Install PostgREST runtime guard\n    installPostgrestFetchGuard();\n  }, []);\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ErrorBoundary>\n        <UserProvider>\n          <FacilityProvider>\n            <Router>\n              <NavigationProvider>\n                <Routes>\n                  <Route path=\"/login\" element={<LoginPage />} />\n                  <Route\n                    path=\"/home\"\n                    element={\n                      <ProtectedRoute>\n                        <HomePage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/sterilization\"\n                    element={\n                      <ProtectedRoute>\n                        <SterilizationPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/sterilization/scanner\"\n                    element={\n                      <ProtectedRoute>\n                        <ScannerPage />\n                      </ProtectedRoute>\n                    }\n                  />\n\n                  <Route\n                    path=\"/inventory\"\n                    element={\n                      <ProtectedRoute>\n                        <InventoryPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/inventory/scanner\"\n                    element={\n                      <ProtectedRoute>\n                        <InventoryScannerPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/environmental-clean\"\n                    element={\n                      <ProtectedRoute>\n                        <EnvironmentalCleanPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/environmental-clean/scanner\"\n                    element={\n                      <ProtectedRoute>\n                        <EnvironmentalCleanScannerPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/knowledge-hub\"\n                    element={\n                      <ProtectedRoute>\n                        <KnowledgeHubPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/library\"\n                    element={\n                      <ProtectedRoute>\n                        <LibraryPage />\n                      </ProtectedRoute>\n                    }\n                  />\n\n                  <Route\n                    path=\"/intelligence\"\n                    element={\n                      <ProtectedRoute>\n                        <IntelligencePage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/settings\"\n                    element={\n                      <ProtectedRoute>\n                        <SettingsPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route\n                    path=\"/content-builder\"\n                    element={\n                      <ProtectedRoute>\n                        <ContentBuilderPage />\n                      </ProtectedRoute>\n                    }\n                  />\n                  <Route path=\"/\" element={<Navigate to=\"/home\" replace />} />\n                </Routes>\n              </NavigationProvider>\n            </Router>\n          </FacilityProvider>\n        </UserProvider>\n        <GlobalBIFailureBanner />\n      </ErrorBoundary>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\@mdi\\js.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\@mdi\\react.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\InventoryManagementTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\contexts\\UserContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\getEnv.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\homeMockTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\importMetaEnv.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\react-error-boundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\supabaseMock.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\timerWorkerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\types\\supabaseMockTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'T' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 58,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'T' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 334,
        "column": 22,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 334,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// ============================================================================\n// SUPABASE MOCK TYPES\n// ============================================================================\n\nexport interface PostgrestError {\n  code: string;\n  message: string;\n  details?: string;\n  hint?: string;\n  name?: string;\n}\n\nexport interface AuthError extends Error {\n  status: number;\n  __isAuthError: boolean;\n}\n\nexport interface User {\n  id: string;\n  email: string;\n  created_at: string;\n  updated_at: string;\n  app_metadata: Record<string, unknown>;\n  user_metadata: Record<string, unknown>;\n  aud: string;\n}\n\nexport interface Session {\n  access_token: string;\n  refresh_token: string;\n  expires_in: number;\n  expires_at: number;\n  token_type: string;\n  user: User;\n}\n\nexport interface AuthResponse {\n  data: {\n    user: User | null;\n    session: Session | null;\n  };\n  error: AuthError | null;\n}\n\nexport interface SupabaseResponse<T> {\n  data: T | null;\n  error: PostgrestError | null;\n}\n\nexport interface RealtimeSubscription {\n  unsubscribe: () => void;\n  send: (event: string, payload: unknown) => void;\n}\n\nexport type RealtimeEventType = 'INSERT' | 'UPDATE' | 'DELETE' | '*';\nexport type RealtimeEventFilter = Record<string, unknown>;\n\nexport interface RealtimeCallback<T> {\n  (payload: unknown): void;\n}\n\nexport interface RealtimeChannel {\n  on<T = unknown>(\n    event: RealtimeEventType,\n    filter: RealtimeEventFilter,\n    callback: RealtimeCallback<T>\n  ): { subscribe: (callback?: RealtimeCallback<T>) => RealtimeSubscription };\n  subscribe<T = unknown>(callback?: RealtimeCallback<T>): RealtimeSubscription;\n  unsubscribe(): void;\n  send(event: string, payload: unknown): void;\n}\n\nexport interface StorageFile {\n  name: string;\n  id: string;\n  updated_at: string;\n  created_at: string;\n  last_accessed_at: string;\n  metadata: Record<string, unknown>;\n  buckets: {\n    id: string;\n    name: string;\n    owner: string;\n    created_at: string;\n    updated_at: string;\n    public: boolean;\n  };\n}\n\nexport interface StorageUploadOptions {\n  cacheControl?: string;\n  contentType?: string;\n  upsert?: boolean;\n}\n\nexport interface StorageListOptions {\n  limit?: number;\n  offset?: number;\n  sortBy?: { column: string; order: 'asc' | 'desc' };\n  search?: string;\n}\n\nexport interface Functions {\n  invoke<T = unknown>(\n    functionName: string,\n    options?: {\n      body?: unknown;\n      headers?: Record<string, string>;\n    }\n  ): Promise<SupabaseResponse<T>>;\n}\n\nexport interface SignInCredentials {\n  email: string;\n  password: string;\n}\n\nexport interface SignUpCredentials {\n  email: string;\n  password: string;\n  options?: {\n    data?: Record<string, unknown>;\n  };\n}\n\nexport interface VerifyOtpParams {\n  token: string;\n  type: 'signup' | 'recovery' | 'email_change' | 'phone_change';\n}\n\nexport interface ResendParams {\n  type: 'signup' | 'recovery' | 'email_change' | 'phone_change';\n  email: string;\n}\n\nexport interface MockQueryState {\n  table: string;\n  columns?: string;\n  filters: Array<{\n    column: string;\n    operator: string;\n    value: unknown;\n  }>;\n  orderBy?: Array<{\n    column: string;\n    ascending: boolean;\n  }>;\n  limit?: number;\n  offset?: number;\n}\n\nexport interface TableQueryBuilder<T = unknown> {\n  select<U = T>(columns?: string): SelectQueryBuilder<U>;\n  insert<U = T>(data: U): InsertQueryBuilder<U>;\n  insert<U = T>(data: U[]): InsertQueryBuilder<U>;\n  update<U = T>(data: Partial<U>): UpdateQueryBuilder<U>;\n  update<U = T>(data: Partial<U>[]): UpdateQueryBuilder<U>;\n  delete<U = T>(): DeleteQueryBuilder<U>;\n}\n\nexport interface SelectQueryBuilder<T = unknown> {\n  eq(column: string, value: unknown): SelectQueryBuilder<T>;\n  ne(column: string, value: unknown): SelectQueryBuilder<T>;\n  gt(column: string, value: unknown): SelectQueryBuilder<T>;\n  gte(column: string, value: unknown): SelectQueryBuilder<T>;\n  lt(column: string, value: unknown): SelectQueryBuilder<T>;\n  lte(column: string, value: unknown): SelectQueryBuilder<T>;\n  like(column: string, pattern: string): SelectQueryBuilder<T>;\n  ilike(column: string, pattern: string): SelectQueryBuilder<T>;\n  in(column: string, values: unknown[]): SelectQueryBuilder<T>;\n  not(column: string, value: unknown): SelectQueryBuilder<T>;\n  or(filter: string): SelectQueryBuilder<T>;\n  and(filter: string): SelectQueryBuilder<T>;\n  order(\n    column: string,\n    options?: { ascending?: boolean }\n  ): SelectQueryBuilder<T>;\n  limit(count: number): SelectQueryBuilder<T>;\n  range(from: number, to: number): SelectQueryBuilder<T>;\n  abortSignal(signal: AbortSignal): SelectQueryBuilder<T>;\n  then<R>(\n    onfulfilled?: (value: SupabaseResponse<T[]>) => R | PromiseLike<R>\n  ): Promise<R>;\n  single(): Promise<SupabaseResponse<T>>;\n  maybeSingle(): Promise<SupabaseResponse<T>>;\n  count(\n    mode?: 'exact' | 'planned' | 'estimated'\n  ): Promise<SupabaseResponse<number>>;\n}\n\nexport interface InsertQueryBuilder<T = unknown> {\n  select<U = T>(columns?: string): SelectQueryBuilder<U>;\n  then<R>(\n    onfulfilled?: (value: SupabaseResponse<T[]>) => R | PromiseLike<R>\n  ): Promise<R>;\n  single(): Promise<SupabaseResponse<T>>;\n  maybeSingle(): Promise<SupabaseResponse<T>>;\n  count(\n    mode?: 'exact' | 'planned' | 'estimated'\n  ): Promise<SupabaseResponse<number>>;\n}\n\nexport interface UpdateQueryBuilder<T = unknown> {\n  eq(column: string, value: unknown): UpdateQueryBuilder<T>;\n  ne(column: string, value: unknown): UpdateQueryBuilder<T>;\n  gt(column: string, value: unknown): UpdateQueryBuilder<T>;\n  gte(column: string, value: unknown): UpdateQueryBuilder<T>;\n  lt(column: string, value: unknown): UpdateQueryBuilder<T>;\n  lte(column: string, value: unknown): UpdateQueryBuilder<T>;\n  like(column: string, pattern: string): UpdateQueryBuilder<T>;\n  ilike(column: string, pattern: string): UpdateQueryBuilder<T>;\n  in(column: string, values: unknown[]): UpdateQueryBuilder<T>;\n  not(column: string, value: unknown): UpdateQueryBuilder<T>;\n  or(filter: string): UpdateQueryBuilder<T>;\n  and(filter: string): UpdateQueryBuilder<T>;\n  select<U = T>(columns?: string): SelectQueryBuilder<U>;\n  then<R>(\n    onfulfilled?: (value: SupabaseResponse<T[]>) => R | PromiseLike<R>\n  ): Promise<R>;\n  single(): Promise<SupabaseResponse<T>>;\n  maybeSingle(): Promise<SupabaseResponse<T>>;\n  count(\n    mode?: 'exact' | 'planned' | 'estimated'\n  ): Promise<SupabaseResponse<number>>;\n}\n\nexport interface DeleteQueryBuilder<T = unknown> {\n  eq(column: string, value: unknown): DeleteQueryBuilder<T>;\n  ne(column: string, value: unknown): DeleteQueryBuilder<T>;\n  gt(column: string, value: unknown): DeleteQueryBuilder<T>;\n  gte(column: string, value: unknown): DeleteQueryBuilder<T>;\n  lt(column: string, value: unknown): DeleteQueryBuilder<T>;\n  lte(column: string, value: unknown): DeleteQueryBuilder<T>;\n  like(column: string, pattern: string): DeleteQueryBuilder<T>;\n  ilike(column: string, pattern: string): DeleteQueryBuilder<T>;\n  in(column: string, values: unknown[]): DeleteQueryBuilder<T>;\n  not(column: string, value: unknown): DeleteQueryBuilder<T>;\n  or(filter: string): DeleteQueryBuilder<T>;\n  and(filter: string): DeleteQueryBuilder<T>;\n  then<R>(\n    onfulfilled?: (value: SupabaseResponse<T[]>) => R | PromiseLike<R>\n  ): Promise<R>;\n  single(): Promise<SupabaseResponse<T>>;\n  maybeSingle(): Promise<SupabaseResponse<T>>;\n  count(\n    mode?: 'exact' | 'planned' | 'estimated'\n  ): Promise<SupabaseResponse<number>>;\n}\n\nexport interface StorageBucket {\n  id: string;\n  name: string;\n  owner: string;\n  created_at: string;\n  updated_at: string;\n  public: boolean;\n  upload(\n    path: string,\n    file: File | Blob,\n    options?: StorageUploadOptions\n  ): Promise<SupabaseResponse<StorageFile>>;\n  download(path: string): Promise<SupabaseResponse<Blob>>;\n  list(\n    path?: string,\n    options?: StorageListOptions\n  ): Promise<SupabaseResponse<StorageFile[]>>;\n  remove(paths: string[]): Promise<SupabaseResponse<StorageFile[]>>;\n  createSignedUrl(\n    path: string,\n    expiresIn: number\n  ): Promise<SupabaseResponse<{ signedUrl: string }>>;\n  createSignedUploadUrl(\n    path: string\n  ): Promise<\n    SupabaseResponse<{ signedUrl: string; path: string; token: string }>\n  >;\n  getPublicUrl(path: string): { data: { publicUrl: string } };\n  move(\n    fromPath: string,\n    toPath: string\n  ): Promise<SupabaseResponse<StorageFile>>;\n  copy(\n    fromPath: string,\n    toPath: string\n  ): Promise<SupabaseResponse<StorageFile>>;\n}\n\nexport interface MockSupabaseClient {\n  auth: {\n    getUser(): Promise<AuthResponse>;\n    getSession(): Promise<{\n      data: { session: Session | null };\n      error: PostgrestError | null;\n    }>;\n    signIn(credentials: SignInCredentials): Promise<AuthResponse>;\n    signInWithPassword(credentials: SignInCredentials): Promise<AuthResponse>;\n    signUp(credentials: SignUpCredentials): Promise<AuthResponse>;\n    signOut(): Promise<{ error: PostgrestError | null }>;\n    signInWithOAuth(provider: string): Promise<AuthResponse>;\n    resetPasswordForEmail(\n      email: string\n    ): Promise<{ data: Record<string, never>; error: PostgrestError | null }>;\n    verifyOtp(params: VerifyOtpParams): Promise<AuthResponse>;\n    resend(\n      params: ResendParams\n    ): Promise<{ data: Record<string, never>; error: PostgrestError | null }>;\n    onAuthStateChange(\n      callback: (event: string, session: Session | null) => void\n    ): {\n      data: { subscription: { unsubscribe: () => void } };\n    };\n    refreshSession(): Promise<AuthResponse>;\n    setSession(session: Session): Promise<AuthResponse>;\n    setUser(user: User): Promise<AuthResponse>;\n    updateUser(attributes: Partial<User>): Promise<AuthResponse>;\n  };\n  storage: {\n    from(bucket: string): StorageBucket;\n  };\n  functions: Functions;\n  realtime: {\n    channel(name: string): RealtimeChannel;\n    removeChannel(subscription: RealtimeSubscription): Promise<'ok'>;\n    removeAllChannels(): Promise<'ok'>;\n    getChannels(): RealtimeChannel[];\n  };\n  from<T = unknown>(table: string): TableQueryBuilder<T>;\n  channel(name: string): RealtimeChannel;\n  removeChannel(subscription: RealtimeSubscription): Promise<'ok'>;\n}\n\n// Table types\nexport type TableName = string;\nexport type TableRow<T extends TableName> = Record<string, unknown>;\n\n// Base mock configuration\nexport interface MockConfig {\n  delay?: number;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\__mocks__\\utils\\_core\\logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\assets\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\AdvancedPerformanceDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\AuthCallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\AuthDebug.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\BIFailureResolution\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\BaseModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ChallengeModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\CleaningSchedule\\CleaningScheduleCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\CleaningSchedule\\ScheduleConfiguration.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\CleaningSchedule\\ScheduleIntegrationSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\CompleteTaskButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\AiEfficiencyCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\CostSavingsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\EnhancedAiEfficiencyCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\GamificationStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\RealtimePerformanceCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\TeamPerformanceCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Dashboard\\TimeSavedCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\DataTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\EnvironmentalCleaning\\CleaningMetricsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\EnvironmentalCleaning\\EnvironmentalCleaningHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\EnvironmentalCleaning\\ScheduleSummaryCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\EnvironmentalCleaning\\TaskSummaryCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ErrorBoundary\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ErrorBoundary\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ErrorBoundary\\withErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Error\\InventoryErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\FilterSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Greeting.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\HeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Icon\\Icon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\BaseInventoryTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryExample.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryFooterControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\InventoryActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\InventoryHeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\InventoryTabHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\hooks\\useInventoryHeaderFocus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\hooks\\useInventoryHeaderKeyboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryHeaderSection\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\InventoryTableSection.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'items' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 26,
        "column": 24,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport Icon from '@mdi/react';\nimport { mdiPlus } from '@mdi/js';\nimport InventoryFilters from './filters/InventoryFilters';\nimport ExpandedFiltersPanel from './forms/ExpandedFiltersPanel';\nimport InventoryTables from './tables/InventoryTables';\nimport TableErrorBoundary from './tables/TableErrorBoundary';\nimport { useInventoryStore } from '@/store/useInventoryStore';\nimport { useInventoryDataAccess } from '@/hooks/inventory/useInventoryDataAccess';\nimport { InventoryItem } from '@/types/inventoryTypes';\n// import { inventoryServiceFacade } from '@/services/inventory/InventoryServiceFacade';\n\n// ‚ö†Ô∏è TRACKING FILTER LOGIC - DO NOT CHANGE:\n// \"Tracked Only\" filter should ONLY appear on Tools and Supplies tabs\n// Equipment and Hardware don't need tracking (doctors don't track desks/chairs)\n// This is intentional business logic, not a bug to fix\n//\n\ninterface Props {\n  onEdit: (item: InventoryItem) => void;\n  onDelete: (item: InventoryItem) => void;\n  items: InventoryItem[];\n}\n\nconst InventoryTableSection: React.FC<Props> = React.memo(\n  ({ onEdit, onDelete, items }) => {\n    // Get UI state and modal state from store\n    const {\n      activeTab,\n      showFilters,\n      setShowFilters,\n      searchQuery,\n      setSearchQuery,\n      categoryFilter: category,\n      setCategoryFilter,\n      locationFilter: location,\n      setLocationFilter,\n      showTrackedOnly,\n      setShowTrackedOnly,\n      showFavoritesOnly,\n      setShowFavoritesOnly,\n      itemsPerPage,\n      favorites,\n      toggleFavorite,\n      openAddModal,\n    } = useInventoryStore();\n\n    // Get categorized data from useInventoryDataAccess\n    const {\n      tools: inventoryData,\n      supplies: suppliesData,\n      equipment: equipmentData,\n      officeHardware: officeHardwareData,\n    } = useInventoryDataAccess();\n\n    // Create compatible filters object\n    const compatibleFilters = React.useMemo(\n      () => ({\n        searchQuery,\n        category,\n        location,\n        showTrackedOnly,\n        showFavoritesOnly,\n      }),\n      [searchQuery, category, location, showTrackedOnly, showFavoritesOnly]\n    );\n\n    // Memoize filter props to prevent unnecessary re-renders\n    const filterProps = React.useMemo(\n      () => ({\n        filters: compatibleFilters,\n        showFilters,\n        setShowFilters,\n        setSearchQuery,\n        onToggleTrackedFilter: () => {\n          // Toggle tracked filter logic - only for tools and supplies\n          if (activeTab === 'tools' || activeTab === 'supplies') {\n            setShowTrackedOnly(!showTrackedOnly);\n          }\n        },\n      }),\n      [\n        compatibleFilters,\n        showFilters,\n        setShowFilters,\n        setSearchQuery,\n        activeTab,\n        showTrackedOnly,\n        setShowTrackedOnly,\n      ]\n    );\n\n    // Memoize expanded filters props\n    const expandedFiltersProps = React.useMemo(\n      () => ({\n        activeTab,\n        filters: {\n          searchQuery,\n          category,\n          location,\n          showFavoritesOnly,\n        },\n        setCategoryFilter,\n        setLocationFilter,\n        setSearchQuery,\n        onToggleFavoritesFilter: () => {\n          setShowFavoritesOnly(!showFavoritesOnly);\n        },\n      }),\n      [\n        activeTab,\n        searchQuery,\n        category,\n        location,\n        showFavoritesOnly,\n        setCategoryFilter,\n        setLocationFilter,\n        setSearchQuery,\n        setShowFavoritesOnly,\n      ]\n    );\n\n    // Memoize table props\n    const tableProps = React.useMemo(\n      () => ({\n        activeTab,\n        filteredData: inventoryData,\n        filteredSuppliesData: suppliesData,\n        filteredEquipmentData: equipmentData,\n        filteredOfficeHardwareData: officeHardwareData,\n        handleEditClick: onEdit,\n        handleDeleteItem: onDelete,\n        handleToggleFavorite: toggleFavorite,\n        showTrackedOnly,\n        showFavoritesOnly,\n        itemsPerPage,\n        favorites,\n      }),\n      [\n        activeTab,\n        inventoryData,\n        suppliesData,\n        equipmentData,\n        officeHardwareData,\n        onEdit,\n        onDelete,\n        toggleFavorite,\n        showTrackedOnly,\n        showFavoritesOnly,\n        itemsPerPage,\n        favorites,\n      ]\n    );\n\n    // Get the table title based on active tab\n    const getTableTitle = () => {\n      switch (activeTab) {\n        case 'tools':\n          return 'Tools Table';\n        case 'supplies':\n          return 'Supplies Table';\n        case 'equipment':\n          return 'Equipment Table';\n        case 'officeHardware':\n          return 'Office Hardware Table';\n        default:\n          return 'Inventory Table';\n      }\n    };\n\n    // Get the subtext based on active tab\n    const getTableSubtext = () => {\n      switch (activeTab) {\n        case 'tools':\n          return 'Manage your tools inventory items';\n        case 'supplies':\n          return 'Manage your supplies inventory items';\n        case 'equipment':\n          return 'Manage your equipment inventory items';\n        case 'officeHardware':\n          return 'Manage your office hardware inventory items';\n        default:\n          return 'Manage your inventory items';\n      }\n    };\n\n    return (\n      <div role=\"region\" aria-label={`${activeTab} inventory table section`}>\n        {/* Table Title and Add Item Button */}\n        <div className=\"flex justify-between items-center mb-4\">\n          <div>\n            <h2 className=\"text-2xl font-bold text-gray-900\">\n              {getTableTitle()}\n            </h2>\n            <p className=\"text-sm text-gray-600 mt-1\">{getTableSubtext()}</p>\n          </div>\n          <button\n            onClick={openAddModal}\n            className=\"px-4 py-2 bg-[#4ECDC4] hover:bg-[#3db8b0] text-white rounded-lg font-medium flex items-center gap-2 transition-colors duration-200 shadow-sm hover:shadow-md\"\n            aria-label=\"Add new item to inventory\"\n          >\n            <Icon path={mdiPlus} size={1} />\n            Add Item\n          </button>\n        </div>\n\n        {/* Filters */}\n        <div className=\"mb-4\">\n          <InventoryFilters {...filterProps} />\n        </div>\n\n        {showFilters && (\n          <div id=\"expanded-filters-panel\">\n            <ExpandedFiltersPanel {...expandedFiltersProps} />\n          </div>\n        )}\n        <TableErrorBoundary>\n          <InventoryTables {...tableProps} />\n        </TableErrorBoundary>\n      </div>\n    );\n  }\n);\n\nInventoryTableSection.displayName = 'InventoryTableSection';\n\nexport default InventoryTableSection;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\SupabaseConnectionTest.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TableActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TableHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TablePagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TableRow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TrackedToolsDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\TrackedToolsNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\VirtualizedInventoryTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\VirtualizedTableRow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\AIInsightsDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\CategoriesCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\InventoryAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\InventoryDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\InventoryInsightsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\analytics\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\examples\\DataManagerExample.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\features\\InventoryContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\features\\InventoryLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\filters\\FiltersCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\filters\\InventoryFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\filters\\InventoryTabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\filters\\TabSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\filters\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\forms\\AddItemButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\forms\\CategoryManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\forms\\ExpandedFiltersPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\forms\\LocationPicker.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\forms\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\AIEnhancedScanModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\AddItemModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\DeleteConfirmationModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\EditItemModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\EnhancedTrackModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\InventoryModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\ModalContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\ScanItemModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\TrackItemsModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\UploadBarcodeModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\modals\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\tables\\InventoryTables.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\tables\\TableErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\tables\\base\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\tables\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\tables\\types\\tableTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\HeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryExample.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryFooterControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryHeaderActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryHeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryHeaderTitle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryItemsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryItemsPerPageSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryPagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryPaginationControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventorySearchAndFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\InventoryTabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\ItemScannerCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Inventory\\ui\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Layout\\PageLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Layout\\SharedLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\LeaderboardModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\LoadingSpinner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\LoginErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\LoginForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\LoginFormInputs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\LoginLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\LoginProgressIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\OAuthButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\OfflineWarning.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Login\\SecurityStatusBadge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\MetricsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ModalContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\NavBar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\NavBar\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Navigation\\DrawerMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\PerformanceDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\PerformanceMetrics\\PerformanceMetrics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\PerformanceMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ProtectedRoute.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ScanRoomModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ServiceConsolidationDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\SessionStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\AIDailyTaskConfig.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\AdminTaskConfigPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\components\\ActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\components\\BasicDetails.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\components\\SchedulingConfiguration.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\data\\categories.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\hooks\\useChecklistFormState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistForm\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistItemForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\ChecklistManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\RoomForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\RoomList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\RoomManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\SchedulingConfig.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\StatusBundleManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Settings\\StatusTypeManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\SocialLoginButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\StatsModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AIEnhancedScannerInterface.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\BITestResults.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\KPICard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\PerformanceChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\PerformanceMetricsDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\RecentActivity.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\SterilizationAIInsightsDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\ToolStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\TrendScore.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\AIInsightsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\DashboardControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\HistoricalTrends.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\PredictiveAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\QuickStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\hooks\\useAnalyticsData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\hooks\\useSterilizationAIDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Analytics\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AutoclaveReceiptUpload\\CameraCapture.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 59,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useRef, useCallback, useState } from 'react';\nimport { mdiCamera, mdiCheck, mdiClose } from '@mdi/js';\nimport Icon from '@mdi/react';\n\ninterface CameraCaptureProps {\n  isMobile: boolean;\n  hasCamera: boolean;\n  onPhotoCapture: (file: File, previewUrl: string) => void;\n}\n\nconst CameraCapture: React.FC<CameraCaptureProps> = ({\n  isMobile,\n  hasCamera,\n  onPhotoCapture,\n}) => {\n  const [showCamera, setShowCamera] = useState(false);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n\n  /**\n   * Start camera stream\n   */\n  const startCamera = useCallback(async () => {\n    // Prevent camera access on desktop devices\n    if (!isMobile) {\n      alert(\n        'Camera access is only available on mobile devices. Please use the file upload option instead.'\n      );\n      return;\n    }\n\n    // Check if camera is available\n    if (!hasCamera) {\n      alert(\n        'No camera detected on this device. Please use file upload instead.'\n      );\n      return;\n    }\n\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          facingMode: 'environment', // Use back camera on mobile\n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n        },\n      });\n\n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        streamRef.current = stream;\n        setShowCamera(true);\n      }\n    } catch (err) { console.error(err); throw err; }\n      // Error handling without console logging\n      alert('Unable to access camera. Please use file upload instead.');\n    }\n  }, [isMobile, hasCamera]);\n\n  /**\n   * Stop camera stream\n   */\n  const stopCamera = useCallback(() => {\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach((track) => track.stop());\n      streamRef.current = null;\n    }\n    setShowCamera(false);\n  }, []);\n\n  /**\n   * Capture photo from camera\n   */\n  const capturePhoto = useCallback(() => {\n    if (videoRef.current && canvasRef.current) {\n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n\n      if (context) {\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        context.drawImage(video, 0, 0);\n\n        canvas.toBlob(\n          (blob) => {\n            if (blob) {\n              // Create file object for upload (not stored locally)\n              const file = new File([blob], `receipt-${Date.now()}.jpg`, {\n                type: 'image/jpeg',\n              });\n\n              // Create temporary preview URL (will be revoked after upload)\n              const previewUrl = URL.createObjectURL(blob);\n              onPhotoCapture(file, previewUrl);\n\n              // Clean up camera\n              stopCamera();\n            }\n          },\n          'image/jpeg',\n          0.8\n        );\n      }\n    }\n  }, [onPhotoCapture, stopCamera]);\n\n  if (!isMobile || !hasCamera) {\n    return null;\n  }\n\n  return (\n    <>\n      <button\n        type=\"button\"\n        onClick={startCamera}\n        className=\"w-full flex items-center justify-center space-x-2 px-4 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\n      >\n        <Icon path={mdiCamera} size={1.2} />\n        <span>Take Photo</span>\n      </button>\n\n      {/* Camera Interface */}\n      {showCamera && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg p-4 max-w-sm w-full mx-4\">\n            <div className=\"relative\">\n              <video\n                ref={videoRef}\n                autoPlay\n                playsInline\n                className=\"w-full h-64 object-cover rounded-md\"\n              >\n                <track kind=\"captions\" />\n              </video>\n              <canvas ref={canvasRef} className=\"hidden\" />\n            </div>\n\n            <div className=\"flex space-x-2 mt-4\">\n              <button\n                type=\"button\"\n                onClick={capturePhoto}\n                className=\"flex-1 flex items-center justify-center space-x-2 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors\"\n              >\n                <Icon path={mdiCheck} size={1} />\n                <span>Capture</span>\n              </button>\n              <button\n                type=\"button\"\n                onClick={stopCamera}\n                className=\"flex-1 flex items-center justify-center space-x-2 px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors\"\n              >\n                <Icon path={mdiClose} size={1} />\n                <span>Cancel</span>\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default CameraCapture;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AutoclaveReceiptUpload\\FileUpload.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AutoclaveReceiptUpload\\ReceiptFormFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AutoclaveReceiptUpload\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\AutoclaveReceiptViewer.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 314,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { mdiEye, mdiDelete, mdiDownload, mdiMagnify, mdiFilter } from '@mdi/js';\nimport Icon from '@mdi/react';\nimport { useAutoclaveReceipts } from '../../hooks/useAutoclaveReceipts';\nimport { AutoclaveReceipt } from '../../types/sterilizationTypes';\n\ninterface AutoclaveReceiptViewerProps {\n  batchCode?: string; // If provided, only show receipts for this batch\n  onClose?: () => void;\n}\n\nconst AutoclaveReceiptViewer: React.FC<AutoclaveReceiptViewerProps> = ({\n  batchCode,\n  onClose,\n}) => {\n  const {\n    receipts,\n    loading,\n    error,\n    loadReceiptsByBatch,\n    loadAllReceipts,\n    deleteReceipt,\n  } = useAutoclaveReceipts();\n\n  const [searchTerm, setSearchTerm] = useState('');\n  const [filterExpired, setFilterExpired] = useState(false);\n  const [selectedReceipt, setSelectedReceipt] =\n    useState<AutoclaveReceipt | null>(null);\n\n  // Load receipts on component mount\n  useEffect(() => {\n    if (batchCode) {\n      loadReceiptsByBatch(batchCode);\n    } else {\n      loadAllReceipts();\n    }\n  }, [batchCode, loadReceiptsByBatch, loadAllReceipts]);\n\n  // Filter receipts based on search and filter criteria\n  const filteredReceipts = receipts.filter((receipt) => {\n    const matchesSearch =\n      receipt.batchCode.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      receipt.cycleNumber?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      receipt.uploadedBy.toLowerCase().includes(searchTerm.toLowerCase());\n\n    const matchesExpiredFilter = filterExpired ? receipt.isExpired : true;\n\n    return matchesSearch && matchesExpiredFilter;\n  });\n\n  const handleDeleteReceipt = async (receipt: AutoclaveReceipt) => {\n    if (\n      window.confirm(\n        `Are you sure you want to delete this receipt for batch ${receipt.batchCode}?`\n      )\n    ) {\n      try {\n        await deleteReceipt(receipt.id);\n      } catch (err) { console.error(err); throw err; }\n        // Error handling without console logging\n      }\n    }\n  };\n\n  const handleViewReceipt = (receipt: AutoclaveReceipt) => {\n    setSelectedReceipt(receipt);\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  const formatDate = (date: Date) => {\n    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();\n  };\n\n  return (\n    <div className=\"p-6 bg-white rounded-lg shadow-lg max-w-4xl mx-auto\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <h2 className=\"text-xl font-semibold text-gray-800\">\n          Autoclave Receipts\n          {batchCode && ` - Batch ${batchCode}`}\n        </h2>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"text-gray-400 hover:text-gray-600 transition-colors\"\n          >\n            <Icon path={mdiEye} size={1.2} />\n          </button>\n        )}\n      </div>\n\n      {/* Search and Filter */}\n      <div className=\"flex space-x-4 mb-6\">\n        <div className=\"flex-1 relative\">\n          <Icon\n            path={mdiMagnify}\n            size={1}\n            className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400\"\n          />\n          <input\n            type=\"text\"\n            placeholder=\"Search by batch code, cycle number, or operator...\"\n            value={searchTerm}\n            onChange={(e) => setSearchTerm(e.target.value)}\n            className=\"w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n          />\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <Icon path={mdiFilter} size={1} className=\"text-gray-400\" />\n          <label className=\"flex items-center space-x-2 text-sm\">\n            <input\n              type=\"checkbox\"\n              checked={filterExpired}\n              onChange={(e) => setFilterExpired(e.target.checked)}\n              className=\"rounded border-gray-300\"\n            />\n            <span>Show expired only</span>\n          </label>\n        </div>\n      </div>\n\n      {/* Loading State */}\n      {loading && (\n        <div className=\"flex items-center justify-center py-8\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n          <span className=\"ml-2 text-gray-600\">Loading receipts...</span>\n        </div>\n      )}\n\n      {/* Error State */}\n      {error && (\n        <div className=\"p-4 bg-red-50 border border-red-200 rounded-md mb-4\">\n          <p className=\"text-red-800\">{error}</p>\n        </div>\n      )}\n\n      {/* Receipts List */}\n      {!loading && !error && (\n        <div className=\"space-y-4\">\n          {filteredReceipts.length === 0 ? (\n            <div className=\"text-center py-8 text-gray-500\">\n              <p>No receipts found</p>\n              {searchTerm && (\n                <p className=\"text-sm mt-1\">\n                  Try adjusting your search criteria\n                </p>\n              )}\n            </div>\n          ) : (\n            filteredReceipts.map((receipt) => (\n              <div\n                key={receipt.id}\n                className={`p-4 border rounded-lg ${\n                  receipt.isExpired\n                    ? 'border-red-200 bg-red-50'\n                    : 'border-gray-200 bg-gray-50'\n                }`}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex-1\">\n                    <div className=\"flex items-center space-x-4\">\n                      <div>\n                        <h3 className=\"font-medium text-gray-900\">\n                          Batch: {receipt.batchCode}\n                        </h3>\n                        {receipt.cycleNumber && (\n                          <p className=\"text-sm text-gray-600\">\n                            Cycle: {receipt.cycleNumber}\n                          </p>\n                        )}\n                      </div>\n                      <div className=\"text-sm text-gray-600\">\n                        <p>Uploaded: {formatDate(receipt.uploadedAt)}</p>\n                        <p>By: {receipt.uploadedBy}</p>\n                      </div>\n                      <div className=\"text-sm text-gray-600\">\n                        <p>Size: {formatFileSize(receipt.photoSize)}</p>\n                        <p>Expires: {formatDate(receipt.retentionUntil)}</p>\n                      </div>\n                    </div>\n                    {receipt.temperatureEvidence && (\n                      <p className=\"text-sm text-gray-600 mt-2\">\n                        <span className=\"font-medium\">\n                          Temperature Evidence:\n                        </span>{' '}\n                        {receipt.temperatureEvidence}\n                      </p>\n                    )}\n                    {receipt.isExpired && (\n                      <span className=\"inline-block px-2 py-1 text-xs bg-red-100 text-red-800 rounded-full mt-2\">\n                        EXPIRED\n                      </span>\n                    )}\n                  </div>\n                  <div className=\"flex space-x-2 ml-4\">\n                    <button\n                      onClick={() => handleViewReceipt(receipt)}\n                      className=\"p-2 text-blue-600 hover:text-blue-800 hover:bg-blue-50 rounded-md transition-colors\"\n                      title=\"View receipt\"\n                    >\n                      <Icon path={mdiEye} size={1} />\n                    </button>\n                    <a\n                      href={receipt.photoUrl}\n                      download={receipt.photoFilename}\n                      className=\"p-2 text-green-600 hover:text-green-800 hover:bg-green-50 rounded-md transition-colors\"\n                      title=\"Download receipt\"\n                    >\n                      <Icon path={mdiDownload} size={1} />\n                    </a>\n                    <button\n                      onClick={() => handleDeleteReceipt(receipt)}\n                      className=\"p-2 text-red-600 hover:text-red-800 hover:bg-red-50 rounded-md transition-colors\"\n                      title=\"Delete receipt\"\n                    >\n                      <Icon path={mdiDelete} size={1} />\n                    </button>\n                  </div>\n                </div>\n              </div>\n            ))\n          )}\n        </div>\n      )}\n\n      {/* Receipt Detail Modal */}\n      {selectedReceipt && (\n        <div className=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <h3 className=\"text-lg font-semibold\">\n                Receipt Details - Batch {selectedReceipt.batchCode}\n              </h3>\n              <button\n                onClick={() => setSelectedReceipt(null)}\n                className=\"text-gray-400 hover:text-gray-600 transition-colors\"\n              >\n                <Icon path={mdiEye} size={1.2} />\n              </button>\n            </div>\n\n            <div className=\"space-y-4\">\n              <img\n                src={selectedReceipt.photoUrl}\n                alt=\"Autoclave receipt\"\n                className=\"w-full max-h-96 object-contain border border-gray-300 rounded-md\"\n              />\n\n              <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                <div>\n                  <p>\n                    <span className=\"font-medium\">Batch Code:</span>{' '}\n                    {selectedReceipt.batchCode}\n                  </p>\n                  {selectedReceipt.cycleNumber && (\n                    <p>\n                      <span className=\"font-medium\">Cycle Number:</span>{' '}\n                      {selectedReceipt.cycleNumber}\n                    </p>\n                  )}\n                  <p>\n                    <span className=\"font-medium\">Uploaded:</span>{' '}\n                    {formatDate(selectedReceipt.uploadedAt)}\n                  </p>\n                  <p>\n                    <span className=\"font-medium\">By:</span>{' '}\n                    {selectedReceipt.uploadedBy}\n                  </p>\n                </div>\n                <div>\n                  <p>\n                    <span className=\"font-medium\">File Size:</span>{' '}\n                    {formatFileSize(selectedReceipt.photoSize)}\n                  </p>\n                  <p>\n                    <span className=\"font-medium\">Expires:</span>{' '}\n                    {formatDate(selectedReceipt.retentionUntil)}\n                  </p>\n                  <p>\n                    <span className=\"font-medium\">Status:</span>\n                    <span\n                      className={`ml-1 px-2 py-1 text-xs rounded-full ${\n                        selectedReceipt.isExpired\n                          ? 'bg-red-100 text-red-800'\n                          : 'bg-green-100 text-green-800'\n                      }`}\n                    >\n                      {selectedReceipt.isExpired ? 'EXPIRED' : 'ACTIVE'}\n                    </span>\n                  </p>\n                </div>\n              </div>\n\n              {selectedReceipt.temperatureEvidence && (\n                <div>\n                  <p className=\"font-medium\">Temperature Evidence:</p>\n                  <p className=\"text-gray-600\">\n                    {selectedReceipt.temperatureEvidence}\n                  </p>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default AutoclaveReceiptViewer;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailConfirmationModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureIncidentDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\BIFailureWorkflowSteps.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\AffectedCyclesList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\AffectedToolsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\ModalHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\OperatorConfirmation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\QuarantineSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\RequiredActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\components\\WarningMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\hooks\\useBIFailureResolution.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'result' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 125,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 125,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useState } from 'react';\nimport { useSterilizationStore } from '@/store/sterilizationStore';\nimport { BIFailureIncidentService } from '@/services/bi/failure/BIFailureIncidentService';\nimport { CreateBIFailureParams } from '@/services/bi/failure/BIFailureValidationService';\nimport { BIFailureError } from '@/services/bi/failure/BIFailureError';\n\n/**\n * Get current operator ID from Supabase auth service\n * Uses the comprehensive SupabaseAuthService for proper authentication\n */\nconst getCurrentOperatorId = async (): Promise<string> => {\n  try {\n    // Import the Supabase auth service\n    const { SupabaseAuthService } = await import(\n      '@/services/supabase/authService'\n    );\n\n    // Get current user from Supabase auth service\n    const { user, error } = await SupabaseAuthService.getCurrentUser();\n\n    if (error) {\n      console.warn('Auth service error:', error);\n    }\n\n    if (user?.id) {\n      return user.id;\n    }\n\n    // Fallback to session storage for development/testing\n    const storedOperatorId =\n      sessionStorage.getItem('currentOperatorId') ||\n      localStorage.getItem('currentOperatorId');\n\n    if (storedOperatorId) {\n      return storedOperatorId;\n    }\n\n    // Development fallback for testing\n    if (process.env.NODE_ENV === 'development') {\n      const devOperatorId = 'dev-operator-001';\n      return devOperatorId;\n    }\n\n    // Production fallback - this should not happen in production\n    console.error(\n      'No operator ID found in production. User may not be authenticated.'\n    );\n    throw new Error('User not authenticated - no operator ID available');\n  } catch (error) {\n    console.error('Failed to get operator ID:', error);\n\n    // In development, provide a fallback to prevent blocking\n    if (process.env.NODE_ENV === 'development') {\n      return 'dev-operator-001';\n    }\n\n    // In production, re-throw the error to prevent invalid operations\n    throw new Error('Authentication required - unable to get operator ID');\n  }\n};\n\n/**\n * Props for the useBIFailureResolution hook.\n * @interface UseBIFailureResolutionProps\n * @property {() => void} onClose - Callback when the resolution modal is closed\n * @property {() => void} onSuccess - Callback when resolution is successful\n */\ninterface UseBIFailureResolutionProps {\n  onClose: () => void;\n  onSuccess: () => void;\n}\n\n/**\n * Error state interface for BI failure resolution.\n * @interface ErrorState\n */\ninterface ErrorState {\n  message: string;\n  code?: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  retryable: boolean;\n}\n\n/**\n * Custom hook that provides logic for managing BI Failure Resolution workflows.\n * Handles incident resolution, error handling, and UI state management.\n * Provides utility functions for resolution workflow and user feedback.\n *\n * @param {UseBIFailureResolutionProps} props - Configuration object containing callbacks\n * @returns {object} Object containing all BI failure resolution logic functions and state\n */\nexport const useBIFailureResolution = ({\n  onClose,\n  onSuccess,\n}: UseBIFailureResolutionProps) => {\n  const { biFailureDetails, deactivateBIFailure } = useSterilizationStore();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<ErrorState | null>(null);\n  const [showExposureReport, setShowExposureReport] = useState(false);\n  const [resolutionNotes, setResolutionNotes] = useState('');\n\n  /**\n   * Handles the resolution of BI failure incidents with validation and error handling.\n   * Processes resolution workflow, shows appropriate error messages, and triggers success callbacks.\n   */\n  const handleResolve = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Get operator ID from auth context or use fallback\n      const operatorId = await getCurrentOperatorId();\n\n      // Check if we have a valid incident to resolve\n      if (!biFailureDetails) {\n        throw new Error('No BI failure incident to resolve');\n      }\n\n      // Since the sterilization store doesn't maintain incident IDs, we'll create a new incident\n      // and then immediately resolve it, or use a session-based approach\n      const incidentId =\n        sessionStorage.getItem('currentBIFailureIncidentId') ||\n        `temp-${Date.now()}`;\n\n      const result = await BIFailureIncidentService.resolveIncident({\n        incidentId: incidentId,\n        resolvedByOperatorId: operatorId,\n        resolutionNotes,\n      });\n\n      deactivateBIFailure();\n      onSuccess();\n      onClose();\n    } catch (error) {\n      console.error('Failed to resolve BI failure incident:', error);\n\n      if (error instanceof BIFailureError) {\n        setError({\n          message: error.message,\n          code: error.code,\n          severity: error.severity,\n          retryable: error.retryable,\n        });\n      } else if (\n        error &&\n        typeof error === 'object' &&\n        'name' in error &&\n        error.name === 'BIFailureError'\n      ) {\n        const biError = error as BIFailureError;\n        setError({\n          message: biError.message,\n          code: biError.code,\n          severity: biError.severity,\n          retryable: biError.retryable,\n        });\n      } else {\n        setError({\n          message:\n            error instanceof Error\n              ? error.message\n              : 'An unexpected error occurred',\n          severity: 'high',\n          retryable: false,\n        });\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    resolutionNotes,\n    deactivateBIFailure,\n    onSuccess,\n    onClose,\n    biFailureDetails,\n  ]);\n\n  /**\n   * Creates a new BI failure incident when a failure is detected\n   */\n  const createIncident = useCallback(\n    async (failureData: {\n      facilityId: string;\n      affectedToolsCount: number;\n      affectedBatchIds: string[];\n      failureReason?: string;\n      severityLevel?: 'low' | 'medium' | 'high' | 'critical';\n    }) => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Get operator ID from auth context or use fallback\n        const operatorId = await getCurrentOperatorId();\n\n        const incidentParams: CreateBIFailureParams = {\n          facility_id: failureData.facilityId,\n          detected_by_operator_id: operatorId,\n          affected_tools_count: failureData.affectedToolsCount,\n          affected_batch_ids: failureData.affectedBatchIds,\n          failure_reason: failureData.failureReason,\n          severity_level: failureData.severityLevel || 'high',\n        };\n\n        const incident =\n          await BIFailureIncidentService.createIncident(incidentParams);\n\n        return incident;\n      } catch (error) {\n        console.error('Failed to create BI failure incident:', error);\n\n        if (error instanceof BIFailureError) {\n          setError({\n            message: error.message,\n            code: error.code,\n            severity: error.severity,\n            retryable: error.retryable,\n          });\n        } else {\n          setError({\n            message:\n              error instanceof Error\n                ? error.message\n                : 'Failed to create incident',\n            severity: 'high',\n            retryable: false,\n          });\n        }\n        throw error;\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    []\n  );\n\n  /**\n   * Handles retry attempts for failed resolution operations.\n   */\n  const handleRetry = useCallback(() => {\n    setError(null);\n    handleResolve();\n  }, [handleResolve]);\n\n  /**\n   * Handles closing the resolution modal and cleaning up state.\n   */\n  const handleClose = useCallback(() => {\n    setError(null);\n    setShowExposureReport(false);\n    onClose();\n  }, [onClose]);\n\n  /**\n   * Handles backdrop click events for modal dismissal.\n   */\n  const handleBackdropClick = useCallback(\n    (e: React.MouseEvent) => {\n      if (e.target === e.currentTarget) {\n        handleClose();\n      }\n    },\n    [handleClose]\n  );\n\n  /**\n   * Handles keyboard events for modal interaction.\n   */\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        handleClose();\n      }\n    },\n    [handleClose]\n  );\n\n  /**\n   * Toggles the exposure report display.\n   */\n  const toggleExposureReport = useCallback(() => {\n    setShowExposureReport((prev) => !prev);\n  }, []);\n\n  /**\n   * Updates resolution notes.\n   */\n  const updateResolutionNotes = useCallback((notes: string) => {\n    setResolutionNotes(notes);\n  }, []);\n\n  /**\n   * Gets the error icon based on severity level.\n   */\n  const getErrorIcon = useCallback(() => {\n    // This would return the appropriate icon path based on severity\n    // Implementation would depend on the icon library being used\n    return 'mdiAlertCircle'; // Default icon\n  }, []);\n\n  /**\n   * Gets the error color classes based on severity level.\n   */\n  const getErrorColor = useCallback((severity: string) => {\n    switch (severity) {\n      case 'critical':\n        return 'text-red-600 bg-red-50 border-red-200';\n      case 'high':\n        return 'text-orange-600 bg-orange-50 border-orange-200';\n      case 'medium':\n        return 'text-yellow-600 bg-yellow-50 border-yellow-200';\n      default:\n        return 'text-gray-600 bg-gray-50 border-gray-200';\n    }\n  }, []);\n\n  /**\n   * Checks if the resolution button should be disabled.\n   */\n  const isResolveButtonDisabled = useCallback(() => {\n    return isLoading || !biFailureDetails;\n  }, [isLoading, biFailureDetails]);\n\n  /**\n   * Gets the resolve button text based on current state.\n   */\n  const getResolveButtonText = useCallback(() => {\n    if (isLoading) return 'Resolving...';\n    return 'Confirm Resolution';\n  }, [isLoading]);\n\n  return {\n    // State\n    isLoading,\n    error,\n    showExposureReport,\n    resolutionNotes,\n    biFailureDetails,\n\n    // Actions\n    handleResolve,\n    createIncident,\n    handleRetry,\n    handleClose,\n    handleBackdropClick,\n    handleKeyDown,\n    toggleExposureReport,\n    updateResolutionNotes,\n\n    // Utilities\n    getErrorIcon,\n    getErrorColor,\n    isResolveButtonDisabled,\n    getResolveButtonText,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\hooks\\useQuarantineData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIFailureResolution\\index.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "jsx-a11y/no-noninteractive-element-interactions",
        "severity": 2,
        "message": "Non-interactive elements should not be assigned mouse or keyboard event listeners.",
        "line": 94,
        "column": 7,
        "nodeType": "JSXOpeningElement",
        "endLine": 100,
        "endColumn": 8,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BIIndicatorDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BITestBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BatchCodeModal.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 191,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect, useState } from 'react';\nimport { useSterilizationStore } from '../../store/sterilizationStore';\nimport { mdiQrcode, mdiClose, mdiPrinter, mdiContentCopy } from '@mdi/js';\nimport Icon from '../Icon/Icon';\n\ninterface BatchCodeModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nconst BatchCodeModal: React.FC<BatchCodeModalProps> = ({ isOpen, onClose }) => {\n  const { lastGeneratedCode, setShowBatchCodeModal } = useSterilizationStore();\n  const [copied, setCopied] = useState(false);\n\n  useEffect(() => {\n    if (!isOpen) {\n      setShowBatchCodeModal(false);\n    }\n  }, [isOpen, setShowBatchCodeModal]);\n\n  const handleClose = () => {\n    setShowBatchCodeModal(false);\n    onClose();\n  };\n\n  const handleCopyCode = async () => {\n    if (lastGeneratedCode?.code) {\n      try {\n        await navigator.clipboard.writeText(lastGeneratedCode.code);\n        setCopied(true);\n        setTimeout(() => setCopied(false), 2000);\n      } catch (err) { console.error(err); throw err; }\n        // Error handling without console logging\n      }\n    }\n  };\n\n  const handlePrint = () => {\n    const printWindow = window.open('', '_blank');\n    if (printWindow && lastGeneratedCode) {\n      printWindow.document.write(`\n        <html>\n          <head>\n            <title>Batch Code - ${lastGeneratedCode.code}</title>\n            <style>\n              body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }\n              .batch-code { font-size: 48px; font-weight: bold; margin: 20px 0; }\n              .info { font-size: 16px; margin: 10px 0; }\n              .instructions { text-align: left; margin: 20px 0; }\n              @media print { body { margin: 0; } }\n            </style>\n          </head>\n          <body>\n            <h1>Batch Code</h1>\n            <div class=\"batch-code\">${lastGeneratedCode.code}</div>\n            <div class=\"info\">\n              <p><strong>Generated:</strong> ${lastGeneratedCode.generatedAt.toLocaleString()}</p>\n              <p><strong>Operator:</strong> ${lastGeneratedCode.operator}</p>\n              <p><strong>Tools:</strong> ${lastGeneratedCode.toolCount}</p>\n            </div>\n            <div class=\"instructions\">\n              <h3>Instructions:</h3>\n              <ol>\n                <li>Write this batch code clearly on the package</li>\n                <li>Add today's date</li>\n                <li>Add your name (${lastGeneratedCode.operator})</li>\n                <li>Place package in autoclave</li>\n              </ol>\n            </div>\n          </body>\n        </html>\n      `);\n      printWindow.document.close();\n      printWindow.print();\n    }\n  };\n\n  if (!isOpen || !lastGeneratedCode) {\n    return null;\n  }\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6\">\n        {/* Header */}\n        <div className=\"flex justify-between items-center mb-6\">\n          <div className=\"flex items-center space-x-2\">\n            <Icon path={mdiQrcode} size={1.5} className=\"text-purple-600\" />\n            <h2 className=\"text-xl font-semibold text-gray-800\">\n              Batch Code Generated\n            </h2>\n          </div>\n          <button\n            onClick={handleClose}\n            className=\"p-1 text-gray-400 hover:text-gray-600 transition-colors\"\n          >\n            <Icon path={mdiClose} size={1.5} />\n          </button>\n        </div>\n\n        {/* Batch Code Display */}\n        <div className=\"text-center mb-6\">\n          <div className=\"bg-purple-50 border-2 border-purple-200 rounded-lg p-6 mb-4\">\n            <p className=\"text-sm text-purple-600 mb-2\">Your Batch Code</p>\n            <div className=\"text-3xl font-bold text-purple-800 font-mono tracking-wider\">\n              {lastGeneratedCode.code}\n            </div>\n          </div>\n\n          {/* Code Info */}\n          <div className=\"text-sm text-gray-600 space-y-1\">\n            <p>\n              <strong>Generated:</strong>{' '}\n              {lastGeneratedCode.generatedAt.toLocaleString()}\n            </p>\n            <p>\n              <strong>Operator:</strong> {lastGeneratedCode.operator}\n            </p>\n            <p>\n              <strong>Tools:</strong> {lastGeneratedCode.toolCount}\n            </p>\n            <p>\n              <strong>Type:</strong>{' '}\n              {lastGeneratedCode.isSingleTool ? 'Single Tool' : 'Batch'}\n            </p>\n          </div>\n        </div>\n\n        {/* Instructions */}\n        <div className=\"mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg\">\n          <h3 className=\"font-medium text-blue-800 mb-3\">Instructions</h3>\n          <ol className=\"text-sm text-blue-700 space-y-2\">\n            <li className=\"flex items-start\">\n              <span className=\"font-bold mr-2\">1.</span>\n              <span>Write this batch code clearly on the package</span>\n            </li>\n            <li className=\"flex items-start\">\n              <span className=\"font-bold mr-2\">2.</span>\n              <span>Add today's date: {new Date().toLocaleDateString()}</span>\n            </li>\n            <li className=\"flex items-start\">\n              <span className=\"font-bold mr-2\">3.</span>\n              <span>Add your name: {lastGeneratedCode.operator}</span>\n            </li>\n            <li className=\"flex items-start\">\n              <span className=\"font-bold mr-2\">4.</span>\n              <span>Place package in autoclave for sterilization</span>\n            </li>\n          </ol>\n        </div>\n\n        {/* Action Buttons */}\n        <div className=\"flex space-x-3\">\n          <button\n            onClick={handleCopyCode}\n            className=\"flex-1 flex items-center justify-center space-x-2 px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-colors\"\n          >\n            <Icon path={mdiContentCopy} size={1} />\n            <span>{copied ? 'Copied!' : 'Copy Code'}</span>\n          </button>\n          <button\n            onClick={handlePrint}\n            className=\"flex-1 flex items-center justify-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\n          >\n            <Icon path={mdiPrinter} size={1} />\n            <span>Print</span>\n          </button>\n        </div>\n\n        {/* Close Button */}\n        <div className=\"mt-4\">\n          <button\n            onClick={handleClose}\n            className=\"w-full px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors\"\n          >\n            Done\n          </button>\n        </div>\n\n        {/* Important Note */}\n        <div className=\"mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg\">\n          <p className=\"text-sm text-yellow-800\">\n            <strong>Important:</strong> This batch code is now tracked in the\n            system. If a BI failure occurs, all tools in this batch will be\n            affected.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default BatchCodeModal;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BatchTrackingPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTestPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\BITestActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\BITestContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\BITestHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\BITestResultSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\BITestWarning.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\BiologicalIndicatorTest\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\CIIndicatorDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\CleaningLogTracker.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\CleaningLogTracker\\CleaningLogFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\CleaningLogTracker\\CleaningLogHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\CleaningLogTracker\\CleaningLogStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ComplianceSettingsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\CycleControlPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\DashboardTabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\NewCycleModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\hooks\\useDashboardState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\Dashboard\\index.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleBITestDismiss' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 124,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 124,
        "endColumn": 30,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\GlobalBIFailureBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PatientExposureReport.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimerTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseTimerAlerts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseTimerControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseTimerExpanded.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timerStatus' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 43,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 43,
        "endColumn": 14,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'currentCycleId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 45,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 45,
        "endColumn": 17,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseTimerHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseTimerProgress.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\PhaseToolList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\hooks\\usePhaseTimerState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\PhaseTimer\\index.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isRunning' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 56,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 56,
        "endColumn": 14,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'setRunning' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 60,
        "column": 19,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 60,
        "endColumn": 29,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'pauseTimer' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 68,
        "column": 23,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 68,
        "endColumn": 33,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScanResults.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScanWorkflowSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerControlsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerInterface.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\components\\ModalHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\components\\ScannerInterface.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\components\\WorkflowContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\components\\WorkflowSelection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\data\\workflowData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\hooks\\useScannerState.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 57,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState } from 'react';\nimport { useSterilizationStore } from '../../../../store/sterilizationStore';\nimport { WorkflowService } from '../../../../services/workflowService';\n\nexport interface ScannerState {\n  currentSessionId: string | null;\n  isScanning: boolean;\n  scanResult: 'success' | 'error' | null;\n}\n\nexport const useScannerState = () => {\n  const {\n    workflowType,\n    setWorkflowType,\n    scannedData,\n    setScannedData,\n    availableTools,\n    addToolToCycle,\n  } = useSterilizationStore();\n\n  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);\n  const [isScanning, setIsScanning] = useState(false);\n  const [scanResult, setScanResult] = useState<'success' | 'error' | null>(\n    null\n  );\n\n  const handleWorkflowSelect = async (workflow: string) => {\n    setWorkflowType(workflow);\n\n    // Start workflow session (mock implementation)\n    try {\n      const session = {\n        id: `session-${Date.now()}`,\n        workflowType: workflow,\n        startedAt: new Date().toISOString(),\n      };\n      setCurrentSessionId(session.id);\n    } catch (err) { console.error(err); throw err; }\n      // Error handling without console logging\n    }\n  };\n\n  const handleBackToWorkflow = async () => {\n    setWorkflowType('');\n    setIsScanning(false);\n    setScannedData('');\n\n    // End workflow session (mock implementation)\n    if (currentSessionId) {\n      try {\n        // Mock end session - just clear the session ID\n        setCurrentSessionId(null);\n      } catch (err) { console.error(err); throw err; }\n        // Error handling without console logging\n      }\n    }\n  };\n\n  const handleScan = async (onClose: () => void) => {\n    if (!workflowType) return;\n\n    setIsScanning(true);\n    setScanResult(null);\n    setScannedData(`Scanning tool for ${workflowType} workflow...`);\n\n    // Simulate scanning\n    setTimeout(async (): Promise<void> => {\n      const demoBarcodes = [\n        'SCAL001',\n        'FORC001',\n        'RETR001',\n        'SCAL002',\n        'FORC002',\n      ];\n      const randomBarcode =\n        demoBarcodes[Math.floor(Math.random() * demoBarcodes.length)];\n\n      const tool = availableTools.find((t) => t.barcode === randomBarcode);\n\n      if (tool) {\n        addToolToCycle(tool.id);\n        setScanResult('success');\n        setScannedData(\n          `Successfully processed ${tool.name} for ${workflowType} workflow`\n        );\n\n        // Log workflow event (mock implementation)\n        if (currentSessionId) {\n          try {\n            await WorkflowService.addTool(\n              currentSessionId,\n              tool.id,\n              tool.name,\n              tool.barcode,\n              workflowType\n            );\n          } catch (err) { console.error(err); throw err; }\n            // Error handling without console logging\n          }\n        }\n\n        // Auto-close after success\n        setTimeout(() => {\n          onClose();\n        }, 2000);\n      } else {\n        setScanResult('error');\n        setScannedData('Tool not found or already in cycle');\n      }\n\n      setIsScanning(false);\n    }, 1000);\n  };\n\n  return {\n    workflowType,\n    scannedData,\n    currentSessionId,\n    isScanning,\n    scanResult,\n    handleWorkflowSelect,\n    handleBackToWorkflow,\n    handleScan,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ScannerModal\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\SterilizationAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\SterilizationCycleTimeline.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\SterilizationDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\SterilizationErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\SterilizationScannerModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleStartTimer' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 27,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 27,
        "endColumn": 29,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay\\AutoclaveCycleSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay\\PhaseControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay\\PhaseHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay\\PhaseInfo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\TimerDisplay\\ToolsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ToolReplacementAlert.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\ToolWorkflowPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\WorkflowCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\WorkflowInfo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\WorkflowSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\hooks\\useBiologicalIndicatorLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\hooks\\useCleaningLogLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\hooks\\useCleaningLogTracker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\hooks\\useDashboardLogic.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'totalTime' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 52,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 52,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useMemo, useRef } from 'react';\nimport { useSterilizationStore } from '../../../store/sterilizationStore';\nimport {\n  DashboardService,\n  CycleProgressInfo,\n} from '../services/dashboardService';\n\nexport const useDashboardLogic = () => {\n  const { currentCycle } = useSterilizationStore();\n  const startTime = useRef(performance.now());\n\n  // Memoize tabs to prevent recalculation\n  const tabs = useMemo(() => {\n    return DashboardService.getTabs();\n  }, []);\n\n  // Memoize cycle progress info with proper dependency\n  const cycleProgressInfo = useMemo((): CycleProgressInfo | null => {\n    if (!currentCycle) return null;\n    return DashboardService.getCycleProgressInfo(currentCycle);\n  }, [currentCycle]);\n\n  // Memoize validation function\n  const validateOperatorName = useCallback((operatorName: string): boolean => {\n    return DashboardService.validateOperatorName(operatorName);\n  }, []);\n\n  // Memoize tab button classes function\n  const getTabButtonClasses = useCallback((isActive: boolean): string => {\n    return DashboardService.getTabButtonClasses(isActive);\n  }, []);\n\n  // Memoize start cycle button state function\n  const getStartCycleButtonState = useCallback((operatorName: string) => {\n    return DashboardService.getStartCycleButtonState(operatorName);\n  }, []);\n\n  // Memoize should show no cycle message with proper dependency\n  const shouldShowNoCycleMessage = useCallback((): boolean => {\n    return DashboardService.shouldShowNoCycleMessage(currentCycle);\n  }, [currentCycle]);\n\n  // Memoize should show active cycle info with proper dependency\n  const shouldShowActiveCycleInfo = useCallback((): boolean => {\n    if (!currentCycle) return false;\n    return DashboardService.shouldShowActiveCycleInfo(currentCycle);\n  }, [currentCycle]);\n\n  // Performance logging\n  useMemo(() => {\n    if (process.env.NODE_ENV === 'development') {\n      const totalTime = performance.now() - startTime.current;\n    }\n  }, []);\n\n  return {\n    tabs,\n    cycleProgressInfo,\n    validateOperatorName,\n    getTabButtonClasses,\n    getStartCycleButtonState,\n    shouldShowNoCycleMessage,\n    shouldShowActiveCycleInfo,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\hooks\\usePhaseTimerLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\services\\biologicalIndicatorService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\services\\cleaningLogService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\services\\dashboardService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\services\\phaseTimerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\sterilizationAnalyticsUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\CleanWorkflowActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\CleanWorkflowStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\CleanWorkflowUpdate.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\components\\TraceabilityCodeDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\hooks\\useCleanWorkflowWithTraceability.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 38,
        "column": 37,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 39,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [1278, 1283], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useCallback, useState } from 'react';\nimport { useSterilizationStore } from '@/store/sterilizationStore';\nimport { getCurrentTraceabilityCode } from '@/utils/generateTraceabilityCode';\n\ninterface UseCleanWorkflowWithTraceabilityProps {\n  scannedData: string;\n  toolId?: string;\n}\n\nexport const useCleanWorkflowWithTraceability = ({\n  scannedData,\n  toolId,\n}: UseCleanWorkflowWithTraceabilityProps) => {\n  const { markToolAsDirty, availableTools } = useSterilizationStore();\n  const [traceabilityCode] = useState(getCurrentTraceabilityCode());\n  const [copied, setCopied] = useState(false);\n\n  // Find the tool by barcode if toolId is not provided\n  const findToolByBarcode = useCallback(\n    (barcode: string) => {\n      return availableTools.find((tool) => tool.barcode === barcode);\n    },\n    [availableTools]\n  );\n\n  // Get the current tool\n  const getCurrentTool = useCallback(() => {\n    return toolId\n      ? availableTools.find((t) => t.id === toolId)\n      : findToolByBarcode(scannedData);\n  }, [toolId, availableTools, findToolByBarcode, scannedData]);\n\n  useEffect(() => {\n    const tool = getCurrentTool();\n\n    if (tool && tool.currentPhase === 'complete' && scannedData) {\n      markToolAsDirty(tool.id);\n    } else if (tool && scannedData) {\n    }\n  }, [scannedData, markToolAsDirty, getCurrentTool, traceabilityCode]);\n\n  const handleCopyCode = async () => {\n    try {\n      await navigator.clipboard.writeText(traceabilityCode);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      console.error('Failed to copy code:', error);\n    }\n  };\n\n  return {\n    tool: getCurrentTool(),\n    traceabilityCode,\n    copied,\n    handleCopyCode,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\CleanWorkflow\\useCleanWorkflow.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DamagedWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\ActionButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\CurrentToolDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\DirtyToolsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\ScanInterface.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\ScanMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\components\\WorkflowHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\hooks\\useDirtyWorkflowState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\DirtyWorkflow\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ImportWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\CIConfirmationStep.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\OperatorInputForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\PackageInformationForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\PackagingScanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\PackagingWorkflowHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\ScannedToolsList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\hooks\\usePackagingWorkflow.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\PackagingWorkflow\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ProblemWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ToolProblemWorkflow\\components\\ProblemTypeSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ToolProblemWorkflow\\components\\VoiceInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ToolProblemWorkflow\\constants\\problemTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ToolProblemWorkflow\\hooks\\useSpeechRecognition.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\ToolProblemWorkflow\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\TwoPWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\WorkflowComponent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\components\\Bath1PhaseDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\components\\CycleStatusDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\components\\ToolScanResult.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\Sterilization\\workflows\\hooks\\useDirtyWorkflow.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\SupabaseConnectionTest.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\SupabaseTest.tsx",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 44,
        "column": 46,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 45,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [1320, 1327], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\n\nexport const SupabaseTest: React.FC = () => {\n  const [testResult, setTestResult] = useState<string>('');\n  const [loading, setLoading] = useState(false);\n\n  const testSupabaseConnection = async () => {\n    setLoading(true);\n    setTestResult('Testing connection...');\n\n    try {\n      // Test 1: Basic connection\n      const { error: dbError } = await supabase\n        .from('users')\n        .select('count')\n        .limit(1);\n\n      if (dbError) {\n        setTestResult(`Database connection failed: ${dbError.message}`);\n        return;\n      }\n\n      setTestResult(\n        'Database connection successful! Testing home_daily_operations_tasks...'\n      );\n\n      // Test 2: Home daily operations tasks table\n      const { data: tasksData, error: tasksError } = await supabase\n        .from('home_daily_operations_tasks')\n        .select('*')\n        .eq('facility_id', '550e8400-e29b-41d4-a716-446655440000')\n        .limit(5);\n\n      if (tasksError) {\n        setTestResult(`Tasks table access failed: ${tasksError.message}`);\n        return;\n      }\n\n      setTestResult(\n        `Success! Found ${tasksData?.length || 0} tasks in home_daily_operations_tasks table.`\n      );\n\n      if (tasksData && tasksData.length > 0) {\n      }\n    } catch (error) {\n      setTestResult(\n        `Test failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px' }}>\n      <h3>Supabase Connection Test</h3>\n      <button onClick={testSupabaseConnection} disabled={loading}>\n        {loading ? 'Testing...' : 'Test Supabase Connection'}\n      </button>\n      <div style={{ marginTop: '10px' }}>\n        <strong>Result:</strong> {testResult}\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TaskCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TaskEditModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TaskList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TaskSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TasksList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\TasksList\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\VirtualizedTasksList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\ErrorMessage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\FormInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\InlineError.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\Pagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\Pagination\\LoadMoreButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\Pagination\\Pagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\Pagination\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\PasswordStrengthIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\common\\SortableTableHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\FloatingHelpButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\RecentlyCleaned.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\RoomStatusSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\Skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\UpdateRoomStatusModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\AIChat.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 67,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport { askCliniioAI } from '../../../services/aiService';\nimport { useAIGuardrails } from '../../../hooks/useAIGuardrails';\n\ninterface AIChatProps {\n  currentContext: string;\n  onBack: () => void;\n}\n\nexport const AIChat: React.FC<AIChatProps> = ({ currentContext, onBack }) => {\n  const [messages, setMessages] = useState<\n    Array<{ role: 'user' | 'assistant'; content: string }>\n  >([\n    {\n      role: 'assistant',\n      content:\n        \"Hello! I'm your Cliniio AI assistant. How can I help you today?\",\n    },\n  ]);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n\n  const { checkQuestionRelevance, getRedirectMessage } = useAIGuardrails();\n\n  const handleSendMessage = async () => {\n    if (!inputValue.trim() || isLoading) return;\n\n    const userMessage = inputValue.trim();\n    setInputValue('');\n    setMessages((prev) => [...prev, { role: 'user', content: userMessage }]);\n    setIsLoading(true);\n\n    // AI Guardrails - Check if question is relevant to current context\n    const isRelevantQuestion = checkQuestionRelevance(\n      userMessage,\n      currentContext\n    );\n\n    if (!isRelevantQuestion) {\n      const redirectMessage = getRedirectMessage(currentContext, userMessage);\n      setMessages((prev) => [\n        ...prev,\n        { role: 'assistant', content: redirectMessage },\n      ]);\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      const response = await askCliniioAI({\n        prompt: userMessage,\n        context: `User is on ${currentContext} page and asking for help. Only answer questions related to ${currentContext}.`,\n      });\n\n      setMessages((prev) => [\n        ...prev,\n        { role: 'assistant', content: response },\n      ]);\n    } catch (err) { console.error(err); throw err; }\n      setMessages((prev) => [\n        ...prev,\n        {\n          role: 'assistant',\n          content: 'Sorry, I encountered an error. Please try again.',\n        },\n      ]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col flex-1 min-h-0\">\n      {/* Chat Header */}\n      <div className=\"flex items-center p-4 border-b border-gray-200 bg-gray-50\">\n        <div className=\"flex items-center space-x-3\">\n          <button\n            onClick={onBack}\n            className=\"p-2 text-gray-400 hover:text-gray-600 transition-colors rounded-lg hover:bg-gray-200\"\n          >\n            ‚Üê Back\n          </button>\n          <div>\n            <h3 className=\"font-medium text-gray-900\">AI Assistant</h3>\n            <p className=\"text-xs text-gray-500\">\n              Ask me anything about Cliniio\n            </p>\n          </div>\n        </div>\n      </div>\n\n      {/* Chat Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4 min-h-0 scrollbar-hide\">\n        {messages.map((message, index) => (\n          <div\n            key={index}\n            className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}\n          >\n            <div\n              className={`max-w-xs px-4 py-2 rounded-lg ${\n                message.role === 'user'\n                  ? 'bg-[#4ECDC4] text-white'\n                  : 'bg-gray-100 text-gray-800'\n              }`}\n            >\n              <p className=\"text-sm\">{message.content}</p>\n            </div>\n          </div>\n        ))}\n        {isLoading && (\n          <div className=\"flex justify-start\">\n            <div className=\"bg-gray-100 text-gray-800 px-4 py-2 rounded-lg\">\n              <div className=\"flex items-center space-x-2\">\n                <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"></div>\n                <div\n                  className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                  style={{ animationDelay: '0.1s' }}\n                ></div>\n                <div\n                  className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                  style={{ animationDelay: '0.2s' }}\n                ></div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Input Area - Fixed at bottom */}\n      <div className=\"border-t border-gray-200 p-4 bg-white\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            value={inputValue}\n            onChange={(e) => setInputValue(e.target.value)}\n            onKeyPress={handleKeyPress}\n            placeholder=\"Ask me anything...\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#4ECDC4] focus:border-transparent\"\n            disabled={isLoading}\n          />\n          <button\n            onClick={handleSendMessage}\n            disabled={!inputValue.trim() || isLoading}\n            className=\"px-4 py-2 bg-[#4ECDC4] text-white rounded-lg hover:bg-[#3db8b0] focus:outline-none focus:ring-2 focus:ring-[#4ECDC4] focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            <span className=\"text-sm\">Send</span>\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\ContextHelp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\FeedbackForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\HelpNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\HelpSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\TourSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\help\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\input.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\label.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\progress.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\components\\ui\\textarea.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\aiConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\autoclaveCycles.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\devAuthConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\inventoryConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\inventoryFilterConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\logging.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\modalConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\scannerWorkflowConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\securityConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\statusBundles.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\supabaseConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\supabaseCredentials.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\timerConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\config\\workflowConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\env.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\homeDefaults.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\homeErrorMessages.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\homeTaskConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\homeUiConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\layoutConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\loginConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\retryConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\securityConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\taskConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\constants\\taskFilterOptions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\FacilityContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\LoginFormContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\NavigationContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\ThemeContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\UIContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\UserContext.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 49,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, {\n  createContext,\n  useContext,\n  useState,\n  ReactNode,\n  useEffect,\n  useCallback,\n} from 'react';\nimport { supabase } from '../lib/supabaseClient';\nimport { logger } from '../utils/_core/logger';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  role: string;\n  title?: string; // e.g., \"Dr.\", \"Nurse\", etc.\n  avatar_url?: string | null;\n  facility_id?: string; // Add facility_id to User interface\n}\n\ninterface UserContextType {\n  currentUser: User | null;\n  setCurrentUser: (user: User | null) => void;\n  getUserDisplayName: () => string;\n  refreshUserData: () => Promise<void>;\n  isLoading: boolean;\n}\n\nconst UserContext = createContext<UserContextType | undefined>(undefined);\n\nexport const UserProvider: React.FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const [currentUser, setCurrentUser] = useState<User | null>(() => {\n    // Try to get user from localStorage on initialization\n    const savedUser = localStorage.getItem('currentUser');\n    if (savedUser) {\n      try {\n        const parsed = JSON.parse(savedUser);\n        // Check if user data is still valid (not expired)\n        if (parsed && parsed.id) {\n          return parsed;\n        }\n      } catch (err) { console.error(err); throw err; }\n        console.warn('Failed to parse saved user data');\n      }\n    }\n    return null;\n  });\n  const [isLoading, setIsLoading] = useState(false);\n  const [hasInitialized, setHasInitialized] = useState(false);\n  const [lastFetchTime, setLastFetchTime] = useState<number>(0);\n\n  // Increase cache duration to 30 minutes to reduce frequent re-authentication\n  const CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\n\n  const getUserDisplayName = () => {\n    if (!currentUser) {\n      return 'Unknown User';\n    }\n\n    // If name is empty or just whitespace, use email as fallback\n    if (!currentUser.name || currentUser.name.trim() === '') {\n      return currentUser.email || 'Unknown User';\n    }\n\n    // Return just the name without any title\n    return currentUser.name;\n  };\n\n  const handleSetCurrentUser = (user: User | null) => {\n    setCurrentUser(user);\n    if (user) {\n      localStorage.setItem('currentUser', JSON.stringify(user));\n      setLastFetchTime(Date.now());\n    } else {\n      localStorage.removeItem('currentUser');\n      setLastFetchTime(0);\n    }\n  };\n\n  const refreshUserData = useCallback(async () => {\n    // Prevent multiple simultaneous calls\n    if (isLoading) {\n      return;\n    }\n\n    // Check if we have recent cached data\n    const now = Date.now();\n    if (currentUser && now - lastFetchTime < CACHE_DURATION) {\n      logger.info('‚úÖ UserContext: Using cached user data');\n      setHasInitialized(true);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      logger.info('üîÑ UserContext: Starting user data refresh...');\n\n      // Check if we have an active Supabase session before proceeding\n      const {\n        data: { session },\n      } = await supabase.auth.getSession();\n      if (!session) {\n        logger.info(\n          '‚ö†Ô∏è UserContext: No active Supabase session, skipping refresh'\n        );\n        setHasInitialized(true);\n        return;\n      }\n\n      // Add timeout to prevent hanging - reduced to 5 seconds for faster failure\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('User data fetch timeout')), 5000);\n      });\n\n      const fetchPromise = (async () => {\n        const startTime = Date.now();\n\n        // Get user auth data\n        const {\n          data: { user },\n          error: authError,\n        } = await supabase.auth.getUser();\n\n        if (authError) {\n          console.error('‚ùå UserContext: Auth error:', authError);\n          return;\n        }\n\n        if (!user) {\n          logger.info('‚ö†Ô∏è UserContext: No authenticated user found');\n          return;\n        }\n\n        logger.info('‚úÖ UserContext: Found authenticated user:', user.id);\n        const authTime = Date.now() - startTime;\n        logger.info(`‚è±Ô∏è UserContext: Auth fetch took ${authTime}ms`);\n\n        // Get user profile data\n        const profileStartTime = Date.now();\n        const { data: userProfile, error: profileError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', user.id)\n          .single();\n\n        if (profileError) {\n          console.error(\n            '‚ùå UserContext: Failed to fetch user profile:',\n            profileError\n          );\n          return;\n        }\n\n        const profileTime = Date.now() - profileStartTime;\n        logger.info(`‚è±Ô∏è UserContext: Profile fetch took ${profileTime}ms`);\n        logger.info(\n          `‚è±Ô∏è UserContext: Total fetch time: ${Date.now() - startTime}ms`\n        );\n\n        if (userProfile) {\n          // Transform the user data to match our User interface\n          const transformedUser: User = {\n            id: userProfile.id as string,\n            name:\n              `${userProfile.first_name || ''} ${userProfile.last_name || ''}`.trim() ||\n              (userProfile.email as string)?.split('@')[0] ||\n              'User',\n            email: userProfile.email as string,\n            role: userProfile.role as string,\n            avatar_url: userProfile.avatar_url as string | null,\n            facility_id: userProfile.facility_id as string, // Include facility_id\n          };\n\n          // Map database role to display role\n          const roleMapping: Record<string, string> = {\n            admin: 'Administrator',\n            manager: 'Manager',\n            user: 'User',\n            viewer: 'Viewer',\n          };\n\n          const userRole =\n            typeof userProfile.role === 'string' ? userProfile.role : 'user';\n          transformedUser.role = roleMapping[userRole] || userRole;\n\n          setCurrentUser(transformedUser);\n          setLastFetchTime(now);\n        }\n      })();\n\n      // Race between fetch and timeout\n      await Promise.race([fetchPromise, timeoutPromise]);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('timeout')) {\n        logger.warn(\n          '‚ö†Ô∏è UserContext: User data fetch timed out, this may indicate database performance issues'\n        );\n      }\n      console.error('‚ùå UserContext: Error refreshing user data:', error);\n    } finally {\n      setIsLoading(false);\n      setHasInitialized(true);\n    }\n  }, [isLoading, currentUser, lastFetchTime, CACHE_DURATION]);\n\n  // Optimize initialization to be non-blocking\n  useEffect(() => {\n    if (!hasInitialized) {\n      const now = Date.now();\n\n      // If we have cached user data that's still valid, use it immediately\n      if (currentUser && now - lastFetchTime < CACHE_DURATION) {\n        setHasInitialized(true);\n        return;\n      }\n\n      // Defer authentication to avoid blocking initial render\n      const timer = setTimeout(() => {\n        if (process.env.NODE_ENV === 'development' || currentUser) {\n          refreshUserData();\n        } else {\n          setHasInitialized(true);\n        }\n      }, 100); // Small delay to avoid blocking render\n\n      return () => clearTimeout(timer);\n    }\n  }, [\n    hasInitialized,\n    currentUser,\n    lastFetchTime,\n    CACHE_DURATION,\n    refreshUserData,\n  ]);\n\n  return (\n    <UserContext.Provider\n      value={{\n        currentUser,\n        setCurrentUser: handleSetCurrentUser,\n        getUserDisplayName,\n        refreshUserData,\n        isLoading,\n      }}\n    >\n      {children}\n    </UserContext.Provider>\n  );\n};\n\nexport const useUser = () => {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\contexts\\__tests__\\FacilityContext.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\data\\sampleTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\debug\\runRealtimeCleanup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\examples\\supabaseMockExample.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\ContentGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\LibraryContentGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\LibraryHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\LibraryProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\LibraryRoot.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\AILearningDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\AISuggestionInsights.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\CategoryFilter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\CategoryOrganizationInsights.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\ContentCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\IntegrationNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\InventorySearchModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryContentGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryModalManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\LibraryTabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\ProgressButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\SearchFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\FilterPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\InventoryItemCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\ModalHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\SearchBar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\SearchResults.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\components\\SelectedItemsSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\hooks\\useInventorySearchModal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\types\\InventorySearchModalTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\components\\utils\\inventorySearchUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useAiSuggestions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useCategoryOrganization.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useFilteredContent.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useInventorySearch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useKnowledgeHubIntegration.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 144,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useCallback } from 'react';\nimport { ContentItem } from '../libraryTypes';\nimport { knowledgeHubIntegrationService } from '../services/knowledgeHubIntegrationService';\n\nexport interface IntegrationState {\n  isAdding: boolean;\n  addedItems: Set<string>;\n  error: string | null;\n  successMessage: string | null;\n}\n\nexport interface UseKnowledgeHubIntegrationReturn {\n  state: IntegrationState;\n  addToKnowledgeHub: (item: ContentItem) => Promise<void>;\n  removeFromKnowledgeHub: (contentId: string) => Promise<void>;\n  clearMessages: () => void;\n  isInKnowledgeHub: (itemId: string) => boolean;\n}\n\nexport const useKnowledgeHubIntegration =\n  (): UseKnowledgeHubIntegrationReturn => {\n    const [state, setState] = useState<IntegrationState>({\n      isAdding: false,\n      addedItems: new Set(),\n      error: null,\n      successMessage: null,\n    });\n\n    const addToKnowledgeHub = useCallback(async (item: ContentItem) => {\n      setState((prev) => ({\n        ...prev,\n        isAdding: true,\n        error: null,\n        successMessage: null,\n      }));\n\n      try {\n        const result =\n          await knowledgeHubIntegrationService.addToKnowledgeHub(item);\n\n        if (result.success) {\n          setState((prev) => ({\n            ...prev,\n            isAdding: false,\n            addedItems: new Set([...prev.addedItems, item.id]),\n            successMessage: result.message,\n          }));\n\n          // Clear success message after 3 seconds\n          setTimeout(() => {\n            setState((prev) => ({\n              ...prev,\n              successMessage: null,\n            }));\n          }, 3000);\n        } else {\n          setState((prev) => ({\n            ...prev,\n            isAdding: false,\n            error: result.message,\n          }));\n\n          // Clear error message after 5 seconds\n          setTimeout(() => {\n            setState((prev) => ({\n              ...prev,\n              error: null,\n            }));\n          }, 5000);\n        }\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error\n            ? err.message\n            : 'Failed to add content to Knowledge Hub';\n\n        setState((prev) => ({\n          ...prev,\n          isAdding: false,\n          error: errorMessage,\n        }));\n\n        // Clear error message after 5 seconds\n        setTimeout(() => {\n          setState((prev) => ({\n            ...prev,\n            error: null,\n          }));\n        }, 5000);\n      }\n    }, []);\n\n    const removeFromKnowledgeHub = useCallback(async (contentId: string) => {\n      try {\n        const success =\n          await knowledgeHubIntegrationService.removeFromKnowledgeHub(\n            contentId\n          );\n\n        if (success) {\n          setState((prev) => ({\n            ...prev,\n            addedItems: new Set(\n              [...prev.addedItems].filter((id) => id !== contentId)\n            ),\n            successMessage: 'Content removed from Knowledge Hub',\n          }));\n\n          // Clear success message after 3 seconds\n          setTimeout(() => {\n            setState((prev) => ({\n              ...prev,\n              successMessage: null,\n            }));\n          }, 3000);\n        } else {\n          setState((prev) => ({\n            ...prev,\n            error: 'Failed to remove content from Knowledge Hub',\n          }));\n\n          // Clear error message after 5 seconds\n          setTimeout(() => {\n            setState((prev) => ({\n              ...prev,\n              error: null,\n            }));\n          }, 5000);\n        }\n      } catch (err) { console.error(err); throw err; }\n        setState((prev) => ({\n          ...prev,\n          error: 'Failed to remove content from Knowledge Hub',\n        }));\n\n        // Clear error message after 5 seconds\n        setTimeout(() => {\n          setState((prev) => ({\n            ...prev,\n            error: null,\n          }));\n        }, 5000);\n      }\n    }, []);\n\n    const clearMessages = useCallback(() => {\n      setState((prev) => ({\n        ...prev,\n        error: null,\n        successMessage: null,\n      }));\n    }, []);\n\n    const isInKnowledgeHub = useCallback(\n      (itemId: string) => {\n        return state.addedItems.has(itemId);\n      },\n      [state.addedItems]\n    );\n\n    return {\n      state,\n      addToKnowledgeHub,\n      removeFromKnowledgeHub,\n      clearMessages,\n      isInKnowledgeHub,\n    };\n  };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useLibraryContent.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useLibraryRootState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\hooks\\useSDSSheets.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\libraryTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\panels\\AISuggestionsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\panels\\CategoriesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\panels\\FavouritesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\panels\\SDSSheetsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\aiSuggestionsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\categoryOrganizationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\courseSearchService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\inventorySearchService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\knowledgeHubIntegrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\libraryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\sdsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\services\\userLearningProfileService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\features\\library\\useLibrary.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useCentralizedInventoryData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryCategoryManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryContext.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryCreate.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDashboardContext.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDataAccess.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDataFetching.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDataManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDataManagerWrapper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\useInventoryBulkDelete.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\useInventoryDelete.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\useInventoryDeleteState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\useInventoryRestore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryDelete\\useInventorySingleDelete.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryErrorHandling.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFilterComposition.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFilterState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFooterData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFormState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFormSubmission.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryFormValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryHeaderData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryMetrics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryModals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryPageLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryRead.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventorySearch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventorySorting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryTableData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryTableLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useInventoryUpdate.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useModalState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useScanModalManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useTableActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\inventory\\useTrackedTools.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\sterilization\\useErrorLogger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\sterilization\\useSterilizationAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAIChallenges.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAIDailyTasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAIGuardrails.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAITaskPerformanceMetrics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAddModalHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAnalytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAutoclaveReceipts.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useAvailablePoints.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useBIWorkflow.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useBackgroundCacheRefresh.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useBackgroundSync.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useCacheWarming.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useCentralizedInventoryData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useCleaningSchedule.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useCleanup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useContentAutosave.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useCumulativeStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useDebounce.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useDebouncedState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useEnvironmentalCleanRooms.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useErrorHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useErrorRecovery.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useFavoriteToggle.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useFeedbackSubmission.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useFilteredInventoryData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useFilteredInventoryDataCentralized.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useForecastingIntelligence.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useFormProtection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useGeolocation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHandleSave.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHelpContext.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomeActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomeDataLoader.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'loadBackgroundData' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 111,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 111,
        "endColumn": 27,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomeGamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomePage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomeState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useHomeTasksManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryFilterData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryFormHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryRealtimeUpdates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryScanModal.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryStatusHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useInventoryUpload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useKnowledgeHubState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLeaderboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLeaderboardData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLeaderboardRank.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoadingProtection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginAnalytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginApi.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginForm.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 28,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect } from 'react';\nimport {\n  login,\n  refreshSession,\n  logout,\n  LoginResponse,\n} from '@/services/authService';\nimport { logAudit } from '@/services/auditService';\nimport { useLoginStore } from '@/stores/useLoginStore';\n\nexport const useLoginForm = () => {\n  const storedToken = localStorage.getItem('authToken');\n  const storedExpiry = localStorage.getItem('sessionExpiry');\n  if (storedToken && storedExpiry && new Date(storedExpiry) > new Date()) {\n    useLoginStore.getState().setAuthToken(storedToken, storedExpiry);\n    useLoginStore.getState().setSessionExpiry(storedExpiry);\n  }\n\n  useEffect(() => {\n    const interval = setInterval(\n      async () => {\n        try {\n          const { expiry } = await refreshSession();\n          useLoginStore.getState().setSessionExpiry(expiry);\n        } catch (err) { console.error(err); throw err; }\n          logout();\n        }\n      },\n      14 * 60 * 1000\n    );\n    return () => clearInterval(interval);\n  }, []);\n\n  // Get store selectors and actions\n  const formData = useLoginStore((state) => state.formData);\n  const errors = useLoginStore((state) => state.errors);\n  const loading = useLoginStore((state) => state.loading);\n  const setField = useLoginStore((state) => state.setField);\n\n  const handleChange =\n    (field: keyof typeof formData) =>\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value =\n        e.target.type === 'checkbox' ? e.target.checked : e.target.value;\n      setField(field, value);\n    };\n\n  async function handleSubmit(credentials: {\n    username: string;\n    password: string;\n  }): Promise<void> {\n    try {\n      const response: LoginResponse = await login(\n        credentials.username,\n        credentials.password\n      );\n      useLoginStore.getState().setAuthToken(response.token, response.expiry);\n      await logAudit(credentials.username, true);\n    } catch (error: unknown) {\n      const errorMessage =\n        error instanceof Error ? error.message : 'Login failed';\n      await logAudit(credentials.username, false);\n      throw new Error(errorMessage);\n    }\n  }\n\n  return { formData, errors, loading, handleChange, handleSubmit };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginFormHook.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginNavigation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginRateLimit.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginSecurity.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useLoginValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useOnlineStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\usePagePerformance.ts",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "The ref value 'mountStartTime.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'mountStartTime.current' to a variable inside the effect, and use that variable in the cleanup function.",
        "line": 86,
        "column": 60,
        "nodeType": "Identifier",
        "endLine": 86,
        "endColumn": 67
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useLayoutEffect, useRef, useCallback } from 'react';\nimport { logger } from '../utils/_core/logger';\nimport { performanceMonitor } from '../services/monitoring/PerformanceMonitor';\n\ninterface PerformanceMetrics {\n  pageLoadTime: number;\n  componentMountTime: number;\n  dataLoadTime?: number;\n  totalTime: number;\n  navigationTime?: number;\n  authenticationTime?: number;\n  dataFetchTime?: number;\n}\n\ninterface UsePagePerformanceOptions {\n  pageName: string;\n  trackDataLoading?: boolean;\n  trackNavigation?: boolean;\n  trackAuthentication?: boolean;\n  onMetricsComplete?: (metrics: PerformanceMetrics) => void;\n}\n\nexport const usePagePerformance = ({\n  pageName,\n  trackDataLoading = false,\n  trackNavigation = true,\n  trackAuthentication = true,\n  onMetricsComplete,\n}: UsePagePerformanceOptions) => {\n  const mountStartTime = useRef<number>(performance.now());\n  const mountTime = useRef<number>();\n  const dataLoadTime = useRef<number>();\n  const navigationTime = useRef<number>();\n  const authenticationTime = useRef<number>();\n  const dataFetchTime = useRef<number>();\n\n  // Defer logging to avoid blocking renders\n  const deferredLog = useCallback((message: string) => {\n    if (process.env.NODE_ENV === 'development') {\n      setTimeout(() => {\n        logger.perf(message);\n      }, 0);\n    }\n  }, []);\n\n  // Use useLayoutEffect for more accurate mount timing\n  useLayoutEffect(() => {\n    // Record component mount time - measure from hook creation to effect execution\n    const now = performance.now();\n    mountTime.current = now - mountStartTime.current;\n\n    // Cap mount time to prevent unrealistic values (max 10 seconds)\n    if (mountTime.current > 10000) {\n      mountTime.current = 10000;\n    }\n\n    // Record in performance monitor\n    performanceMonitor.recordComponentMount(pageName, mountTime.current, {\n      page: pageName,\n      timestamp: new Date().toISOString(),\n    });\n\n    // Defer mount performance logging\n    deferredLog(`${pageName} mounted in ${mountTime.current.toFixed(2)}ms`);\n\n    if (navigationTime.current) {\n      deferredLog(\n        `${pageName} navigation took ${navigationTime.current.toFixed(2)}ms`\n      );\n    }\n\n    if (authenticationTime.current) {\n      deferredLog(\n        `${pageName} authentication took ${authenticationTime.current.toFixed(2)}ms`\n      );\n    }\n\n    if (dataFetchTime.current) {\n      deferredLog(\n        `${pageName} data fetch took ${dataFetchTime.current.toFixed(2)}ms`\n      );\n    }\n\n    return () => {\n      // Calculate total time on unmount using captured startTime\n      const totalTime = performance.now() - mountStartTime.current;\n      const currentMountTime = mountTime.current;\n\n      const metrics: PerformanceMetrics = {\n        pageLoadTime: currentMountTime || 0,\n        componentMountTime: currentMountTime || 0,\n        dataLoadTime: dataLoadTime.current,\n        navigationTime: navigationTime.current,\n        authenticationTime: authenticationTime.current,\n        dataFetchTime: dataFetchTime.current,\n        totalTime,\n      };\n\n      // Defer total performance logging and bottleneck analysis\n      if (process.env.NODE_ENV === 'development') {\n        setTimeout(() => {\n          logger.perf(\n            `${pageName} total time: ${totalTime.toFixed(2)}ms`,\n            metrics\n          );\n\n          // Identify bottlenecks with performance monitor thresholds\n          const bottlenecks = [];\n          if (navigationTime.current && navigationTime.current > 1000) {\n            bottlenecks.push(\n              `Navigation (${navigationTime.current.toFixed(2)}ms)`\n            );\n          }\n          if (authenticationTime.current && authenticationTime.current > 2000) {\n            bottlenecks.push(\n              `Authentication (${authenticationTime.current.toFixed(2)}ms)`\n            );\n          }\n          if (dataFetchTime.current && dataFetchTime.current > 2000) {\n            bottlenecks.push(\n              `Data Fetch (${dataFetchTime.current.toFixed(2)}ms)`\n            );\n          }\n          if (currentMountTime && currentMountTime > 1000) {\n            bottlenecks.push(\n              `Component Mount (${currentMountTime.toFixed(2)}ms)`\n            );\n          }\n\n          if (bottlenecks.length > 0) {\n            logger.warn(\n              `${pageName} bottlenecks detected:`,\n              bottlenecks.join(', ')\n            );\n          }\n        }, 0);\n      }\n\n      // Call callback if provided\n      onMetricsComplete?.(metrics);\n    };\n  }, [pageName, onMetricsComplete, deferredLog]);\n\n  const recordDataLoaded = useCallback(() => {\n    if (trackDataLoading && mountStartTime.current) {\n      dataLoadTime.current = performance.now() - mountStartTime.current;\n      deferredLog(\n        `${pageName} data loaded in ${dataLoadTime.current.toFixed(2)}ms`\n      );\n    }\n  }, [pageName, trackDataLoading, deferredLog]);\n\n  const recordNavigationComplete = useCallback(() => {\n    if (trackNavigation && mountStartTime.current) {\n      navigationTime.current = performance.now() - mountStartTime.current;\n\n      // Record in performance monitor\n      performanceMonitor.recordNavigation(\n        'unknown',\n        pageName,\n        navigationTime.current,\n        {\n          page: pageName,\n          timestamp: new Date().toISOString(),\n        }\n      );\n\n      deferredLog(\n        `${pageName} navigation completed in ${navigationTime.current.toFixed(2)}ms`\n      );\n    }\n  }, [pageName, trackNavigation, deferredLog]);\n\n  const recordAuthenticationComplete = useCallback(() => {\n    if (trackAuthentication && mountStartTime.current) {\n      // Only record authentication time if we haven't already recorded it\n      if (!authenticationTime.current) {\n        authenticationTime.current = performance.now() - mountStartTime.current;\n\n        // Record in performance monitor\n        performanceMonitor.recordAuthentication(\n          authenticationTime.current,\n          true,\n          {\n            page: pageName,\n            timestamp: new Date().toISOString(),\n          }\n        );\n\n        deferredLog(\n          `${pageName} authentication completed in ${authenticationTime.current.toFixed(2)}ms`\n        );\n      }\n    }\n  }, [pageName, trackAuthentication, deferredLog]);\n\n  const recordDataFetchComplete = useCallback(() => {\n    if (trackDataLoading && mountStartTime.current) {\n      dataFetchTime.current = performance.now() - mountStartTime.current;\n\n      // Record in performance monitor\n      performanceMonitor.recordDataFetch(\n        'data_fetch',\n        dataFetchTime.current,\n        true,\n        {\n          page: pageName,\n          timestamp: new Date().toISOString(),\n        }\n      );\n\n      deferredLog(\n        `[PERF] ${pageName} data fetch completed in ${dataFetchTime.current.toFixed(2)}ms`\n      );\n    }\n  }, [pageName, trackDataLoading, deferredLog]);\n\n  return {\n    recordDataLoaded,\n    recordNavigationComplete,\n    recordAuthenticationComplete,\n    recordDataFetchComplete,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\usePerformanceMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\usePerformanceOptimizedData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\usePhaseTransition.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useRealtimeUpdates.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useScanModalHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useScannerPage.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useSimpleCacheWarming.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useSmartInventorySearch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useSterilizationInitialization.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useSterilizationScan.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useTimerControls.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useTopUsers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useUI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\hooks\\useWorkflowScanner.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\__mocks__\\getEnv.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\__tests__\\supabaseMockTypeTest.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\getEnv.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\rateLimiter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\redisClient.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 13,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '../utils/_core/logger';\n\n// Optional Redis import - will fallback to in-memory if not available\nlet createClient: ((config: unknown) => unknown) | null = null;\n\ntry {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const redis = require('redis');\n  createClient = redis.createClient;\n} catch (err) { console.error(err); throw err; }\n  // Redis package not available, will use in-memory fallback\n  // Don't log warning here as it's expected in some environments\n}\n\nexport interface RedisConfig {\n  host: string;\n  port: number;\n  password?: string;\n  db?: number;\n  retryDelayOnFailover?: number;\n  maxRetriesPerRequest?: number;\n}\n\nclass RedisManager {\n  private client: unknown = null;\n  private config: RedisConfig;\n  private isConnected = false;\n\n  constructor(config: RedisConfig) {\n    this.config = config;\n  }\n\n  async connect(): Promise<void> {\n    if (this.isConnected) return;\n\n    if (!createClient) {\n      logger.warn('Redis not available, using in-memory fallback');\n      return;\n    }\n\n    try {\n      this.client = createClient({\n        socket: {\n          host: this.config.host,\n          port: this.config.port,\n          reconnectStrategy: (retries) => {\n            if (retries > 10) {\n              logger.error('Redis connection failed after 10 retries');\n              return new Error('Redis connection failed');\n            }\n            return Math.min(retries * 100, 3000);\n          },\n        },\n        password: this.config.password,\n        database: this.config.db || 0,\n      });\n\n      this.client.on('error', (err) => {\n        logger.error('Redis client error:', err);\n        this.isConnected = false;\n      });\n\n      this.client.on('connect', () => {\n        logger.info('Redis client connected');\n        this.isConnected = true;\n      });\n\n      this.client.on('disconnect', () => {\n        logger.warn('Redis client disconnected');\n        this.isConnected = false;\n      });\n\n      await this.client.connect();\n    } catch (error) {\n      logger.error('Failed to connect to Redis:', error);\n      throw error;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.client && this.isConnected) {\n      await this.client.disconnect();\n      this.isConnected = false;\n    }\n  }\n\n  getClient(): unknown {\n    if (!this.client || !this.isConnected) {\n      throw new Error('Redis client not connected');\n    }\n    return this.client;\n  }\n\n  isHealthy(): boolean {\n    return this.isConnected && this.client !== null;\n  }\n}\n\n// Default configuration - can be overridden by environment variables\nconst getEnvVar = (key: string, defaultValue: string): string => {\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env[key] || defaultValue;\n  }\n  return defaultValue;\n};\n\nconst defaultConfig: RedisConfig = {\n  host: getEnvVar('REDIS_HOST', 'localhost'),\n  port: parseInt(getEnvVar('REDIS_PORT', '6379')),\n  password: getEnvVar('REDIS_PASSWORD', ''),\n  db: parseInt(getEnvVar('REDIS_DB', '0')),\n  retryDelayOnFailover: 100,\n  maxRetriesPerRequest: 3,\n};\n\nexport const redisManager = new RedisManager(defaultConfig);\n\n// Initialize Redis connection\nexport const initializeRedis = async (): Promise<void> => {\n  try {\n    await redisManager.connect();\n    logger.info('Redis initialized successfully');\n  } catch (error) {\n    logger.warn(\n      'Redis initialization failed, falling back to in-memory cache:',\n      error\n    );\n  }\n};\n\n// Graceful shutdown\nexport const shutdownRedis = async (): Promise<void> => {\n  try {\n    await redisManager.disconnect();\n    logger.info('Redis disconnected successfully');\n  } catch (error) {\n    logger.error('Error disconnecting from Redis:', error);\n  }\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\sessionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\supabase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\supabaseClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\supabaseConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\supabaseEnv.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\lib\\supabaseMockIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\Assistant.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 45,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport { SharedLayout } from '../../components/Layout/SharedLayout';\nimport { FaQuestionCircle, FaRobot, FaPaperPlane } from 'react-icons/fa';\nimport { askCliniioAI } from '../../services/aiService';\n\nexport default function Assistant() {\n  const [messages, setMessages] = useState<\n    Array<{ role: 'user' | 'assistant'; content: string }>\n  >([\n    {\n      role: 'assistant',\n      content:\n        \"Hello! I'm your Cliniio AI assistant. How can I help you today?\",\n    },\n  ]);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleSendMessage = async () => {\n    if (!inputValue.trim() || isLoading) return;\n\n    const userMessage = inputValue.trim();\n    setInputValue('');\n    setMessages((prev) => [...prev, { role: 'user', content: userMessage }]);\n    setIsLoading(true);\n\n    try {\n      const response = await askCliniioAI({\n        prompt: userMessage,\n        context: 'User is asking for help in the Cliniio AI Assistant',\n      });\n\n      setMessages((prev) => [\n        ...prev,\n        { role: 'assistant', content: response },\n      ]);\n    } catch (err) { console.error(err); throw err; }\n      setMessages((prev) => [\n        ...prev,\n        {\n          role: 'assistant',\n          content: 'Sorry, I encountered an error. Please try again.',\n        },\n      ]);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  return (\n    <SharedLayout>\n      <div className=\"p-6 space-y-6\">\n        {/* Header */}\n        <div className=\"flex items-center space-x-4 mb-6\">\n          <div className=\"w-12 h-12 bg-[#4ECDC4] rounded-lg flex items-center justify-center\">\n            <FaQuestionCircle size={24} className=\"text-white\" />\n          </div>\n          <div>\n            <h1 className=\"text-2xl font-bold text-[#5b5b5b]\">\n              Help & Assistant\n            </h1>\n            <p className=\"text-gray-500 text-sm\">\n              AI-powered assistance and support for Cliniio users\n            </p>\n          </div>\n        </div>\n\n        {/* AI Chat Interface */}\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200\">\n          {/* Chat Messages */}\n          <div className=\"h-96 overflow-y-auto p-4 space-y-4\">\n            {messages.map((message, index) => (\n              <div\n                key={index}\n                className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}\n              >\n                <div\n                  className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${\n                    message.role === 'user'\n                      ? 'bg-[#4ECDC4] text-white'\n                      : 'bg-gray-100 text-gray-800'\n                  }`}\n                >\n                  <p className=\"text-sm\">{message.content}</p>\n                </div>\n              </div>\n            ))}\n            {isLoading && (\n              <div className=\"flex justify-start\">\n                <div className=\"bg-gray-100 text-gray-800 px-4 py-2 rounded-lg\">\n                  <div className=\"flex items-center space-x-2\">\n                    <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"></div>\n                    <div\n                      className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                      style={{ animationDelay: '0.1s' }}\n                    ></div>\n                    <div\n                      className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"\n                      style={{ animationDelay: '0.2s' }}\n                    ></div>\n                  </div>\n                </div>\n              </div>\n            )}\n          </div>\n\n          {/* Input Area */}\n          <div className=\"border-t border-gray-200 p-4\">\n            <div className=\"flex space-x-2\">\n              <input\n                type=\"text\"\n                value={inputValue}\n                onChange={(e) => setInputValue(e.target.value)}\n                onKeyPress={handleKeyPress}\n                placeholder=\"Ask me anything about Cliniio...\"\n                className=\"flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#4ECDC4] focus:border-transparent\"\n                disabled={isLoading}\n              />\n              <button\n                onClick={handleSendMessage}\n                disabled={!inputValue.trim() || isLoading}\n                className=\"px-4 py-2 bg-[#4ECDC4] text-white rounded-lg hover:bg-[#3db8b0] focus:outline-none focus:ring-2 focus:ring-[#4ECDC4] focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                <FaPaperPlane size={16} />\n              </button>\n            </div>\n          </div>\n        </div>\n\n        {/* AI Status */}\n        <div className=\"bg-green-50 border border-green-200 rounded-lg p-4\">\n          <div className=\"flex items-start space-x-3\">\n            <FaRobot size={20} className=\"text-green-600 mt-0.5\" />\n            <div>\n              <h3 className=\"font-medium text-green-800 mb-1\">\n                AI Assistant Active\n              </h3>\n              <p className=\"text-sm text-green-700\">\n                Your AI assistant is now connected and ready to help! Ask\n                questions about Cliniio features, workflows, or get assistance\n                with any clinical management tasks.\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </SharedLayout>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\AssistantChat.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\AssistantHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\AssistantStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\ChatInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\ChatMessages.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\LoadingIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\MessageBubble.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\constants\\assistantConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\hooks\\useAssistantChat.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\services\\assistantAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\types\\assistantTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\utils\\assistantUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Assistant\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\ContentBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\__tests__\\LinkedPrerequisiteInput.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\AISuggestions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\AccessibilityEnhancements.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\BugTracker.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CommonEditorFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\ContentEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\ContentFormFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\ContentToolbar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\ContentTypeSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\AISuggestionsService.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\ContentBuilderStep.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\ContentBuilderStep.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\ContentQualityValidator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CoursePlanningStep.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CoursePreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CourseStep1.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CourseStep3.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CourseStep4.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 217,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport Icon from '@mdi/react';\nimport { mdiEye, mdiPublish, mdiClock } from '@mdi/js';\nimport { useContentBuilder } from '../../context';\nimport { useContentBuilderActions } from '../../hooks';\nimport CourseValidation from './CourseValidation';\nimport PublishingSettings from './PublishingSettings';\nimport SEOMetadata from './SEOMetadata';\nimport CoursePreview from './CoursePreview';\nimport PublishingWorkflow from './PublishingWorkflow';\nimport ValidationStatus from './ValidationStatus';\n\ninterface ValidationResult {\n  field: string;\n  status: 'valid' | 'warning' | 'error';\n  message: string;\n}\n\nconst CourseStep4: React.FC = () => {\n  const { state } = useContentBuilder();\n  const { updateCourseField } = useContentBuilderActions();\n  const { courseData } = state;\n\n  const [validationResults, setValidationResults] = useState<\n    ValidationResult[]\n  >([]);\n  const [isPublishing, setIsPublishing] = useState(false);\n  const [publishSettings, setPublishSettings] = useState({\n    isPublic: true,\n    requireEnrollment: false,\n    allowGuestAccess: false,\n    maxEnrollments: 0,\n    enrollmentStartDate: '',\n    enrollmentEndDate: '',\n    courseStartDate: '',\n    courseEndDate: '',\n    autoArchive: false,\n    archiveAfterDays: 30,\n  });\n  const [seoSettings, setSeoSettings] = useState({\n    metaTitle: courseData.title || '',\n    metaDescription: courseData.description || '',\n    keywords: '',\n    canonicalUrl: '',\n    ogImage: '',\n    structuredData: true,\n  });\n\n  const [collapsedSections, setCollapsedSections] = useState({\n    review: false,\n    settings: false,\n    seo: false,\n    access: false,\n    preview: false,\n  });\n\n  // Validation logic\n  useEffect(() => {\n    const validateCourse = () => {\n      const results: ValidationResult[] = [];\n\n      // Course title validation\n      if (!courseData.title || courseData.title.trim().length < 5) {\n        results.push({\n          field: 'title',\n          status: 'error',\n          message: 'Course title must be at least 5 characters long',\n        });\n      } else if (courseData.title.length > 100) {\n        results.push({\n          field: 'title',\n          status: 'warning',\n          message: 'Course title is quite long, consider shortening it',\n        });\n      } else {\n        results.push({\n          field: 'title',\n          status: 'valid',\n          message: 'Course title is appropriate length',\n        });\n      }\n\n      // Course description validation\n      if (\n        !courseData.description ||\n        courseData.description.trim().length < 20\n      ) {\n        results.push({\n          field: 'description',\n          status: 'error',\n          message: 'Course description must be at least 20 characters long',\n        });\n      } else if (courseData.description.length > 500) {\n        results.push({\n          field: 'description',\n          status: 'warning',\n          message: 'Course description is quite long, consider shortening it',\n        });\n      } else {\n        results.push({\n          field: 'description',\n          status: 'valid',\n          message: 'Course description is appropriate length',\n        });\n      }\n\n      // Modules validation\n      if (courseData.modules.length === 0) {\n        results.push({\n          field: 'modules',\n          status: 'error',\n          message: 'Course must have at least one module',\n        });\n      } else {\n        const totalLessons = courseData.modules.reduce(\n          (acc, module) => acc + module.lessons.length,\n          0\n        );\n        if (totalLessons === 0) {\n          results.push({\n            field: 'lessons',\n            status: 'error',\n            message: 'Course must have at least one lesson',\n          });\n        } else if (totalLessons < 3) {\n          results.push({\n            field: 'lessons',\n            status: 'warning',\n            message: 'Consider adding more lessons for a comprehensive course',\n          });\n        } else {\n          results.push({\n            field: 'lessons',\n            status: 'valid',\n            message: `Course has ${totalLessons} lessons across ${courseData.modules.length} modules`,\n          });\n        }\n      }\n\n      // Settings validation\n      if (!courseData.settings?.difficulty) {\n        results.push({\n          field: 'difficulty',\n          status: 'error',\n          message: 'Difficulty level must be set',\n        });\n      } else {\n        results.push({\n          field: 'difficulty',\n          status: 'valid',\n          message: `Difficulty level: ${courseData.settings.difficulty}`,\n        });\n      }\n\n      // Assessment validation\n      if (courseData.assessments && courseData.assessments.length > 0) {\n        results.push({\n          field: 'assessments',\n          status: 'valid',\n          message: `Course has ${courseData.assessments.length} assessment(s)`,\n        });\n      } else {\n        results.push({\n          field: 'assessments',\n          status: 'warning',\n          message: 'Consider adding assessments to evaluate learning',\n        });\n      }\n\n      setValidationResults(results);\n    };\n\n    validateCourse();\n  }, [courseData]);\n\n  const getValidationStatus = () => {\n    const errors = validationResults.filter((r) => r.status === 'error').length;\n    const warnings = validationResults.filter(\n      (r) => r.status === 'warning'\n    ).length;\n\n    if (errors > 0)\n      return { status: 'error', message: `${errors} issues must be resolved` };\n    if (warnings > 0)\n      return { status: 'warning', message: `${warnings} warnings to consider` };\n    return { status: 'valid', message: 'Course is ready to publish' };\n  };\n\n  const toggleSection = (section: keyof typeof collapsedSections) => {\n    setCollapsedSections((prev) => ({\n      ...prev,\n      [section]: !prev[section],\n    }));\n  };\n\n  const handlePublish = async () => {\n    const validationStatus = getValidationStatus();\n    if (validationStatus.status === 'error') {\n      alert('Please resolve all validation errors before publishing');\n      return;\n    }\n\n    setIsPublishing(true);\n\n    try {\n      // Simulate publishing process\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n\n      // Update course status\n      updateCourseField({ isPublished: true });\n\n      alert(\n        'Course published successfully! It is now available in the library.'\n      );\n    } catch (err) { console.error(err); throw err; }\n      alert('Failed to publish course. Please try again.');\n    } finally {\n      setIsPublishing(false);\n    }\n  };\n\n  const generatePreview = () => {\n    // Generate course preview data\n    const previewData = {\n      title: courseData.title,\n      description: courseData.description,\n      modules: courseData.modules.length,\n      lessons: courseData.modules.reduce((acc, m) => acc + m.lessons.length, 0),\n      duration: courseData.settings?.estimatedDuration || 0,\n      difficulty: courseData.settings?.difficulty || 'beginner',\n    };\n\n    alert(\n      `Course Preview:\\n\\nTitle: ${previewData.title}\\nDescription: ${previewData.description}\\nModules: ${previewData.modules}\\nLessons: ${previewData.lessons}\\nDuration: ${previewData.duration} minutes\\nDifficulty: ${previewData.difficulty}`\n    );\n  };\n\n  const validationStatus = getValidationStatus();\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h4 className=\"text-2xl font-semibold text-gray-900\">\n            Publish & Settings\n          </h4>\n          <p className=\"text-sm text-gray-600\">\n            Final review and configuration before publishing your course\n          </p>\n        </div>\n        <div className=\"flex items-center gap-3\">\n          <button\n            onClick={generatePreview}\n            className=\"inline-flex items-center gap-2 px-4 py-2 border border-blue-200 rounded-lg bg-blue-50 hover:border-blue-300 hover:bg-blue-100 transition-colors\"\n          >\n            <Icon path={mdiEye} size={1} className=\"text-blue-600\" />\n            <span className=\"font-medium text-blue-900 text-sm\">Preview</span>\n          </button>\n          <button\n            onClick={handlePublish}\n            disabled={validationStatus.status === 'error' || isPublishing}\n            className={`inline-flex items-center gap-2 px-6 py-2 rounded-lg font-medium transition-colors ${\n              validationStatus.status === 'error' || isPublishing\n                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n                : 'bg-green-600 text-white hover:bg-green-700'\n            }`}\n          >\n            <Icon path={isPublishing ? mdiClock : mdiPublish} size={1} />\n            <span>{isPublishing ? 'Publishing...' : 'Publish Course'}</span>\n          </button>\n        </div>\n      </div>\n\n      {/* Validation Status */}\n      <ValidationStatus\n        validationStatus={\n          validationStatus as {\n            status: 'error' | 'warning' | 'valid';\n            message: string;\n          }\n        }\n      />\n\n      {/* Course Review Section */}\n      <CourseValidation\n        collapsedSections={collapsedSections}\n        toggleSection={toggleSection}\n      />\n\n      {/* Publishing Settings Section */}\n      <PublishingSettings\n        collapsedSections={collapsedSections}\n        toggleSection={toggleSection}\n        publishSettings={publishSettings}\n        setPublishSettings={setPublishSettings}\n      />\n\n      {/* SEO & Metadata Section */}\n      <SEOMetadata\n        collapsedSections={collapsedSections}\n        toggleSection={toggleSection}\n        seoSettings={seoSettings}\n        setSeoSettings={setSeoSettings}\n      />\n\n      {/* Course Preview & Testing Tools */}\n      <CoursePreview\n        collapsedSections={collapsedSections}\n        toggleSection={toggleSection}\n        generatePreview={generatePreview}\n      />\n\n      {/* Publishing Workflow */}\n      <PublishingWorkflow\n        validationStatus={\n          validationStatus as {\n            status: 'error' | 'warning' | 'valid';\n            message: string;\n          }\n        }\n        isPublishing={isPublishing}\n        handlePublish={handlePublish}\n      />\n    </div>\n  );\n};\n\nexport default CourseStep4;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\CourseValidation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\DragDropContentBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\LessonEditModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\LessonEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\LinkedPrerequisiteInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\MediaUploadZone.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\ModuleNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\PublishingSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\PublishingWorkflow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\RichContentCreation.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\RichTextEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\SEOMetadata.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\SaveStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\SmartObjectivesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\UnifiedContentBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\ValidationStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\CourseSteps\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\LazyContentEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\LearningPathwayBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\MediaLibrary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\MediaUploader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\MobileResponsiveness.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\PDFUploadHandler.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\PerformanceMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\PolicyEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionBankManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionBankSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionBankViewer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\DragDrop.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\FillBlank.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\Hotspot.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\Matching.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\MultipleChoice.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuestionTypes\\TrueFalse.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuizAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuizBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuizEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuizPreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\QuizRenderer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\Quiz\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\SDSAIAssistant.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\SimpleContentEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\SmartTagManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\TableBuilder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\TestRunner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\TestingAndBugTracking.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\TextFormatting.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\ValidationErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\VoiceRecorder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\constants\\contentTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\context\\ContentBuilderContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\context\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useContentBuilderActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useContentForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useContentTypeSpecific.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useMediaUpload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useOptimizedValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\usePerformanceOptimization.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useQuestionBanks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useSDSAnalysis.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useTableBuilder.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useTextFormatting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\hooks\\useValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\services\\SDSAnalysisService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\types\\contentTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\types\\validationSchemas.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\ContentBuilder\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\ScannerPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 81,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * ‚ö†Ô∏è CRITICAL: DO NOT MODIFY THIS FILE WITHOUT EXPLICIT USER CONSENT ‚ö†Ô∏è\n *\n * This environmental clean scanner page contains:\n * - Room scanning functionality with barcode simulation\n * - Status selection and room management\n * - Working scan interface and room cleaning completion\n * - Navigation and room status handling\n * - Original functionality and architecture\n *\n * ANY CHANGES TO THIS FILE REQUIRE EXPLICIT USER PERMISSION\n * DO NOT: Remove scan functionality, change room status handling, modify navigation\n * DO NOT: Simplify component, alter core architecture, or remove working features\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { motion } from 'framer-motion';\nimport Icon from '@mdi/react';\nimport { SharedLayout } from '../../components/Layout/SharedLayout';\nimport { RoomScanService, Room } from './services/RoomScanService';\nimport { mdiBarcode, mdiArrowLeft } from '@mdi/js';\nimport { RoomStatusType } from './types';\n\nconst ScannerPage: React.FC = () => {\n  const navigate = useNavigate();\n  const [isScanning, setIsScanning] = useState(false);\n  const [scanResult, setScanResult] = useState<'success' | 'error' | null>(\n    null\n  );\n  const [scanMessage, setScanMessage] = useState('');\n  const [selectedStatus, setSelectedStatus] = useState<RoomStatusType | ''>('');\n  const [scannedRoom, setScannedRoom] = useState<Room | null>(null);\n\n  // Get available statuses from the service\n  const availableStatuses = useMemo(() => {\n    const statuses = RoomScanService.getAvailableStatuses();\n\n    // Map to the format expected by the UI\n    return statuses.map((status) => ({\n      id: status.id,\n      name: status.name,\n      icon: status.icon || 'default-icon',\n      color: status.color || '#6b7280', // Default gray color\n      description: status.description || '',\n      isCore: status.isCore || false,\n    }));\n  }, []);\n\n  const handleScan = async () => {\n    setIsScanning(true);\n    setScanResult(null);\n    setScannedRoom(null);\n\n    try {\n      // Simulate barcode scanning - in real implementation, this would come from camera\n      const demoBarcodes = [\n        'ROOM-001',\n        'ROOM-002',\n        'ROOM-003',\n        'ROOM-004',\n        'ROOM-005',\n      ];\n      const randomBarcode =\n        demoBarcodes[Math.floor(Math.random() * demoBarcodes.length)];\n\n      // Use the RoomScanService to scan the barcode\n      const result = await RoomScanService.scanRoomBarcode(randomBarcode);\n\n      if (result.success && result.room) {\n        setScanResult('success');\n        setScanMessage(result.message);\n        setScannedRoom(result.room);\n      } else {\n        setScanResult('error');\n        setScanMessage(result.message);\n      }\n    } catch (err) { console.error(err); throw err; }\n      setScanResult('error');\n      setScanMessage('An error occurred during scanning. Please try again.');\n    } finally {\n      setIsScanning(false);\n    }\n  };\n\n  const handleStatusSelect = (statusId: string) => {\n    // Convert the status ID to RoomStatusType\n    // This is a temporary fix - in a real app, you'd want to map the store status IDs to RoomStatusType\n    const statusMap: Record<string, RoomStatusType> = {\n      clean: 'clean',\n      dirty: 'dirty',\n      in_progress: 'in_progress',\n      available: 'available',\n      biohazard: 'biohazard',\n      theft: 'theft',\n      low_inventory: 'low_inventory',\n      out_of_service: 'out_of_service',\n      public_areas: 'public_areas',\n    };\n\n    const roomStatus = statusMap[statusId] || 'dirty'; // Default to dirty if unknown\n    setSelectedStatus(roomStatus);\n  };\n\n  const handleCompleteCleaning = async () => {\n    if (!scannedRoom) {\n      setScanMessage('No room selected for cleaning completion');\n      return;\n    }\n\n    try {\n      const result = await RoomScanService.completeRoomCleaning(scannedRoom.id);\n\n      if (result.success) {\n        setScanMessage(result.message);\n        // Navigate back after successful completion\n        setTimeout(() => {\n          navigate('/environmental-clean');\n        }, 2000);\n      } else {\n        setScanMessage(result.message);\n      }\n    } catch (err) { console.error(err); throw err; }\n      setScanMessage(\n        'An error occurred while completing cleaning. Please try again.'\n      );\n    }\n  };\n\n  const handleStatusUpdate = async () => {\n    if (!scannedRoom || !selectedStatus) {\n      setScanMessage('Please select a room and status');\n      return;\n    }\n\n    try {\n      const result = await RoomScanService.updateRoomStatus(\n        scannedRoom.id,\n        selectedStatus\n      );\n\n      if (result.success) {\n        setScanMessage(result.message);\n        // Navigate back after successful update\n        setTimeout(() => {\n          navigate('/environmental-clean');\n        }, 2000);\n      } else {\n        setScanMessage(result.message);\n      }\n    } catch (err) { console.error(err); throw err; }\n      setScanMessage(\n        'An error occurred while updating status. Please try again.'\n      );\n    }\n  };\n\n  const handleBack = () => {\n    navigate('/environmental-clean');\n  };\n\n  return (\n    <SharedLayout>\n      <div\n        className=\"fixed inset-0 bg-black bg-opacity-30 z-40\"\n        onClick={handleBack}\n        onKeyDown={(e) => e.key === 'Escape' && handleBack()}\n        role=\"button\"\n        tabIndex={0}\n      />\n\n      {/* Drawer - Maintains the original modal styling */}\n      <motion.div\n        initial={{ x: '100%' }}\n        animate={{ x: 0 }}\n        exit={{ x: '100%' }}\n        transition={{ duration: 0.3, ease: 'easeInOut' }}\n        className=\"fixed inset-y-0 right-0 w-[40%] bg-white shadow-2xl z-50\"\n      >\n        <div className=\"h-full flex flex-col\">\n          <div className=\"bg-white overflow-hidden h-full\">\n            {/* Header */}\n            <div className=\"p-4 border-b border-gray-200 flex items-center gap-4\">\n              <button\n                onClick={handleBack}\n                className=\"p-2 hover:bg-gray-100 rounded-lg transition-colors\"\n              >\n                <Icon\n                  path={mdiArrowLeft}\n                  size={1.2}\n                  className=\"text-gray-600\"\n                />\n              </button>\n              <div>\n                <h2 className=\"text-xl font-semibold text-gray-800\">\n                  Environmental Clean Scanner\n                </h2>\n                <p className=\"text-gray-600 text-sm\">\n                  Scan rooms for cleaning management\n                </p>\n              </div>\n            </div>\n\n            {/* Content */}\n            <div className=\"p-4 overflow-y-auto flex-1 hide-scrollbar\">\n              {!selectedStatus ? (\n                /* Status Selection */\n                <div className=\"space-y-3\">\n                  <h3 className=\"text-lg font-medium text-gray-800 mb-3\">\n                    Select Room Status\n                  </h3>\n                  <div className=\"space-y-2\">\n                    {availableStatuses.map((status) => (\n                      <button\n                        key={status.id}\n                        onClick={() => handleStatusSelect(status.id)}\n                        className={`w-full p-3 rounded-lg border-2 transition-all duration-200 text-left ${\n                          status.color === '#16a34a'\n                            ? 'border-green-200 hover:border-green-300 bg-green-50 hover:bg-green-100'\n                            : status.color === '#ca8a04'\n                              ? 'border-yellow-200 hover:border-yellow-300 bg-yellow-50 hover:bg-yellow-100'\n                              : status.color === '#dc2626'\n                                ? 'border-red-200 hover:border-red-300 bg-red-50 hover:bg-red-100'\n                                : status.color === '#9333ea'\n                                  ? 'border-purple-200 hover:border-purple-300 bg-purple-50 hover:bg-purple-100'\n                                  : status.color === '#4b5563'\n                                    ? 'border-gray-200 hover:border-gray-300 bg-gray-50 hover:bg-gray-100'\n                                    : status.color === '#b45309'\n                                      ? 'border-amber-200 hover:border-amber-300 bg-amber-50 hover:bg-amber-100'\n                                      : status.color === '#047857'\n                                        ? 'border-emerald-200 hover:border-emerald-300 bg-emerald-50 hover:bg-emerald-100'\n                                        : 'border-gray-200 hover:border-gray-300 bg-gray-50 hover:bg-gray-100'\n                        }`}\n                      >\n                        <div className=\"flex items-center gap-2\">\n                          <div\n                            className={`p-1.5 rounded-lg ${\n                              status.color === '#16a34a'\n                                ? 'bg-green-100'\n                                : status.color === '#ca8a04'\n                                  ? 'bg-yellow-100'\n                                  : status.color === '#dc2626'\n                                    ? 'bg-red-100'\n                                    : status.color === '#9333ea'\n                                      ? 'bg-purple-100'\n                                      : status.color === '#4b5563'\n                                        ? 'bg-gray-100'\n                                        : status.color === '#b45309'\n                                          ? 'bg-amber-100'\n                                          : status.color === '#047857'\n                                            ? 'bg-emerald-100'\n                                            : 'bg-gray-100'\n                            }`}\n                          >\n                            <Icon\n                              path={status.icon}\n                              size={1}\n                              className={\n                                status.color === '#16a34a'\n                                  ? 'text-green-600'\n                                  : status.color === '#ca8a04'\n                                    ? 'text-yellow-600'\n                                    : status.color === '#dc2626'\n                                      ? 'text-red-600'\n                                      : status.color === '#9333ea'\n                                        ? 'text-purple-600'\n                                        : status.color === '#4b5563'\n                                          ? 'text-gray-600'\n                                          : status.color === '#b45309'\n                                            ? 'text-amber-600'\n                                            : status.color === '#047857'\n                                              ? 'text-emerald-600'\n                                              : 'text-gray-600'\n                              }\n                            />\n                          </div>\n                          <div>\n                            <h4\n                              className={`font-semibold text-sm ${\n                                status.color === '#16a34a'\n                                  ? 'text-green-800'\n                                  : status.color === '#ca8a04'\n                                    ? 'text-yellow-800'\n                                    : status.color === '#dc2626'\n                                      ? 'text-red-800'\n                                      : status.color === '#9333ea'\n                                        ? 'text-purple-800'\n                                        : status.color === '#4b5563'\n                                          ? 'text-gray-800'\n                                          : status.color === '#b45309'\n                                            ? 'text-amber-800'\n                                            : status.color === '#047857'\n                                              ? 'text-emerald-800'\n                                              : 'text-gray-800'\n                              }`}\n                            >\n                              {status.name}\n                            </h4>\n                            <p\n                              className={`text-xs ${\n                                status.color === '#16a34a'\n                                  ? 'text-green-600'\n                                  : status.color === '#ca8a04'\n                                    ? 'text-yellow-600'\n                                    : status.color === '#dc2626'\n                                      ? 'text-red-600'\n                                      : status.color === '#9333ea'\n                                        ? 'text-purple-600'\n                                        : status.color === '#4b5563'\n                                          ? 'text-gray-600'\n                                          : status.color === '#b45309'\n                                            ? 'text-amber-600'\n                                            : status.color === '#047857'\n                                              ? 'text-emerald-600'\n                                              : 'text-gray-600'\n                              }`}\n                            >\n                              {status.description}\n                            </p>\n                          </div>\n                        </div>\n                      </button>\n                    ))}\n                  </div>\n                </div>\n              ) : (\n                /* Scanner Interface */\n                <div className=\"space-y-6\">\n                  {/* Status Info */}\n                  <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n                    <h3 className=\"font-semibold text-blue-800 mb-1\">\n                      {selectedStatus.charAt(0).toUpperCase() +\n                        selectedStatus.slice(1)}{' '}\n                      Status\n                    </h3>\n                    <p className=\"text-blue-600 text-sm\">\n                      {\n                        availableStatuses.find((s) => s.id === selectedStatus)\n                          ?.description\n                      }\n                    </p>\n                  </div>\n\n                  {/* Room Info (if scanned) */}\n                  {scannedRoom && (\n                    <div className=\"bg-green-50 border border-green-200 rounded-lg p-4\">\n                      <h3 className=\"font-semibold text-green-800 mb-1\">\n                        Scanned Room\n                      </h3>\n                      <p className=\"text-green-600 text-sm\">\n                        <strong>Name:</strong> {scannedRoom.name}\n                        <br />\n                        <strong>Department:</strong>{' '}\n                        {scannedRoom.department || 'N/A'}\n                        <br />\n                        <strong>Floor:</strong> {scannedRoom.floor || 'N/A'}\n                        <br />\n                        <strong>Building:</strong>{' '}\n                        {scannedRoom.building || 'N/A'}\n                      </p>\n                    </div>\n                  )}\n\n                  {/* Scan Interface */}\n                  <div className=\"bg-gray-50 rounded-lg p-6\">\n                    <div className=\"text-center space-y-4\">\n                      {/* Camera Viewfinder */}\n                      <div className=\"relative bg-black h-64 rounded-lg overflow-hidden\">\n                        {/* Camera feed simulation */}\n                        <div className=\"absolute inset-0 bg-gradient-to-br from-gray-900 to-black\"></div>\n\n                        {/* Scanning animation */}\n                        <motion.div\n                          className=\"absolute left-0 right-0 h-1 bg-[#4ECDC4]\"\n                          animate={{\n                            top: ['10%', '90%', '10%'],\n                            opacity: [0.5, 1, 0.5],\n                          }}\n                          transition={{\n                            duration: 2,\n                            repeat: Infinity,\n                            ease: 'easeInOut',\n                          }}\n                        />\n\n                        {/* QR Code outline */}\n                        <div className=\"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 border-2 border-[#4ECDC4] w-48 h-48 rounded-lg\">\n                          <div className=\"absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-[#4ECDC4] rounded-tl\"></div>\n                          <div className=\"absolute top-0 right-0 w-4 h-4 border-t-2 border-r-2 border-[#4ECDC4] rounded-tr\"></div>\n                          <div className=\"absolute bottom-0 left-0 w-4 h-4 border-b-2 border-l-2 border-[#4ECDC4] rounded-bl\"></div>\n                          <div className=\"absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-[#4ECDC4] rounded-br\"></div>\n                        </div>\n\n                        {/* Camera status indicator */}\n                        <div className=\"absolute bottom-4 right-4 flex items-center\">\n                          <div className=\"w-2 h-2 rounded-full bg-red-500 mr-2 animate-pulse\"></div>\n                          <span className=\"text-white text-xs\">\n                            Camera active\n                          </span>\n                        </div>\n\n                        {/* Scan Button Overlay */}\n                        <button\n                          onClick={handleScan}\n                          disabled={isScanning}\n                          className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-4 rounded-full transition-all duration-200 ${\n                            isScanning\n                              ? 'bg-gray-600 cursor-not-allowed'\n                              : 'bg-[#4ECDC4] hover:bg-[#3db8b0] shadow-lg hover:shadow-xl'\n                          }`}\n                        >\n                          <Icon\n                            path={mdiBarcode}\n                            size={1.5}\n                            className={`${isScanning ? 'text-gray-400' : 'text-white'}`}\n                          />\n                        </button>\n                      </div>\n\n                      <div>\n                        <h3 className=\"text-lg font-medium text-gray-800 mb-2\">\n                          {isScanning ? 'Scanning...' : 'Click to Scan'}\n                        </h3>\n                        <p className=\"text-gray-600 text-sm\">\n                          {isScanning\n                            ? 'Position room barcode in camera view'\n                            : 'Use camera to scan room barcode'}\n                        </p>\n                      </div>\n                    </div>\n\n                    {/* Scan Result */}\n                    {scanResult && (\n                      <motion.div\n                        initial={{ opacity: 0, y: 10 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        className={`mt-4 p-4 rounded-lg ${\n                          scanResult === 'success'\n                            ? 'bg-green-100 border border-green-200'\n                            : 'bg-red-100 border border-red-200'\n                        }`}\n                      >\n                        <div className=\"flex items-center gap-2\">\n                          <Icon\n                            path={mdiBarcode}\n                            size={1}\n                            className={\n                              scanResult === 'success'\n                                ? 'text-green-600'\n                                : 'text-red-600'\n                            }\n                          />\n                          <span\n                            className={`font-medium ${\n                              scanResult === 'success'\n                                ? 'text-green-800'\n                                : 'text-red-800'\n                            }`}\n                          >\n                            {scanMessage}\n                          </span>\n                        </div>\n                      </motion.div>\n                    )}\n                  </div>\n\n                  {/* Action Buttons */}\n                  <div className=\"flex justify-center space-x-4\">\n                    <button\n                      onClick={() => setSelectedStatus('')}\n                      className=\"px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors\"\n                    >\n                      ‚Üê Back to Status Selection\n                    </button>\n                    {scanResult === 'success' && scannedRoom && (\n                      <>\n                        <button\n                          onClick={handleStatusUpdate}\n                          className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors\"\n                        >\n                          Update Status\n                        </button>\n                        <button\n                          onClick={handleCompleteCleaning}\n                          className=\"px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors\"\n                        >\n                          Complete Cleaning\n                        </button>\n                      </>\n                    )}\n                  </div>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </motion.div>\n    </SharedLayout>\n  );\n};\n\nexport default ScannerPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\TestStatusButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanAnalyticsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanAuditModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanChecklists.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanChecklistsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanErrorNotification.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanHeaderWrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanPagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanRoomStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanScanModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\EnvironmentalCleanStatusPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\TestStatusButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\analytics\\EnvironmentalCleanInsightsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\modals\\ScannerOverlay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\ChecklistCategory.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\ChecklistItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\CleaningAnalytics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\CleaningChecklists.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\EnvironmentalCleanHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\RecentlyCleaned.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\RoomCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\RoomStatusCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\RoomStatusSummary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\SdsSheets.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\StatusButtons.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\components\\CategoryTabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\components\\ChecklistItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\components\\RoomDrawer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\components\\StatusCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\components\\StatusModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\constants\\cleaningData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\hooks\\useChecklistState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\hooks\\useSpeechRecognition.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\types\\RoomStatusTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\types\\cleaningChecklists.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\utils\\statusGenerationUtils.ts",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useMemo has unnecessary dependencies: 'isLoading' and 'statusTypes'. Either exclude them or remove the dependency array.",
        "line": 74,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 84,
        "endColumn": 4,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [getCoreStatusTypes, getPublishedStatusTypes, config.bgColorMap, config.bgColorSelectedMap, config.borderColorMap, config.colorMap, config.iconMap]",
            "fix": {
              "range": [2199, 2411],
              "text": "[getCoreStatusTypes, getPublishedStatusTypes, config.bgColorMap, config.bgColorSelectedMap, config.borderColorMap, config.colorMap, config.iconMap]"
            }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMemo } from 'react';\nimport { useStatusTypes } from '@/store/statusTypesStore';\nimport { StatusOption, StatusCard } from '../types/RoomStatusTypes';\nimport {\n  createStatusMappingConfig,\n  getStatusIcon,\n  getStatusBgColor,\n  getStatusTextColor,\n} from './statusMappingUtils';\n\ninterface StatusType {\n  id: string;\n  name: string;\n  color: string;\n  icon: string;\n  isCore: boolean;\n}\n\n// StatusConfig interface removed as it's not used\n\nexport const useStatusOptions = (): StatusOption[] => {\n  const {\n    getCoreStatusTypes,\n    getPublishedStatusTypes,\n    statusTypes,\n    isLoading,\n  } = useStatusTypes();\n  const config = createStatusMappingConfig();\n\n  return useMemo(() => {\n    const coreStatusTypes = getCoreStatusTypes();\n    const publishedStatusTypes = getPublishedStatusTypes();\n\n    const generateStatusOptions = (\n      statusTypes: StatusType[]\n    ): StatusOption[] => {\n      return statusTypes.map((statusType) => {\n        const iconPath =\n          config.iconMap[statusType.icon] || config.iconMap.default;\n\n        return {\n          value: statusType.id,\n          name: statusType.name,\n          bgColor:\n            config.bgColorMap[statusType.color] || config.bgColorMap.default,\n          bgColorSelected:\n            config.bgColorSelectedMap[statusType.color] ||\n            config.bgColorSelectedMap.default,\n          borderColor:\n            config.borderColorMap[statusType.color] ||\n            config.borderColorMap.default,\n          color: config.colorMap[statusType.color] || config.colorMap.default,\n          icon: iconPath,\n          isCore: statusType.isCore || false,\n        };\n      });\n    };\n\n    // Return combined array of core and published status options, avoiding duplicates\n    const coreOptions = generateStatusOptions(coreStatusTypes);\n    const publishedOptions = generateStatusOptions(publishedStatusTypes);\n\n    // Combine and deduplicate by ID\n    const allOptions = [...coreOptions];\n    publishedOptions.forEach((publishedOption) => {\n      if (\n        !allOptions.find((option) => option.value === publishedOption.value)\n      ) {\n        allOptions.push(publishedOption);\n      }\n    });\n\n    return allOptions;\n  }, [\n    getCoreStatusTypes,\n    getPublishedStatusTypes,\n    statusTypes,\n    isLoading,\n    config.bgColorMap,\n    config.bgColorSelectedMap,\n    config.borderColorMap,\n    config.colorMap,\n    config.iconMap,\n  ]);\n};\n\nexport const useStatusCards = (): StatusCard[] => {\n  const { getCoreStatusTypes, getPublishedStatusTypes } = useStatusTypes();\n  const config = createStatusMappingConfig();\n\n  return useMemo(() => {\n    const coreStatuses = getCoreStatusTypes();\n    const publishedStatuses = getPublishedStatusTypes();\n\n    // Combine core and published statuses, with core statuses first\n    const allVisibleStatuses = [\n      ...coreStatuses,\n      ...publishedStatuses.filter((s) => !s.isCore),\n    ];\n\n    return allVisibleStatuses.map((status) => ({\n      status: status.name,\n      icon: getStatusIcon(status.icon, config.iconMap),\n      color: status.color,\n      bgColor: getStatusBgColor(status.color, config.bgColorMap),\n      textColor: getStatusTextColor(status.color, config.textColorMap),\n      isCore: status.isCore,\n    }));\n  }, [\n    getCoreStatusTypes,\n    getPublishedStatusTypes,\n    config.bgColorMap,\n    config.iconMap,\n    config.textColorMap,\n  ]);\n};\n\nexport const getRoomCountByStatus = (\n  rooms: Array<{ id: string; status: string }>,\n  status: string\n): number => {\n  return rooms.filter((room) => room.status === status).length;\n};\n\nexport const getRoomsByStatus = (\n  rooms: Array<{ id: string; status: string }>,\n  status: string\n): Array<{ id: string; status: string }> => {\n  return rooms.filter((room) => room.status === status);\n};\n\nexport const getRoomDetails = (\n  room: {\n    id: string;\n    status: string;\n    name?: string;\n    metadata?: Record<string, unknown>;\n  },\n  activeRooms: Array<{\n    id: string;\n    barcode?: string;\n    name: string;\n    department?: string;\n    floor?: string;\n  }>\n): { name: string; department: string; floor: string } => {\n  // First, try to use the room's own name if it exists\n  if (room.name) {\n    return {\n      name: room.name,\n      department: room.metadata?.department || '',\n      floor: room.metadata?.floor || '',\n    };\n  }\n\n  // Fallback to matching with room store\n  const roomFromSettings = activeRooms.find(\n    (settingsRoom) => (settingsRoom.barcode || settingsRoom.id) === room.id\n  );\n\n  return {\n    name: roomFromSettings ? roomFromSettings.name : `Room ${room.id}`,\n    department: roomFromSettings ? roomFromSettings.department || '' : '',\n    floor: roomFromSettings ? roomFromSettings.floor || '' : '',\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\components\\ui\\utils\\statusMappingUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\config\\statusOptions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\context\\EnvironmentalCleanContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\context\\RoomStatusContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanAnalytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanAudit.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fullAuditEvent' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 38,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'data' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 109,
        "column": 17,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 109,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMutation } from '@tanstack/react-query';\nimport { auditLogger } from '@/utils/auditLogger';\nimport { RoomStatusType } from '../models';\n\n// Define proper types for audit events\nexport interface EnvironmentalCleanAuditEvent {\n  action: string;\n  item?: Record<string, string | number | boolean | undefined>;\n  operator?: string;\n  roomId?: string;\n  status?: RoomStatusType;\n  metadata?: Record<string, string | number | boolean | undefined>;\n}\n\n// Define audit result types\nexport interface EnvironmentalCleanAuditResult {\n  success: boolean;\n  auditId?: string;\n  timestamp?: string;\n  error?: string;\n}\n\n// Define audit error types\nexport type EnvironmentalCleanAuditError = Error | string | null;\n\nexport function useEnvironmentalCleanAudit() {\n  return useMutation<\n    EnvironmentalCleanAuditResult,\n    EnvironmentalCleanAuditError,\n    EnvironmentalCleanAuditEvent\n  >({\n    mutationFn: async (auditEvent: EnvironmentalCleanAuditEvent) => {\n      try {\n        const timestamp = new Date().toISOString();\n        const operator = auditEvent.operator || 'Unknown Operator';\n\n        // Create comprehensive audit event\n        const fullAuditEvent = {\n          ...auditEvent,\n          timestamp,\n          operator,\n          module: 'environmental_clean',\n          category: 'environmental_clean',\n        };\n\n        // Log to single audit system to prevent duplicates\n        const auditPromises = [\n          // 1. Console logging (development) - removed for performance\n\n          // 2. Single audit logger utility (consolidated)\n          Promise.resolve().then(() => {\n            try {\n              auditLogger.log('environmental_clean', auditEvent.action, {\n                ...auditEvent.item,\n                operator,\n                roomId: auditEvent.roomId,\n                status: auditEvent.status,\n                metadata: auditEvent.metadata,\n                timestamp,\n              });\n            } catch (error) {\n              console.warn('Audit logger failed:', error);\n            }\n          }),\n        ];\n\n        // Don't wait for audit operations - make them non-blocking\n        Promise.allSettled(auditPromises).catch(() => {\n          // Silently handle any audit failures\n        });\n\n        // Generate audit ID for tracking\n        const auditId = `EC-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n        // Success logging removed for performance\n\n        return {\n          success: true,\n          auditId,\n          timestamp,\n        };\n      } catch (error) {\n        console.error('‚ùå Failed to log Environmental Clean audit:', error);\n\n        // Even if audit fails, don't break the user experience\n        // Log to console as fallback\n        console.warn(\n          '‚ö†Ô∏è Audit logging failed, using console fallback:',\n          auditEvent\n        );\n\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown audit error',\n        };\n      }\n    },\n    // Retry configuration for audit failures\n    retry: 2,\n    retryDelay: 1000,\n    // Don't show loading states for audit operations\n    onMutate: () => {\n      // Audit indicator removed for performance\n    },\n    onError: (error) => {\n      console.error('‚ùå Environmental Clean audit failed:', error);\n      // Don't show error to user for audit failures\n    },\n    onSuccess: (data) => {\n      // Success logging removed for performance\n    },\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanBatch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanDataManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanOffline.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 45,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useState, useCallback } from 'react';\n\n// Define proper error types for offline functionality\nexport type OfflineError = Error | string | null;\n\ninterface OfflineStatus {\n  isOnline: boolean;\n  isServiceWorkerRegistered: boolean;\n  isServiceWorkerActive: boolean;\n  hasOfflineData: boolean;\n  lastSyncTime: string | null;\n  error: OfflineError;\n}\n\n/**\n * Enhanced offline functionality for Environmental Clean module\n * Registers service worker and manages offline state\n */\nexport function useEnvironmentalCleanOffline() {\n  const [status, setStatus] = useState<OfflineStatus>({\n    isOnline: navigator.onLine,\n    isServiceWorkerRegistered: false,\n    isServiceWorkerActive: false,\n    hasOfflineData: false,\n    lastSyncTime: null,\n    error: null,\n  });\n\n  // Check if service worker file exists\n  const checkServiceWorkerExists = useCallback(async (): Promise<boolean> => {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout\n\n      const response = await fetch('/sw.js', {\n        method: 'HEAD',\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n      return response.ok;\n    } catch (err) { console.error(err); throw err; }\n      return false;\n    }\n  }, []);\n\n  // Register service worker with proper error handling\n  const registerServiceWorker = useCallback(async (): Promise<boolean> => {\n    if (!('serviceWorker' in navigator)) {\n      const error = 'Service Worker not supported in this browser';\n      setStatus((prev) => ({\n        ...prev,\n        error,\n      }));\n      return false;\n    }\n\n    try {\n      // Check if service worker file exists\n      const swExists = await checkServiceWorkerExists();\n      if (!swExists) {\n        console.warn('‚ö†Ô∏è Service Worker file not found at /sw.js');\n        const error = 'Service Worker file not available';\n        setStatus((prev) => ({\n          ...prev,\n          error,\n        }));\n        return false;\n      }\n\n      // Register the service worker\n      const registration = await navigator.serviceWorker.register('/sw.js', {\n        scope: '/',\n        updateViaCache: 'none', // Always check for updates\n      });\n\n      console.log('‚úÖ Service Worker registered successfully:', registration);\n\n      // Check if service worker is active\n      if (registration.active) {\n        setStatus((prev) => ({\n          ...prev,\n          isServiceWorkerRegistered: true,\n          isServiceWorkerActive: true,\n          error: null,\n        }));\n      } else {\n        // Wait for service worker to activate\n        registration.addEventListener('activate', () => {\n          setStatus((prev) => ({\n            ...prev,\n            isServiceWorkerRegistered: true,\n            isServiceWorkerActive: true,\n            error: null,\n          }));\n        });\n      }\n\n      // Listen for service worker updates with throttling\n      let updateCount = 0;\n      const maxUpdates = 3; // Limit update notifications\n\n      registration.addEventListener('updatefound', () => {\n        updateCount++;\n        if (updateCount <= maxUpdates) {\n          console.log(\n            `üîÑ Service Worker update found (${updateCount}/${maxUpdates})`\n          );\n        }\n\n        const newWorker = registration.installing;\n        if (newWorker) {\n          newWorker.addEventListener('statechange', () => {\n            if (\n              newWorker.state === 'installed' &&\n              navigator.serviceWorker.controller\n            ) {\n              if (updateCount <= maxUpdates) {\n                console.log(\n                  'üîÑ New Service Worker installed, refresh to activate'\n                );\n              }\n            }\n          });\n        }\n      });\n\n      return true;\n    } catch (error) {\n      console.error('‚ùå Service Worker registration failed:', error);\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      const fullError = `Service Worker registration failed: ${errorMessage}`;\n      setStatus((prev) => ({\n        ...prev,\n        error: fullError,\n      }));\n      return false;\n    }\n  }, [checkServiceWorkerExists]);\n\n  // Check offline data availability\n  const checkOfflineData = useCallback(async (): Promise<void> => {\n    try {\n      if ('caches' in window) {\n        const cache = await caches.open('cliniio-v1');\n        const keys = await cache.keys();\n        const hasData = keys.some(\n          (key) =>\n            key.url.includes('/api/environmental') ||\n            key.url.includes('/environmental-clean')\n        );\n\n        setStatus((prev) => ({\n          ...prev,\n          hasOfflineData: hasData,\n        }));\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Failed to check offline data:', error);\n    }\n  }, []);\n\n  // Handle online/offline status changes\n  const handleOnlineStatusChange = useCallback((): void => {\n    const isOnline = navigator.onLine;\n    const error: OfflineError = isOnline\n      ? null\n      : 'You are currently offline. Some features may be limited.';\n\n    setStatus((prev) => ({\n      ...prev,\n      isOnline,\n      error,\n    }));\n\n    if (isOnline) {\n      // Update last sync time when coming back online\n      setStatus((prev) => ({\n        ...prev,\n        lastSyncTime: new Date().toISOString(),\n      }));\n    }\n  }, []);\n\n  // Initialize offline functionality\n  useEffect(() => {\n    // Register service worker\n    registerServiceWorker();\n\n    // Check offline data\n    checkOfflineData();\n\n    // Set up online/offline listeners\n    window.addEventListener('online', handleOnlineStatusChange);\n    window.addEventListener('offline', handleOnlineStatusChange);\n\n    // Set initial online status\n    handleOnlineStatusChange();\n\n    return () => {\n      window.removeEventListener('online', handleOnlineStatusChange);\n      window.removeEventListener('offline', handleOnlineStatusChange);\n    };\n  }, [registerServiceWorker, checkOfflineData, handleOnlineStatusChange]);\n\n  // Manual service worker update check\n  const checkForUpdates = useCallback(async (): Promise<void> => {\n    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n      try {\n        await navigator.serviceWorker.controller.postMessage({\n          type: 'SKIP_WAITING',\n        });\n        console.log('üîÑ Service Worker update requested');\n      } catch (error) {\n        console.warn('‚ö†Ô∏è Failed to request Service Worker update:', error);\n      }\n    }\n  }, []);\n\n  // Clear offline cache\n  const clearOfflineCache = useCallback(async (): Promise<void> => {\n    try {\n      if ('caches' in window) {\n        const cacheNames = await caches.keys();\n        await Promise.all(\n          cacheNames.map((cacheName) => caches.delete(cacheName))\n        );\n        setStatus((prev) => ({\n          ...prev,\n          hasOfflineData: false,\n        }));\n        console.log('üóëÔ∏è Offline cache cleared');\n      }\n    } catch (error) {\n      console.error('‚ùå Failed to clear offline cache:', error);\n    }\n  }, []);\n\n  return {\n    ...status,\n    registerServiceWorker,\n    checkForUpdates,\n    clearOfflineCache,\n    checkOfflineData,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useEnvironmentalCleanRealtime.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 303,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport { getEnvVar } from '@/lib/getEnv';\nimport { RoomStatusType } from '../models';\nimport { RealtimeManager } from '@/services/_core/realtimeManager';\n\n// Define proper error types for real-time functionality\nexport type RealtimeError = Error | string | null;\n\ninterface RealtimeStatus {\n  isConnected: boolean;\n  isSubscribed: boolean;\n  lastUpdate: string | null;\n  error: RealtimeError;\n  connectionAttempts: number;\n}\n\n/**\n * Enhanced real-time functionality for Environmental Clean module\n * Uses Supabase real-time subscriptions for live updates\n */\nexport function useEnvironmentalCleanRealtime(autoConnect: boolean = false) {\n  const [status, setStatus] = useState<RealtimeStatus>({\n    isConnected: false,\n    isSubscribed: false,\n    lastUpdate: null,\n    error: null,\n    connectionAttempts: 0,\n  });\n\n  const subscriptionRef = useRef<(() => void) | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const connectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const maxReconnectAttempts = 3; // Reduced from 5\n  const reconnectDelay = 1000; // Reduced from 2000ms\n  const connectionTimeout = 5000; // 5 second connection timeout\n\n  // Check if Supabase is configured\n  const isSupabaseConfigured = () => {\n    try {\n      return !!(\n        getEnvVar('VITE_SUPABASE_URL') && getEnvVar('VITE_SUPABASE_ANON_KEY')\n      );\n    } catch (err) { console.error(err); throw err; }\n      return false;\n    }\n  };\n\n  // Subscribe to environmental cleaning changes\n  const subscribeToEnvironmentalCleans = useCallback(() => {\n    if (!isSupabaseConfigured()) {\n      console.warn(\n        '‚ö†Ô∏è Supabase not configured, skipping real-time subscription'\n      );\n      setStatus((prev) => ({\n        ...prev,\n        error: 'Supabase not configured',\n      }));\n      return;\n    }\n\n    // Clear any existing connection timeout\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n\n    try {\n      // Clean up existing subscription\n      if (subscriptionRef.current) {\n        subscriptionRef.current();\n        subscriptionRef.current = null;\n      }\n\n      // Set connection timeout\n      connectionTimeoutRef.current = setTimeout(() => {\n        console.warn('‚ö†Ô∏è Real-time connection timeout after 5 seconds');\n        setStatus((prev) => ({\n          ...prev,\n          error: 'Connection timeout',\n          isConnected: false,\n          isSubscribed: false,\n          connectionAttempts: prev.connectionAttempts + 1,\n        }));\n      }, connectionTimeout);\n\n      // Use centralized realtime manager\n      subscriptionRef.current = RealtimeManager.subscribe(\n        'environmental_cleans_enhanced',\n        (payload: unknown) => {\n          setStatus((prev) => ({\n            ...prev,\n            lastUpdate: new Date().toISOString(),\n            isConnected: true,\n            isSubscribed: true,\n            error: null,\n          }));\n\n          // Emit custom event for components to listen to\n          const event = new CustomEvent('environmentalCleanUpdate', {\n            detail: {\n              type: (payload as { eventType?: string }).eventType || 'update',\n              data: (payload as { new?: unknown }).new || payload,\n              oldData: (payload as { old?: unknown }).old || null,\n              timestamp: new Date().toISOString(),\n            },\n          });\n          window.dispatchEvent(event);\n        },\n        { event: '*' }\n      );\n    } catch (error) {\n      console.error(\n        '‚ùå Failed to subscribe to environmental cleaning changes:',\n        error\n      );\n      setStatus((prev) => ({\n        ...prev,\n        error: 'Failed to subscribe',\n      }));\n    }\n  }, [connectionTimeout]);\n\n  // Handle reconnection logic\n  const handleReconnection = useCallback(() => {\n    if (status.connectionAttempts >= maxReconnectAttempts) {\n      console.warn(\n        '‚ö†Ô∏è Max reconnection attempts reached for Environmental Clean'\n      );\n      setStatus((prev) => ({\n        ...prev,\n        error: 'Max reconnection attempts reached',\n      }));\n      return;\n    }\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      subscribeToEnvironmentalCleans();\n    }, reconnectDelay);\n  }, [\n    status.connectionAttempts,\n    maxReconnectAttempts,\n    reconnectDelay,\n    subscribeToEnvironmentalCleans,\n  ]);\n\n  // Initialize real-time connection only if autoConnect is true\n  useEffect(() => {\n    if (!autoConnect) {\n      return;\n    }\n\n    // Subscribe to environmental cleaning changes\n    subscribeToEnvironmentalCleans();\n\n    // Set up reconnection on error\n    if (status.error && status.connectionAttempts < maxReconnectAttempts) {\n      handleReconnection();\n    }\n\n    // Cleanup function\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n\n      if (connectionTimeoutRef.current) {\n        clearTimeout(connectionTimeoutRef.current);\n      }\n\n      if (subscriptionRef.current) {\n        subscriptionRef.current(); // Call the unsubscribe function\n        subscriptionRef.current = null;\n      }\n    };\n  }, [\n    autoConnect,\n    subscribeToEnvironmentalCleans,\n    status.error,\n    status.connectionAttempts,\n    maxReconnectAttempts,\n    handleReconnection,\n  ]);\n\n  // Handle reconnection on status changes\n  useEffect(() => {\n    if (\n      status.error &&\n      !status.isConnected &&\n      status.connectionAttempts < maxReconnectAttempts\n    ) {\n      handleReconnection();\n    }\n  }, [\n    status.error,\n    status.isConnected,\n    status.connectionAttempts,\n    handleReconnection,\n  ]);\n\n  // Manual reconnection function\n  const reconnect = () => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n\n    setStatus((prev) => ({\n      ...prev,\n      connectionAttempts: 0,\n      error: null,\n    }));\n\n    subscribeToEnvironmentalCleans();\n  };\n\n  // Manual disconnect function\n  const disconnect = () => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n\n    if (subscriptionRef.current) {\n      subscriptionRef.current(); // Call the unsubscribe function\n      subscriptionRef.current = null;\n    }\n\n    setStatus((prev) => ({\n      ...prev,\n      isConnected: false,\n      isSubscribed: false,\n    }));\n  };\n\n  // Subscribe to specific room updates\n  const subscribeToRoomUpdates = (\n    roomId: string,\n    callback: (payload: Record<string, unknown>) => void\n  ) => {\n    if (!isSupabaseConfigured()) {\n      console.warn(\n        '‚ö†Ô∏è Supabase not configured, cannot subscribe to room updates'\n      );\n      return () => {};\n    }\n\n    try {\n      // Use centralized realtime manager\n      return RealtimeManager.subscribe(\n        'environmental_cleans_enhanced',\n        callback as (payload: unknown) => void,\n        {\n          event: '*',\n          // filter: `room_id=eq.${roomId}`,\n        }\n      );\n    } catch (error) {\n      console.error('‚ùå Failed to subscribe to room updates:', error);\n      return () => {};\n    }\n  };\n\n  // Subscribe to status changes\n  const subscribeToStatusChanges = (\n    status: RoomStatusType,\n    callback: (payload: Record<string, unknown>) => void\n  ) => {\n    if (!isSupabaseConfigured()) {\n      console.warn(\n        '‚ö†Ô∏è Supabase not configured, cannot subscribe to status changes'\n      );\n      return () => {};\n    }\n\n    try {\n      // Use centralized realtime manager\n      return RealtimeManager.subscribe(\n        'environmental_cleans_enhanced',\n        callback as (payload: unknown) => void,\n        {\n          event: '*',\n          // filter: `status=eq.${status}`,\n        }\n      );\n    } catch (error) {\n      console.error('‚ùå Failed to subscribe to status changes:', error);\n      return () => {};\n    }\n  };\n\n  return {\n    ...status,\n    reconnect,\n    disconnect,\n    subscribeToRoomUpdates,\n    subscribeToStatusChanges,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\usePredictiveCleaning.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useRecentlyCleanedRooms.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\hooks\\useRoomScanner.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\mockData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\models.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\providers\\EnvironmentalCleanDataProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\providers\\EnvironmentalCleanProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\providers\\EnvironmentalCleanUIProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\EnvironmentalCleanAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\EnvironmentalCleanService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\EnvironmentalCleaningInventoryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\EnvironmentalCleaningTaskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\PredictiveCleaningIntegrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\RoomScanService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\__tests__\\EnvironmentalCleanService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\errors\\EnvironmentalCleanServiceError.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\services\\RoomService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 52,
        "column": 53,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 52,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1418, 1421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1418, 1421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 172,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 172,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5056, 5059], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5056, 5059], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 173,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 173,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5093, 5096], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5093, 5096], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 173,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 173,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5128, 5131], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5128, 5131], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 174,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 174,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5199, 5202], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5199, 5202], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 176,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 176,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5266, 5269], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5266, 5269], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 177,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 177,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5326, 5329], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5326, 5329], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 179,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 179,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5392, 5395], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5392, 5395], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 180,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 180,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5437, 5440], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5437, 5440], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 225,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 225,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6591, 6594], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6591, 6594], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 226,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 226,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6628, 6631], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6628, 6631], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 226,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 226,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6663, 6666], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6663, 6666], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 227,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 227,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6734, 6737], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6734, 6737], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 229,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 229,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6801, 6804], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6801, 6804], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 230,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 230,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6860, 6863], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6860, 6863], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 231,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 231,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6921, 6924], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6921, 6924], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 232,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 232,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6983, 6986], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6983, 6986], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 233,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 233,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7044, 7047], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7044, 7047], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 235,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 235,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7117, 7120], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7117, 7120], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 236,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 236,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7162, 7165], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7162, 7165], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 20,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabase';\nimport { Room, RoomStatusType } from '../../models';\nimport { auditLogger } from '@/utils/auditLogger';\nimport { createUserFriendlyError } from '../errors/EnvironmentalCleanServiceError';\nimport {\n  mapDatabaseStatusToRoomStatus,\n  mapRoomStatusToDatabaseStatus,\n} from '../utils/statusMapper';\n\n// Row type for Supabase mapping\ninterface EnvironmentalCleanRow {\n  id: string;\n  room_id: string;\n  room_name: string | null;\n  status: string;\n  cleaning_type: string | null;\n  scheduled_time: string | null;\n  completed_time?: string | null;\n  quality_score?: number | null;\n  compliance_score?: number | null;\n  checklist_items?: string[] | null;\n  completed_items?: string[] | null;\n  failed_items?: string[] | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport class RoomService {\n  static async fetchRooms(): Promise<Room[]> {\n    try {\n      const { data, error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .select(\n          `\n          id,\n          room_id,\n          room_name,\n          status,\n          cleaning_type,\n          scheduled_time,\n          completed_time,\n          quality_score,\n          compliance_score,\n          created_at,\n          updated_at\n        `\n        )\n        .order('scheduled_time', { ascending: false });\n\n      if (error) throw error;\n\n      const rooms: Room[] = (data ?? []).map((item: any) => {\n        const mappedStatus = mapDatabaseStatusToRoomStatus(item.status);\n        return {\n          id: item.room_id || item.id,\n          name: item.room_name || `Room ${item.room_id || item.id}`,\n          status: mappedStatus,\n          metadata: {\n            cleaningType: item.cleaning_type ?? '',\n            qualityScore: item.quality_score ?? 0,\n            complianceScore: item.compliance_score ?? 0,\n            scheduledTime: item.scheduled_time ?? '',\n            completedTime: item.completed_time ?? undefined,\n          },\n          createdAt: item.created_at,\n          updatedAt: item.updated_at,\n        };\n      });\n\n      return rooms;\n    } catch (error) {\n      console.warn(\n        'Environmental Clean rooms fetch failed, falling back to static data:',\n        error\n      );\n      return [\n        {\n          id: 'room-1',\n          name: 'Operating Room 1',\n          status: 'pending' as RoomStatusType,\n          metadata: {\n            cleaningType: 'surgical',\n            qualityScore: 95,\n            complianceScore: 98,\n            scheduledTime: new Date().toISOString(),\n            completedTime: undefined,\n          },\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n        {\n          id: 'room-2',\n          name: 'Recovery Room A',\n          status: 'in_progress' as RoomStatusType,\n          metadata: {\n            cleaningType: 'standard',\n            qualityScore: 87,\n            complianceScore: 92,\n            scheduledTime: new Date().toISOString(),\n            completedTime: undefined,\n          },\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n        {\n          id: 'room-3',\n          name: 'ICU Room 3',\n          status: 'completed' as RoomStatusType,\n          metadata: {\n            cleaningType: 'intensive',\n            qualityScore: 99,\n            complianceScore: 100,\n            scheduledTime: new Date().toISOString(),\n            completedTime: new Date().toISOString(),\n          },\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n      ];\n    }\n  }\n\n  static async updateRoomStatus(\n    roomId: string,\n    status: RoomStatusType\n  ): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .update({\n          status: mapRoomStatusToDatabaseStatus(status),\n          updated_at: new Date().toISOString(),\n        })\n        .eq('room_id', roomId);\n\n      if (error) throw error;\n\n      auditLogger.log('environmental_clean', 'room_status_updated', {\n        roomId,\n        status,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      const friendlyError = createUserFriendlyError(error, 'updateRoomStatus');\n      console.error('‚ùå Failed to update room status:', friendlyError);\n      throw friendlyError;\n    }\n  }\n\n  static async createEnvironmentalClean(\n    roomData: Partial<Room>\n  ): Promise<Room> {\n    try {\n      const { data, error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .insert({\n          room_id: roomData.id ?? '',\n          room_name: roomData.name ?? '',\n          status: 'pending',\n          cleaning_type: 'routine',\n          scheduled_time: new Date().toISOString(),\n          checklist_items: [],\n          completed_items: [],\n          failed_items: [],\n        })\n        .select()\n        .single();\n\n      if (error || !data) throw error ?? new Error('Insert failed');\n\n      const room: Room = {\n        id: (data as any).room_id,\n        name: (data as any).room_name || `Room ${(data as any).room_id}`,\n        status: mapDatabaseStatusToRoomStatus((data as any).status),\n        metadata: {\n          cleaningType: (data as any).cleaning_type ?? '',\n          scheduledTime: (data as any).scheduled_time ?? '',\n        },\n        createdAt: (data as any).created_at,\n        updatedAt: (data as any).updated_at,\n      };\n\n      auditLogger.log('environmental_clean', 'room_created', {\n        roomId: room.id,\n        roomName: room.name,\n      });\n\n      return room;\n    } catch (error) {\n      const friendlyError = createUserFriendlyError(\n        error,\n        'createEnvironmentalClean'\n      );\n      console.error('‚ùå Failed to create environmental clean:', friendlyError);\n      throw friendlyError;\n    }\n  }\n\n  static async updateEnvironmentalClean(\n    id: string,\n    roomData: Partial<Room>\n  ): Promise<Room> {\n    try {\n      const updateData: Partial<EnvironmentalCleanRow> = {\n        updated_at: new Date().toISOString(),\n      };\n\n      if (roomData.name) {\n        updateData.room_name = roomData.name;\n      }\n      if (roomData.status) {\n        updateData.status = mapRoomStatusToDatabaseStatus(roomData.status);\n      }\n\n      const { data, error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .update(updateData)\n        .eq('room_id', id)\n        .select()\n        .single();\n\n      if (error || !data) throw error ?? new Error('Update failed');\n\n      const room: Room = {\n        id: (data as any).room_id,\n        name: (data as any).room_name || `Room ${(data as any).room_id}`,\n        status: mapDatabaseStatusToRoomStatus((data as any).status),\n        metadata: {\n          cleaningType: (data as any).cleaning_type ?? '',\n          qualityScore: (data as any).quality_score ?? 0,\n          complianceScore: (data as any).compliance_score ?? 0,\n          scheduledTime: (data as any).scheduled_time ?? '',\n          completedTime: (data as any).completed_time ?? undefined,\n        },\n        createdAt: (data as any).created_at,\n        updatedAt: (data as any).updated_at,\n      };\n\n      auditLogger.log('environmental_clean', 'room_updated', {\n        roomId: room.id,\n        roomName: room.name,\n      });\n\n      return room;\n    } catch (error) {\n      const friendlyError = createUserFriendlyError(\n        error,\n        'updateEnvironmentalClean'\n      );\n      console.error('‚ùå Failed to update environmental clean:', friendlyError);\n      throw friendlyError;\n    }\n  }\n\n  static async deleteEnvironmentalClean(id: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .delete()\n        .eq('room_id', id);\n\n      if (error) throw error;\n\n      auditLogger.log('environmental_clean', 'room_deleted', { roomId: id });\n    } catch (error) {\n      const friendlyError = createUserFriendlyError(\n        error,\n        'deleteEnvironmentalClean'\n      );\n      console.error('‚ùå Failed to delete environmental clean:', friendlyError);\n      throw friendlyError;\n    }\n  }\n\n  static async completeRoomCleaning(roomId: string): Promise<void> {\n    try {\n      if (!roomId) throw new Error('Room ID is required');\n\n      const { error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .update({\n          status: 'completed',\n          completed_time: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        })\n        .eq('room_id', roomId);\n\n      if (error) throw error;\n\n      auditLogger.log('environmental_clean', 'room_cleaning_completed', {\n        roomId,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      const friendlyError = createUserFriendlyError(\n        error,\n        'completeRoomCleaning'\n      );\n      console.error('‚ùå Error completing room cleaning:', friendlyError);\n      throw friendlyError;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\utils\\dataTransformers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\services\\utils\\statusMapper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\store\\environmentalCleanStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\utils\\keyboardNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\EnvironmentalClean\\utils\\statusUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\DashboardHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\GamificationSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\Gamification\\LeaderboardDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\Gamification\\PointsDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\Gamification\\ProgressDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\Gamification\\StreakDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\Gamification\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeContentLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeGamificationSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeMetricsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\HomeTasksSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\MetricsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\MetricsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\OperationsTasksContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\OperationsTasksList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\TaskErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\TaskLoadingStates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\TaskManagementLogic.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\TaskSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\TasksPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\constants\\homeConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\hooks\\useHomePageState.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\hooks\\useHomeTaskSection.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 94,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useCallback } from 'react';\nimport { useHomeStore, Task } from '../../../store/homeStore';\nimport { isValidTaskInput } from '../../../utils/validateTask';\nimport { handleTaskCompletion } from '../../../utils/handleTaskCompletion';\nimport { logger } from '../../../utils/logger';\nimport { TASK_POINTS, TASK_VALIDATION } from '../../../constants/taskConstants';\n\nexport const useHomeTaskSection = () => {\n  const storeAvailablePoints = useHomeStore((state) => state.availablePoints);\n  const storeShowFilters = useHomeStore((state) => state.showFilters);\n  const setStoreShowFilters = useHomeStore((state) => state.setShowFilters);\n  const updateGamificationData = useHomeStore(\n    (state) => state.updateGamificationData\n  );\n  const tasks = useHomeStore((state) => state.tasks);\n  const setTasks = useHomeStore((state) => state.setTasks);\n  const loading = false; // Since we're not using the useTasks hook anymore\n\n  const [selectedCategory, setSelectedCategory] = useState('');\n  const [selectedType, setSelectedType] = useState('');\n  const [taskError, setTaskError] = useState<string | null>(null);\n\n  const handleCategoryChange = useCallback((value: string) => {\n    setSelectedCategory(value);\n  }, []);\n\n  const handleTypeChange = useCallback((value: string) => {\n    setSelectedType(value);\n  }, []);\n\n  // Validate task input\n  const validateTaskInput = useCallback((taskId: string, points?: number) => {\n    if (\n      !taskId ||\n      typeof taskId !== 'string' ||\n      !TASK_VALIDATION.UUID_REGEX.test(taskId)\n    ) {\n      logger.warn('Invalid task ID:', taskId);\n      return false;\n    }\n\n    if (!isValidTaskInput(taskId, points)) {\n      logger.warn('Invalid task input provided to handleTaskComplete');\n      return false;\n    }\n\n    return true;\n  }, []);\n\n  // Update task completion status\n  const updateTaskCompletion = useCallback(\n    (taskId: string, points?: number) => {\n      // Update total score if points are provided\n      if (\n        typeof points === 'number' &&\n        points > TASK_POINTS.MIN &&\n        points <= TASK_POINTS.MAX\n      ) {\n        updateGamificationData({ totalScore: points });\n      }\n    },\n    [updateGamificationData]\n  );\n\n  const handleTaskCompleteWithErrorHandling = useCallback(\n    async (taskId: string, points?: number) => {\n      handleTaskCompletion(taskId);\n\n      if (!validateTaskInput(taskId, points)) {\n        return;\n      }\n\n      try {\n        updateTaskCompletion(taskId, points);\n      } catch (err) {\n        setTaskError('Failed to complete task. Please try again.');\n        logger.error(err);\n      }\n    },\n    [validateTaskInput, updateTaskCompletion, setTaskError]\n  );\n\n  const handleTaskUpdate = useCallback(\n    async (taskId: string) => {\n      try {\n        // Update local state\n        const updatedTasks = tasks.map((task: Task) =>\n          task.id === taskId ? { ...task, completed: !task.completed } : task\n        );\n        setTasks(updatedTasks);\n      } catch (err) { console.error(err); throw err; }\n        setTaskError('Failed to update task. Please try again.');\n      }\n    },\n    [tasks, setTasks]\n  );\n\n  const toggleFilters = useCallback(() => {\n    setStoreShowFilters(!storeShowFilters);\n  }, [storeShowFilters, setStoreShowFilters]);\n\n  return {\n    // State\n    tasks,\n    loading,\n    taskError,\n    selectedCategory,\n    selectedType,\n    storeAvailablePoints,\n    storeShowFilters,\n\n    // Actions\n    handleCategoryChange,\n    handleTypeChange,\n    handleTaskCompleteWithErrorHandling,\n    handleTaskUpdate,\n    toggleFilters,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Home\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceActionsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceForecastingTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceInsightsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceIntegrationsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceOverviewTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\IntelligenceRisksTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\IntelligenceCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\IntelligenceEmptyState.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\IntelligenceHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\IntelligenceMetricsGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\IntelligenceTabNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\cards\\MetricCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\hooks\\useIntelligenceData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\ActionsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\ForecastingTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\InsightsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\IntegrationsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\OverviewTab.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'tab' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 62,
        "column": 25,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 62,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiTrendingDown,\n  mdiShieldAlert,\n  mdiCurrencyUsd,\n  mdiAccountGroup,\n  mdiExclamation,\n  mdiInformation,\n  mdiRefresh,\n} from '@mdi/js';\nimport { IntelligenceSummary } from '../utils/intelligenceTypes';\nimport { RiskAlert } from '../../../services/analytics';\n\ninterface OverviewTabProps {\n  summary: IntelligenceSummary | null;\n  actionableInsights?: RiskAlert[];\n}\n\nexport default function OverviewTab({ summary }: OverviewTabProps) {\n  // Use the passed summary prop\n  const data = summary;\n\n  function hasHighRiskItems() {\n    return data?.risks?.some((risk) => risk.level === 'high');\n  }\n\n  function getUrgentActions() {\n    return data?.actions?.filter((action) => action.urgency === 'high') ?? [];\n  }\n\n  function getUrgencyColor(urgency: string) {\n    switch (urgency.toLowerCase()) {\n      case 'critical':\n        return 'border-red-500 bg-red-50';\n      case 'high':\n        return 'border-orange-500 bg-orange-50';\n      case 'medium':\n        return 'border-yellow-500 bg-yellow-50';\n      case 'low':\n        return 'border-green-500 bg-green-50';\n      default:\n        return 'border-gray-500 bg-gray-50';\n    }\n  }\n\n  function getRiskLevelColor(urgency: string) {\n    switch (urgency.toLowerCase()) {\n      case 'critical':\n        return 'bg-red-100 text-red-800';\n      case 'high':\n        return 'bg-orange-100 text-orange-800';\n      case 'medium':\n        return 'bg-yellow-100 text-yellow-800';\n      case 'low':\n        return 'bg-green-100 text-green-800';\n      default:\n        return 'bg-gray-100 text-gray-800';\n    }\n  }\n\n  function setActiveTab(tab: string) {\n    // This would typically be passed as a prop or handled by parent component\n  }\n  return (\n    <div className=\"space-y-6\">\n      {/* Intelligence Summary Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <div className=\"flex items-center\">\n            <div className=\"p-2 bg-blue-100 rounded-lg\">\n              <Icon\n                path={mdiTrendingDown}\n                size={1.5}\n                className=\"text-blue-600\"\n              />\n            </div>\n            <div className=\"ml-4\">\n              <p className=\"text-sm font-medium text-gray-600\">\n                Forecasts Active\n              </p>\n              <p className=\"text-2xl font-bold text-gray-900\">\n                {(data?.toolReplacement?.length || 0) +\n                  (data?.autoclaveCapacity?.length || 0) +\n                  (data?.supplyDepletion?.length || 0)}\n              </p>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <div className=\"flex items-center\">\n            <div className=\"p-2 bg-orange-100 rounded-lg\">\n              <Icon\n                path={mdiShieldAlert}\n                size={1.5}\n                className=\"text-orange-600\"\n              />\n            </div>\n            <div className=\"ml-4\">\n              <p className=\"text-sm font-medium text-gray-600\">Risk Level</p>\n              <p className=\"text-2xl font-bold text-gray-900 capitalize\">\n                {data?.auditRisk?.riskLevel || 'No data'}\n              </p>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <div className=\"flex items-center\">\n            <div className=\"p-2 bg-green-100 rounded-lg\">\n              <Icon\n                path={mdiCurrencyUsd}\n                size={1.5}\n                className=\"text-green-600\"\n              />\n            </div>\n            <div className=\"ml-4\">\n              <p className=\"text-sm font-medium text-gray-600\">\n                Monthly Savings\n              </p>\n              <p className=\"text-2xl font-bold text-gray-900\">\n                $\n                {(\n                  data?.efficiencyROI?.estimatedLaborSavings || 0\n                ).toLocaleString()}\n              </p>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <div className=\"flex items-center\">\n            <div className=\"p-2 bg-purple-100 rounded-lg\">\n              <Icon\n                path={mdiAccountGroup}\n                size={1.5}\n                className=\"text-purple-600\"\n              />\n            </div>\n            <div className=\"ml-4\">\n              <p className=\"text-sm font-medium text-gray-600\">Training Gaps</p>\n              <p className=\"text-2xl font-bold text-gray-900\">\n                {data?.trainingGaps?.usersWithGaps?.length || 0}\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* High Priority Alerts */}\n      {hasHighRiskItems() && (\n        <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n          <div className=\"flex items-center\">\n            <Icon\n              path={mdiExclamation}\n              size={1.5}\n              className=\"text-red-600 mr-3\"\n            />\n            <div>\n              <h3 className=\"text-sm font-medium text-red-800\">\n                High Priority Alerts\n              </h3>\n              <p className=\"text-sm text-red-700 mt-1\">\n                {getUrgentActions().length} urgent actions require immediate\n                attention\n              </p>\n            </div>\n            <button\n              onClick={() => setActiveTab('actions')}\n              className=\"ml-auto bg-red-100 text-red-800 px-3 py-2 rounded-md text-sm font-medium hover:bg-red-200\"\n            >\n              View Actions\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Recent Forecasts */}\n      <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n        <h3 className=\"text-lg font-medium text-gray-900 mb-4\">\n          Recent Forecasts\n        </h3>\n        {data?.supplyDepletion && data.supplyDepletion.length > 0 ? (\n          <div className=\"space-y-3\">\n            {data.supplyDepletion.slice(0, 3).map((item, index) => (\n              <div\n                key={index}\n                className={`p-3 rounded-lg border-l-4 ${getUrgencyColor(item.reorderUrgency)}`}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <p className=\"font-medium text-gray-900\">{item.itemName}</p>\n                    <p className=\"text-sm text-gray-600\">\n                      Depletes in{' '}\n                      {Math.ceil(\n                        (new Date(item.depletionDate).getTime() - Date.now()) /\n                          (1000 * 60 * 60 * 24)\n                      )}{' '}\n                      days\n                    </p>\n                  </div>\n                  <span\n                    className={`px-2 py-1 rounded-full text-xs font-medium ${getRiskLevelColor(item.reorderUrgency)}`}\n                  >\n                    {item.reorderUrgency}\n                  </span>\n                </div>\n              </div>\n            ))}\n          </div>\n        ) : (\n          <div className=\"text-center py-8\">\n            <Icon\n              path={mdiInformation}\n              size={2}\n              className=\"text-gray-400 mx-auto mb-2\"\n            />\n            <p className=\"text-gray-600\">\n              No supply depletion forecasts available\n            </p>\n            <p className=\"text-sm text-gray-500\">\n              Data will appear here once inventory items are added\n            </p>\n          </div>\n        )}\n      </div>\n\n      {/* Tool Turnover & Utilization */}\n      {data?.toolTurnoverUtilization &&\n      data.toolTurnoverUtilization.length > 0 ? (\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <h3 className=\"text-lg font-medium text-gray-900 mb-4 flex items-center\">\n            <Icon path={mdiRefresh} size={1.5} className=\"text-blue-600 mr-2\" />\n            Tool Turnover & Utilization\n          </h3>\n          <div className=\"space-y-4\">\n            {data.toolTurnoverUtilization.slice(0, 3).map((tool, index) => (\n              <div\n                key={index}\n                className=\"border border-gray-200 rounded-lg p-4\"\n              >\n                <div className=\"flex items-start justify-between mb-3\">\n                  <div>\n                    <h4 className=\"font-medium text-gray-900\">\n                      {tool.toolName}\n                    </h4>\n                    <p className=\"text-sm text-gray-600\">\n                      Batch: {tool.toolBatchId}\n                    </p>\n                  </div>\n                  <div className=\"text-right\">\n                    <div\n                      className={`px-2 py-1 rounded-full text-xs font-medium ${\n                        tool.performanceScore >= 90\n                          ? 'bg-green-100 text-green-800'\n                          : tool.performanceScore >= 80\n                            ? 'bg-yellow-100 text-yellow-800'\n                            : 'bg-red-100 text-red-800'\n                      }`}\n                    >\n                      Score: {tool.performanceScore}\n                    </div>\n                  </div>\n                </div>\n\n                <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n                  <div>\n                    <span className=\"font-medium text-gray-700\">\n                      Daily Cycles:\n                    </span>\n                    <div className=\"text-gray-900\">{tool.dailyCycleCount}</div>\n                  </div>\n                  <div>\n                    <span className=\"font-medium text-gray-700\">\n                      Turnover Rate:\n                    </span>\n                    <div className=\"text-gray-900\">\n                      {tool.turnoverRate.toFixed(1)}x/day\n                    </div>\n                  </div>\n                  <div>\n                    <span className=\"font-medium text-gray-700\">\n                      Efficiency:\n                    </span>\n                    <div className=\"text-gray-900\">\n                      {tool.utilizationEfficiency}%\n                    </div>\n                  </div>\n                  <div>\n                    <span className=\"font-medium text-gray-700\">\n                      Idle Time:\n                    </span>\n                    <div className=\"text-gray-900\">\n                      {tool.idleTimePercentage}%\n                    </div>\n                  </div>\n                </div>\n\n                <div className=\"mt-3 pt-3 border-t border-gray-200\">\n                  <div className=\"text-sm\">\n                    <span className=\"font-medium text-gray-700\">\n                      Peak Hours:\n                    </span>\n                    <span className=\"text-gray-600 ml-2\">\n                      {tool.peakUsageHours.join(', ')}\n                    </span>\n                  </div>\n                  <div className=\"text-sm mt-1\">\n                    <span className=\"font-medium text-gray-700\">\n                      Optimization:\n                    </span>\n                    <span className=\"text-gray-600 ml-2\">\n                      {tool.recommendedOptimization}\n                    </span>\n                  </div>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : (\n        <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-6\">\n          <div className=\"text-center\">\n            <Icon\n              path={mdiInformation}\n              size={2}\n              className=\"text-gray-400 mx-auto mb-2\"\n            />\n            <p className=\"text-gray-600\">No tool utilization data available</p>\n            <p className=\"text-sm text-gray-500\">\n              Data will appear here once sterilization cycles are completed\n            </p>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\RisksTab.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 111,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 111,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3961, 3964], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3961, 3964], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiShieldAlert,\n  mdiAlertCircle,\n  mdiExclamation,\n  mdiInformation,\n} from '@mdi/js';\nimport { IntelligenceSummary } from '../utils/intelligenceTypes';\n\ninterface RisksTabProps {\n  summary?: IntelligenceSummary | null;\n}\n\nexport default function RisksTab({ summary }: RisksTabProps) {\n  // Helper function for risk level colors\n  const getRiskLevelColor = (level: string) => {\n    switch (level) {\n      case 'low':\n        return 'bg-green-100 text-green-800';\n      case 'medium':\n        return 'bg-yellow-100 text-yellow-800';\n      case 'high':\n        return 'bg-orange-100 text-orange-800';\n      case 'critical':\n        return 'bg-red-100 text-red-800';\n      default:\n        return 'bg-gray-100 text-gray-800';\n    }\n  };\n\n  if (!summary) {\n    return (\n      <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-6\">\n        <div className=\"text-center\">\n          <Icon\n            path={mdiInformation}\n            size={2}\n            className=\"text-gray-400 mx-auto mb-2\"\n          />\n          <p className=\"text-gray-600\">No risk analysis data available</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Audit Risk Score */}\n      {summary.auditRisk ? (\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <h3 className=\"text-lg font-medium text-gray-900 mb-4 flex items-center\">\n            <Icon\n              path={mdiShieldAlert}\n              size={1.5}\n              className=\"text-red-600 mr-2\"\n            />\n            Audit Risk Assessment\n          </h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n            <div className=\"text-center\">\n              <div\n                className={`inline-flex items-center justify-center w-20 h-20 rounded-full ${getRiskLevelColor(summary.auditRisk?.riskLevel || 'medium')} mb-3`}\n              >\n                <span className=\"text-2xl font-bold\">\n                  {summary.auditRisk?.overallRiskScore || 85}\n                </span>\n              </div>\n              <p className=\"text-sm font-medium text-gray-900\">\n                Overall Risk Score\n              </p>\n              <p\n                className={`text-sm font-medium capitalize ${getRiskLevelColor(summary.auditRisk?.riskLevel || 'medium')}`}\n              >\n                {summary.auditRisk?.riskLevel || 'medium'} Risk\n              </p>\n            </div>\n\n            <div className=\"text-center\">\n              <div className=\"inline-flex items-center justify-center w-20 h-20 rounded-full bg-orange-100 text-orange-600 mb-3\">\n                <span className=\"text-2xl font-bold\">\n                  {summary.auditRisk?.incompleteCycles || 2}\n                </span>\n              </div>\n              <p className=\"text-sm font-medium text-gray-900\">\n                Incomplete Cycles\n              </p>\n              <p className=\"text-sm text-orange-600\">This Week</p>\n            </div>\n\n            <div className=\"text-center\">\n              <div className=\"inline-flex items-center justify-center w-20 h-20 rounded-full bg-yellow-100 text-yellow-600 mb-3\">\n                <span className=\"text-2xl font-bold\">\n                  {summary.auditRisk?.riskFactors?.length || 2}\n                </span>\n              </div>\n              <p className=\"text-sm font-medium text-gray-900\">Risk Factors</p>\n              <p className=\"text-sm text-yellow-600\">Identified</p>\n            </div>\n          </div>\n\n          {/* Risk Factors */}\n          <div className=\"mt-6\">\n            <h4 className=\"text-md font-medium text-gray-900 mb-3\">\n              Risk Factors\n            </h4>\n            <div className=\"space-y-3\">\n              {summary.auditRisk?.riskFactors &&\n              summary.auditRisk.riskFactors.length > 0 ? (\n                summary.auditRisk.riskFactors.map(\n                  (riskFactor: any, index: number) => (\n                    <div\n                      key={index}\n                      className=\"flex items-center justify-between p-3 bg-gray-50 rounded-lg\"\n                    >\n                      <div>\n                        <p className=\"font-medium text-gray-900\">\n                          {riskFactor.factor}\n                        </p>\n                        <p className=\"text-sm text-gray-600\">\n                          {riskFactor.description}\n                        </p>\n                      </div>\n                      <span className=\"px-3 py-1 rounded-full text-sm font-medium bg-orange-100 text-orange-800\">\n                        Severity: {riskFactor.severity}\n                      </span>\n                    </div>\n                  )\n                )\n              ) : (\n                <div className=\"text-center py-4 text-gray-500\">\n                  No risk factors identified\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      ) : (\n        <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-6\">\n          <div className=\"text-center\">\n            <Icon\n              path={mdiInformation}\n              size={2}\n              className=\"text-gray-400 mx-auto mb-2\"\n            />\n            <p className=\"text-gray-600\">No audit risk data available</p>\n            <p className=\"text-sm text-gray-500\">\n              Data will appear here once sterilization cycles are completed\n            </p>\n          </div>\n        </div>\n      )}\n\n      {/* Theft/Loss Analysis */}\n      {summary.theftLoss ? (\n        <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n          <h3 className=\"text-lg font-medium text-gray-900 mb-4 flex items-center\">\n            <Icon\n              path={mdiAlertCircle}\n              size={1.5}\n              className=\"text-orange-600 mr-2\"\n            />\n            Theft & Loss Analysis\n          </h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n            <div>\n              <div className=\"text-center mb-4\">\n                <div className=\"inline-flex items-center justify-center w-16 h-16 rounded-full bg-orange-100 text-orange-600 mb-2\">\n                  <span className=\"text-xl font-bold\">\n                    {summary.theftLoss.estimatedLossPercentage || 0}%\n                  </span>\n                </div>\n                <p className=\"text-sm font-medium text-gray-900\">\n                  Estimated Loss\n                </p>\n                <p className=\"text-lg font-bold text-orange-600\">\n                  $\n                  {summary.theftLoss.estimatedLossValue?.toLocaleString() ||\n                    '0'}\n                </p>\n              </div>\n\n              <div className=\"space-y-2\">\n                <h4 className=\"font-medium text-gray-900\">Flagged Items:</h4>\n                <ul className=\"text-sm text-gray-600 space-y-1\">\n                  {summary.theftLoss?.flaggedItems &&\n                  summary.theftLoss.flaggedItems.length > 0 ? (\n                    summary.theftLoss.flaggedItems.map(\n                      (item: string, index: number) => (\n                        <li key={index} className=\"flex items-center\">\n                          <Icon\n                            path={mdiExclamation}\n                            size={0.8}\n                            className=\"text-orange-500 mr-2\"\n                          />\n                          {item}\n                        </li>\n                      )\n                    )\n                  ) : (\n                    <li className=\"text-gray-500\">No flagged items</li>\n                  )}\n                </ul>\n              </div>\n            </div>\n\n            <div>\n              <div className=\"space-y-4\">\n                <div>\n                  <h4 className=\"font-medium text-gray-900 mb-2\">\n                    Risk Factors:\n                  </h4>\n                  <ul className=\"text-sm text-gray-600 space-y-1\">\n                    {summary.theftLoss?.riskFactors &&\n                    summary.theftLoss.riskFactors.length > 0 ? (\n                      summary.theftLoss.riskFactors.map(\n                        (factor: string, index: number) => (\n                          <li key={index} className=\"flex items-center\">\n                            <Icon\n                              path={mdiInformation}\n                              size={0.8}\n                              className=\"text-blue-500 mr-2\"\n                            />\n                            {factor}\n                          </li>\n                        )\n                      )\n                    ) : (\n                      <li className=\"text-gray-500\">\n                        No risk factors identified\n                      </li>\n                    )}\n                  </ul>\n                </div>\n\n                <div>\n                  <h4 className=\"font-medium text-gray-900 mb-2\">\n                    Incident Summary:\n                  </h4>\n                  <div className=\"text-sm text-gray-600 space-y-1\">\n                    <p>\n                      Flagged Items:{' '}\n                      {summary.theftLoss?.flaggedItems?.length || 0}\n                    </p>\n                    <p>\n                      Risk Factors:{' '}\n                      {summary.theftLoss?.riskFactors?.length || 0}\n                    </p>\n                    <p>\n                      Recommended Actions:{' '}\n                      {summary.theftLoss?.recommendedActions?.length || 0}\n                    </p>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <div className=\"bg-gray-50 border border-gray-200 rounded-lg p-6\">\n          <div className=\"text-center\">\n            <Icon\n              path={mdiInformation}\n              size={2}\n              className=\"text-gray-400 mx-auto mb-2\"\n            />\n            <p className=\"text-gray-600\">No theft/loss data available</p>\n            <p className=\"text-sm text-gray-500\">\n              Data will appear here once inventory tracking is implemented\n            </p>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\tabs\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\types\\intelligence.types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\utils\\intelligenceConstants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\utils\\intelligenceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Intelligence\\utils\\intelligenceUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\InventoryContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\InventoryControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\InventoryDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\InventoryLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\ScanInventoryModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\ScannerPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\AdvancedExportModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\BulkImportModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\BulkOperationProgress.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\InventoryAnalyticsSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\InventoryHeaderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\InventoryModalsWrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\PerformanceMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\ScanModalActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\ScanModalContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\ScanModalHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\components\\ScanModalWrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\context\\InventoryDashboardContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\context\\InventorySearchContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useInventoryDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useInventoryPageSetup.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useInventorySearch.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useInventoryState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useInventoryUIState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\hooks\\useScanModalLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\providers\\InventoryDataManagerProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\providers\\InventoryDataProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\providers\\InventoryProviders.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\__tests__\\inventoryServiceHierarchy.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\caching.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\formatter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\performance.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\progress.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\retry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\bulkProgress\\workerPool.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\cache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\fileManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\formatting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\memory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\streaming.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\export\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryActionHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryActionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryBulkProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryControlHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryControlService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryDataHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryErrorService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryExportService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryExportTemplateService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryHeaderHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryHeaderService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryImportService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 228,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { InventoryItem } from '@/types/inventoryTypes';\nimport { InventoryServiceFacade } from '@/services/inventory/InventoryServiceFacade';\n\nexport type ImportFormat = 'csv' | 'json';\n\nexport interface ImportOptions {\n  format: ImportFormat;\n  hasHeaders?: boolean;\n  skipValidation?: boolean;\n  duplicateHandling?: 'skip' | 'update' | 'create';\n  customFieldMapping?: Record<string, string>;\n}\n\nexport interface ImportResult {\n  success: boolean;\n  importedCount: number;\n  failedCount: number;\n  skippedCount: number;\n  errors: string[];\n  warnings: string[];\n  fileName: string;\n}\n\nexport interface ImportValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  validItems: InventoryItem[];\n  invalidItems: Array<{ item: Partial<InventoryItem>; errors: string[] }>;\n}\n\n/**\n * Service for handling inventory data imports\n */\nexport class InventoryImportService {\n  /**\n   * Import inventory items from file\n   */\n  static async importItems(\n    file: File,\n    options: ImportOptions = { format: 'csv', hasHeaders: true }\n  ): Promise<ImportResult> {\n    try {\n      // Read file content\n      const content = await this.readFileContent(file);\n\n      // Parse content based on format\n      const parsedItems = await this.parseContent(content, options);\n\n      // Validate items\n      const validation = await this.validateItems(parsedItems);\n\n      // Process import\n      const result = await this.processImport(validation.validItems, options);\n\n      return {\n        success: result.success,\n        importedCount: result.importedCount,\n        failedCount: validation.invalidItems.length,\n        skippedCount: result.skippedCount,\n        errors: [...validation.errors, ...result.errors],\n        warnings: validation.warnings,\n        fileName: file.name,\n      };\n    } catch (error) {\n      console.error('Import failed:', error);\n      return {\n        success: false,\n        importedCount: 0,\n        failedCount: 0,\n        skippedCount: 0,\n        errors: [\n          `Import failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        ],\n        warnings: [],\n        fileName: file.name,\n      };\n    }\n  }\n\n  /**\n   * Read file content as text\n   */\n  private static async readFileContent(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target?.result as string);\n      reader.onerror = () => reject(new Error('Failed to read file'));\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   * Parse content based on format\n   */\n  private static async parseContent(\n    content: string,\n    options: ImportOptions\n  ): Promise<Partial<InventoryItem>[]> {\n    switch (options.format) {\n      case 'csv':\n        return this.parseCSV(content, options);\n      case 'json':\n        return this.parseJSON(content);\n      default:\n        throw new Error(`Unsupported import format: ${options.format}`);\n    }\n  }\n\n  /**\n   * Parse CSV content\n   */\n  private static parseCSV(\n    content: string,\n    options: ImportOptions\n  ): Partial<InventoryItem>[] {\n    const lines = content.split('\\n').filter((line) => line.trim());\n    const items: Partial<InventoryItem>[] = [];\n\n    let startIndex = 0;\n    if (options.hasHeaders) {\n      startIndex = 1;\n    }\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i];\n      const values = this.parseCSVLine(line);\n\n      if (values.length > 0) {\n        const item = this.createItemFromCSVValues(values, options);\n        if (item) {\n          items.push(item);\n        }\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * Parse CSV line with proper escaping\n   */\n  private static parseCSVLine(line: string): string[] {\n    const values: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          current += '\"';\n          i++; // Skip next quote\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        values.push(current.trim());\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    values.push(current.trim());\n    return values;\n  }\n\n  /**\n   * Create item from CSV values\n   */\n  private static createItemFromCSVValues(\n    values: string[],\n    options: ImportOptions\n  ): Partial<InventoryItem> | null {\n    if (values.length < 3) return null; // Need at least id, item, category\n\n    const defaultFields = [\n      'id',\n      'item',\n      'category',\n      'location',\n      'status',\n      'quantity',\n      'cost',\n      'vendor',\n      'purchaseDate',\n      'warranty',\n      'lastUpdated',\n    ];\n    const fields = options.customFieldMapping\n      ? Object.values(options.customFieldMapping)\n      : defaultFields;\n\n    const item: Partial<InventoryItem> = {};\n\n    for (let i = 0; i < Math.min(fields.length, values.length); i++) {\n      const field = fields[i];\n      const value = values[i];\n\n      if (value && value.trim()) {\n        (item as Record<string, unknown>)[field] = this.parseFieldValue(\n          value,\n          field\n        );\n      }\n    }\n\n    return item;\n  }\n\n  /**\n   * Parse JSON content\n   */\n  private static parseJSON(content: string): Partial<InventoryItem>[] {\n    try {\n      const data = JSON.parse(content);\n      return Array.isArray(data) ? data : [data];\n    } catch (err) { console.error(err); throw err; }\n      throw new Error('Invalid JSON format');\n    }\n  }\n\n  /**\n   * Parse field value based on field type\n   */\n  private static parseFieldValue(value: string, field: string): unknown {\n    if (field === 'quantity' || field === 'cost') {\n      const num = parseFloat(value);\n      return isNaN(num) ? 0 : num;\n    }\n\n    if (field === 'purchaseDate' || field === 'lastUpdated') {\n      const date = new Date(value);\n      return isNaN(date.getTime()) ? null : date;\n    }\n\n    return value;\n  }\n\n  /**\n   * Validate imported items\n   */\n  private static async validateItems(\n    items: Partial<InventoryItem>[]\n  ): Promise<ImportValidationResult> {\n    const validItems: InventoryItem[] = [];\n    const invalidItems: Array<{\n      item: Partial<InventoryItem>;\n      errors: string[];\n    }> = [];\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    for (const item of items) {\n      const itemErrors: string[] = [];\n\n      // Basic validation\n      if (!item.item?.trim()) {\n        itemErrors.push('Item name is required');\n      }\n\n      if (!item.category?.trim()) {\n        itemErrors.push('Category is required');\n      }\n\n      if (!item.location?.trim()) {\n        itemErrors.push('Location is required');\n      }\n\n      if (\n        item.quantity !== undefined &&\n        (isNaN(Number(item.quantity)) || Number(item.quantity) < 0)\n      ) {\n        itemErrors.push('Quantity must be a positive number');\n      }\n\n      if (\n        item.unit_cost !== undefined &&\n        (isNaN(Number(item.unit_cost)) || Number(item.unit_cost) < 0)\n      ) {\n        itemErrors.push('Cost must be a positive number');\n      }\n\n      if (itemErrors.length > 0) {\n        invalidItems.push({ item, errors: itemErrors });\n      } else {\n        // Add default values for required fields\n        const validItem: InventoryItem = {\n          id: item.id || this.generateId(),\n          name: item.item!,\n          item: item.item!,\n          category: item.category!,\n          location: item.location!,\n          status: item.status || 'active',\n          quantity: item.quantity || 1,\n          unit_cost: item.unit_cost || 0,\n          facility_id: '',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n          reorder_point: 0,\n          expiration_date: null,\n          data: {\n            vendor: item.vendor || '',\n            purchaseDate:\n              (item.data?.purchaseDate as string) || new Date().toISOString(),\n            warranty: (item.data?.warranty as string) || '',\n            maintenanceSchedule: item.maintenanceSchedule || '',\n            lastServiced: (item.data?.lastServiced as string) || undefined,\n            nextDue: item.nextDue || undefined,\n            serviceProvider: (item.data?.serviceProvider as string) || '',\n            assignedTo: (item.data?.assignedTo as string) || '',\n            notes: (item.data?.notes as string) || '',\n          },\n        };\n\n        validItems.push(validItem);\n      }\n    }\n\n    return {\n      isValid: invalidItems.length === 0,\n      errors,\n      warnings,\n      validItems,\n      invalidItems,\n    };\n  }\n\n  /**\n   * Process the import\n   */\n  private static async processImport(\n    items: InventoryItem[],\n    options: ImportOptions\n  ): Promise<{\n    success: boolean;\n    importedCount: number;\n    skippedCount: number;\n    errors: string[];\n  }> {\n    const errors: string[] = [];\n    let importedCount = 0;\n    let skippedCount = 0;\n\n    for (const item of items) {\n      try {\n        // Check for duplicates if duplicate handling is specified\n        if (\n          options.duplicateHandling &&\n          options.duplicateHandling !== 'create'\n        ) {\n          const existingItem = await this.checkForDuplicate(item);\n\n          if (existingItem) {\n            if (options.duplicateHandling === 'skip') {\n              skippedCount++;\n              continue;\n            } else if (options.duplicateHandling === 'update') {\n              // Update existing item\n              await InventoryServiceFacade.updateItem(existingItem.id, {\n                item: item.item,\n                category: item.category,\n                location: item.location,\n                status: item.status,\n                quantity: item.quantity,\n                unit_cost: item.unit_cost,\n                vendor: item.vendor,\n                purchaseDate: item.data?.purchaseDate as string,\n                warranty: item.data?.warranty as string,\n                maintenanceSchedule: item.maintenanceSchedule,\n                lastServiced: item.data?.lastServiced as string,\n                nextDue: item.data?.nextDue as string,\n                serviceProvider: item.data?.serviceProvider as string,\n                assignedTo: item.data?.assignedTo as string,\n                notes: item.data?.notes as string,\n                lastUpdated: new Date().toISOString(),\n              });\n              importedCount++;\n              continue;\n            }\n          }\n        }\n\n        // Create new item\n        await InventoryServiceFacade.createItem({\n          name: item.item || '',\n          category: item.category,\n          location: item.location,\n          status: item.status,\n          quantity: item.quantity,\n          unit_cost: item.unit_cost,\n          facility_id: '',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n          reorder_point: 0,\n          expiration_date: null,\n          data: {\n            vendor: item.vendor,\n            purchaseDate: item.data?.purchaseDate,\n            warranty: item.data?.warranty,\n            maintenanceSchedule: item.maintenanceSchedule,\n            lastServiced: item.data?.lastServiced,\n            nextDue: item.data?.nextDue,\n            serviceProvider: item.data?.serviceProvider,\n            assignedTo: item.data?.assignedTo,\n            notes: item.data?.notes,\n          },\n        });\n\n        importedCount++;\n      } catch (error) {\n        errors.push(\n          `Failed to import ${item.item}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      importedCount,\n      skippedCount,\n      errors,\n    };\n  }\n\n  /**\n   * Check for duplicate items based on item name and category\n   */\n  private static async checkForDuplicate(\n    item: InventoryItem\n  ): Promise<InventoryItem | null> {\n    try {\n      // Get all items to check for duplicates\n      const allItems = await InventoryServiceFacade.getAllItems();\n\n      // Find items with same name and category\n      const duplicate = allItems.find(\n        (existingItem) =>\n          existingItem.item?.toLowerCase() === item.item?.toLowerCase() &&\n          existingItem.category?.toLowerCase() === item.category?.toLowerCase()\n      );\n\n      return duplicate || null;\n    } catch (error) {\n      console.error('Error checking for duplicates:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Generate a unique ID\n   */\n  private static generateId(): string {\n    return `import-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Validate import options\n   */\n  static validateImportOptions(options: ImportOptions): {\n    isValid: boolean;\n    errors: string[];\n  } {\n    const errors: string[] = [];\n\n    if (!options.format || !['csv', 'json'].includes(options.format)) {\n      errors.push('Invalid import format. Must be csv or json.');\n    }\n\n    if (\n      options.duplicateHandling &&\n      !['skip', 'update', 'create'].includes(options.duplicateHandling)\n    ) {\n      errors.push(\n        'Invalid duplicate handling option. Must be skip, update, or create.'\n      );\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryModalsHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryModalsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryScheduledExportService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryTableHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\inventoryTableService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\scanInventoryModalHandlers.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ')' expected.",
        "line": 41,
        "column": 5,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ParsedItem } from '../types/scanInventoryModalTypes';\nimport { InventoryServiceFacade } from '@/services/inventory/InventoryServiceFacade';\nimport { InventoryItem } from '@/types/inventoryTypes';\n\nexport interface ScanMode {\n  mode: 'add' | 'use' | null;\n}\n\n// Process CSV file and extract inventory items\nexport const processCsvFile = async (file: File): Promise<ParsedItem[]> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (event) => {\n      try {\n        const csvContent = event.target?.result as string;\n        const lines = csvContent.split('\\n');\n\n        const items: ParsedItem[] = lines\n          .slice(1)\n          .filter((line) => line.trim())\n          .map((line, index) => {\n            const values = line.split(',').map((v) => v.trim());\n            const item: ParsedItem = {\n              id: values[0] || `item-${index + 1}`,\n              item: values[1] || '',\n              name: values[1] || '',\n              barcode: values[2] || undefined,\n              category: values[3] || '',\n              location: values[4] || '',\n              quantity: parseInt(values[5]) || 1,\n              cost: parseFloat(values[6]) || 0,\n            };\n            return item;\n          });\n\n        resolve(items);\n      } catch (err) { console.error(err); throw err; }\n        reject(new Error('Failed to parse CSV file'));\n      }\n    };\n\n    reader.onerror = () => reject(new Error('Failed to read file'));\n    reader.readAsText(file);\n  });\n};\n\n// Validate CSV data structure\nexport const validateCsvData = (data: unknown): boolean => {\n  if (!Array.isArray(data)) return false;\n\n  return data.every((item) => {\n    return (\n      typeof item === 'object' &&\n      item !== null &&\n      typeof item.id === 'string' &&\n      typeof item.name === 'string' &&\n      item.name.trim().length > 0\n    );\n  });\n};\n\n// Upload scanned items to inventory system\nexport const uploadScannedItems = async (\n  items: ParsedItem[]\n): Promise<void> => {\n  try {\n    // Validate items before upload\n    if (!validateCsvData(items)) {\n      throw new Error('Invalid item data');\n    }\n\n    // Convert ParsedItem to InventoryItem format\n    const inventoryItems: Omit<InventoryItem, 'id' | 'lastUpdated'>[] =\n      items.map((item) => ({\n        name: item.name || item.item,\n        category: item.category || 'Unknown',\n        location: item.location || 'Default',\n        quantity: item.quantity,\n        facility_id: '',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        reorder_point: 0,\n        supplier: '',\n        cost: 0,\n        expiration_date: null,\n        unit_cost: 0,\n        data: {\n          barcode:\n            (item as { data?: { barcode?: string } }).data?.barcode || item.id,\n          status: 'active',\n          cost: 0,\n          vendor: '',\n          purchaseDate: new Date().toISOString(),\n          warranty: '',\n          description: `Imported from scan - ${item.name || item.item}`,\n          tags: [],\n          notes: '',\n          lastMaintenance: null,\n          nextMaintenance: null,\n          assignedTo: null,\n          department: '',\n          condition: 'good',\n          priority: 'medium',\n          supplier: '',\n          reorderPoint: 0,\n          maxQuantity: item.quantity * 2,\n          unit: 'piece',\n          isTracked: false,\n          isFavorite: false,\n          isArchived: false,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n      }));\n\n    // Upload items using InventoryServiceFacade\n    const uploadPromises = inventoryItems.map((item) =>\n      InventoryServiceFacade.createItem(item)\n    );\n\n    const results = await Promise.allSettled(uploadPromises);\n    const successfulUploads = results.filter(\n      (result) => result.status === 'fulfilled'\n    ).length;\n    const failedUploads = results.filter(\n      (result) => result.status === 'rejected'\n    ).length;\n\n    console.log(\n      `Upload completed: ${successfulUploads} successful, ${failedUploads} failed`\n    );\n\n    if (failedUploads > 0) {\n      console.warn(\n        'Some uploads failed:',\n        results.filter((result) => result.status === 'rejected')\n      );\n    }\n  } catch (error) {\n    console.error('Error uploading scanned items:', error);\n    throw error;\n  }\n};\n\n// Parse barcode data into structured format\nexport const parseBarcodeData = (barcodeString: string): ParsedItem => {\n  const parts = barcodeString.split('-');\n\n  return {\n    id: parts[0] || barcodeString,\n    item: parts.slice(1).join('-') || barcodeString,\n    name: parts.slice(1).join('-') || barcodeString,\n    barcode: barcodeString,\n    category: 'Unknown',\n    location: 'Default',\n    quantity: 1,\n    cost: 0,\n  };\n};\n\n// Validate scanned item format\nexport const validateScannedItem = (item: string): boolean => {\n  return item.trim().length > 0 && item.includes('-');\n};\n\n// Process scanned items into structured format\nexport const processScannedItems = (items: string[]): ParsedItem[] => {\n  return items.map(parseBarcodeData);\n};\n\n// Get display text for scan mode\nexport const getScanModeDisplayText = (mode: ScanMode['mode']): string => {\n  switch (mode) {\n    case 'add':\n      return 'Add Items';\n    case 'use':\n      return 'Use Items';\n    default:\n      return 'Select Mode';\n  }\n};\n\n// Type guard for scan mode validation\nexport const isValidScanMode = (mode: unknown): mode is ScanMode['mode'] => {\n  return mode === 'add' || mode === 'use' || mode === null;\n};\n\n// Generate unique item ID\nexport const generateItemId = (prefix: string = 'INV'): string => {\n  const timestamp = Date.now();\n  const random = Math.floor(Math.random() * 1000);\n  return `${prefix}-${timestamp}-${random}`;\n};\n\n// Format scanned items count for display\nexport const formatScannedItemsCount = (count: number): string => {\n  if (count === 0) return 'No items scanned';\n  if (count === 1) return '1 item scanned';\n  return `${count} items scanned`;\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\services\\scanInventoryModalService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\types\\inventoryDashboardTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\types\\inventorySearchTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Inventory\\types\\scanInventoryModalTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\__mocks__\\BaseErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\__mocks__\\knowledgeHubApiService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\CategoriesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ContentManagementPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ContentTable.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'deleteContent' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 38,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 18,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\CourseCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\CourseFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\CoursesTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\DepartmentRoleFilter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\EmptyState.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorBoundaries\\BaseErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorBoundaries\\ComponentErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorBoundaries\\KnowledgeHubErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorBoundaries\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorDisplay\\ErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\ErrorDisplay\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\KnowledgeHubContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\KnowledgeHubErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\QuizComponent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\QuizCreationForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\QuizList.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'quiz' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 222,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 222,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport { ContentItem } from '../types';\nimport QuizComponent from './QuizComponent';\nimport { QuizCreationForm } from './QuizCreationForm';\n\ninterface QuizListProps {\n  quizzes: ContentItem[];\n  onQuizStart?: (quizId: string) => void;\n  onQuizComplete?: (quizId: string, score: number, passed: boolean) => void;\n}\n\nexport const QuizList: React.FC<QuizListProps> = ({\n  quizzes,\n  onQuizStart,\n  onQuizComplete,\n}) => {\n  const [selectedQuizId, setSelectedQuizId] = useState<string | null>(null);\n  const [showQuiz, setShowQuiz] = useState(false);\n  const [showCreateForm, setShowCreateForm] = useState(false);\n\n  const handleStartQuiz = (quizId: string) => {\n    setSelectedQuizId(quizId);\n    setShowQuiz(true);\n    onQuizStart?.(quizId);\n  };\n\n  const handleQuizComplete = (score: number, passed: boolean) => {\n    if (selectedQuizId) {\n      onQuizComplete?.(selectedQuizId, score, passed);\n    }\n    setShowQuiz(false);\n    setSelectedQuizId(null);\n  };\n\n  const handleCloseQuiz = () => {\n    setShowQuiz(false);\n    setSelectedQuizId(null);\n  };\n\n  const getDifficultyColor = (difficulty: string) => {\n    switch (difficulty.toLowerCase()) {\n      case 'easy':\n        return 'bg-green-100 text-green-800';\n      case 'medium':\n        return 'bg-yellow-100 text-yellow-800';\n      case 'hard':\n        return 'bg-red-100 text-red-800';\n      default:\n        return 'bg-gray-100 text-gray-800';\n    }\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'published':\n        return 'bg-green-100 text-green-800';\n      case 'draft':\n        return 'bg-gray-100 text-gray-800';\n      case 'review':\n        return 'bg-blue-100 text-blue-800';\n      case 'archived':\n        return 'bg-red-100 text-red-800';\n      default:\n        return 'bg-gray-100 text-gray-800';\n    }\n  };\n\n  if (quizzes.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 text-lg mb-2\">No quizzes available</div>\n        <div className=\"text-gray-400 text-sm\">\n          Check back later for new knowledge assessments\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Quiz Header */}\n      <div className=\"flex items-center justify-between mb-6\">\n        <div>\n          <h3 className=\"text-lg font-semibold text-gray-900\">\n            Knowledge Quizzes\n          </h3>\n          <p className=\"text-sm text-gray-600\">\n            Test your knowledge with interactive assessments\n          </p>\n        </div>\n        <button\n          onClick={() => setShowCreateForm(true)}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors\"\n        >\n          Create Quiz\n        </button>\n      </div>\n\n      {/* Quiz List */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        {quizzes.map((quiz) => (\n          <div\n            key={quiz.id}\n            className=\"bg-white rounded-lg shadow-md border border-gray-200 hover:shadow-lg transition-shadow\"\n          >\n            {/* Quiz Header */}\n            <div className=\"p-6\">\n              <div className=\"flex items-start justify-between mb-3\">\n                <h3 className=\"text-lg font-semibold text-gray-900 line-clamp-2\">\n                  {quiz.title}\n                </h3>\n                <div className=\"flex flex-col items-end space-y-2\">\n                  <span\n                    className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(quiz.status)}`}\n                  >\n                    {quiz.status}\n                  </span>\n                  <span\n                    className={`px-2 py-1 rounded-full text-xs font-medium ${getDifficultyColor(quiz.difficultyLevel || 'medium')}`}\n                  >\n                    {quiz.difficultyLevel || 'Medium'}\n                  </span>\n                </div>\n              </div>\n\n              {/* Quiz Description */}\n              <p className=\"text-gray-600 text-sm mb-4 line-clamp-3\">\n                {quiz.description ||\n                  'Test your knowledge with this interactive quiz'}\n              </p>\n\n              {/* Quiz Metadata */}\n              <div className=\"space-y-2 mb-4\">\n                <div className=\"flex items-center justify-between text-xs text-gray-500\">\n                  <span>Duration:</span>\n                  <span>{quiz.estimatedDuration || 15} min</span>\n                </div>\n                <div className=\"flex items-center justify-between text-xs text-gray-500\">\n                  <span>Category:</span>\n                  <span>{quiz.category}</span>\n                </div>\n                {quiz.passingScore && (\n                  <div className=\"flex items-center justify-between text-xs text-gray-500\">\n                    <span>Passing Score:</span>\n                    <span>{quiz.passingScore}%</span>\n                  </div>\n                )}\n                <div className=\"flex items-center justify-between text-xs text-gray-500\">\n                  <span>Last Updated:</span>\n                  <span>\n                    {quiz.lastUpdated\n                      ? new Date(quiz.lastUpdated).toLocaleDateString()\n                      : 'N/A'}\n                  </span>\n                </div>\n              </div>\n\n              {/* Quiz Actions */}\n              <div className=\"flex space-x-2\">\n                <button\n                  onClick={() => handleStartQuiz(quiz.id)}\n                  className=\"flex-1 px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors\"\n                >\n                  Start Quiz\n                </button>\n                <button className=\"px-3 py-2 text-gray-600 hover:text-gray-800 transition-colors\">\n                  <svg\n                    className=\"w-5 h-5\"\n                    fill=\"none\"\n                    stroke=\"currentColor\"\n                    viewBox=\"0 0 24 24\"\n                  >\n                    <path\n                      strokeLinecap=\"round\"\n                      strokeLinejoin=\"round\"\n                      strokeWidth={2}\n                      d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                    />\n                  </svg>\n                </button>\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n\n      {/* Quiz Modal */}\n      {showQuiz && selectedQuizId && (\n        <div className=\"fixed inset-0 z-50 overflow-y-auto\">\n          <div className=\"flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0\">\n            <div\n              className=\"fixed inset-0 transition-opacity\"\n              aria-hidden=\"true\"\n            >\n              <div className=\"absolute inset-0 bg-gray-500 opacity-75\"></div>\n            </div>\n\n            <div className=\"inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-4xl sm:w-full\">\n              <QuizComponent\n                quizId={selectedQuizId}\n                onComplete={handleQuizComplete}\n                onClose={handleCloseQuiz}\n              />\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Quiz Creation Form Modal */}\n      {showCreateForm && (\n        <div className=\"fixed inset-0 z-50 overflow-y-auto\">\n          <div className=\"flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0\">\n            <div\n              className=\"fixed inset-0 transition-opacity\"\n              aria-hidden=\"true\"\n            >\n              <div className=\"absolute inset-0 bg-gray-500 opacity-75\"></div>\n            </div>\n\n            <div className=\"inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-6xl sm:w-full\">\n              <QuizCreationForm\n                onQuizCreated={(quiz) => {\n                  setShowCreateForm(false);\n                  // TODO: Refresh quiz list // TRACK: Migrate to GitHub issue\n                }}\n                onCancel={() => setShowCreateForm(false)}\n              />\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\RecentUpdatesPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\UnifiedSearchFilterBar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\UserProgressPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\api-docs\\AuthenticationGuide.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\api-docs\\CodeExamples.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\api-docs\\ErrorHandlingGuide.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\table-components\\CategoryIcon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\table-components\\ErrorState.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\table-components\\TableContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\table-components\\TableHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\table-components\\TableLoadingFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\BaseVirtualizedTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\CourseRow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\CoursesTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\LearningPathwaysTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\PoliciesTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\ProceduresTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\ResizableColumn.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\SimpleTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\TableHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\TablePagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\TableRow.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ')' expected.",
        "line": 155,
        "column": 16,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiDelete,\n  mdiChevronDown,\n  mdiChevronRight,\n  mdiPlay,\n  mdiPause,\n  mdiStop,\n  mdiCalendar,\n} from '@mdi/js';\nimport { ContentItem } from '../../types';\nimport { ProgressDisplay, DateDisplay, ActionButton } from './types';\n\ninterface TableRowProps {\n  item: ContentItem;\n  isExpanded: boolean;\n  onToggleExpansion: (id: string) => void;\n  onDelete: (id: string) => void;\n  onStartContent?: (id: string) => void;\n  progressDisplay: ProgressDisplay;\n  startDateDisplay: DateDisplay;\n  dueDateDisplay: DateDisplay;\n  actionButton: ActionButton;\n  columnWidths: {\n    content: number;\n    progress: number;\n    startDate: number;\n    assigned: number;\n    actions: number;\n  };\n}\n\n/**\n * Table Row Component\n *\n * Handles individual row rendering and interactions including:\n * - Row expansion/collapse\n * - Progress display\n * - Date formatting\n * - Action buttons\n */\nexport const TableRow: React.FC<TableRowProps> = ({\n  item,\n  isExpanded,\n  onToggleExpansion,\n  onDelete,\n  onStartContent,\n  progressDisplay,\n  dueDateDisplay,\n  actionButton,\n  columnWidths,\n}) => {\n  // Safety check for required props\n  if (!item) {\n    console.warn('TableRow: item prop is undefined or null');\n    return null;\n  }\n\n  const handleToggleExpansion = () => {\n    if (item?.id) {\n      onToggleExpansion(item.id);\n    }\n  };\n\n  const handleDelete = () => {\n    if (item?.id) {\n      onDelete(item.id);\n    }\n  };\n\n  const handleStartContent = () => {\n    if (onStartContent && item?.id) {\n      onStartContent(item.id);\n    }\n  };\n\n  try {\n    return (\n      <>\n        {/* Main row */}\n        <tr className=\"border-b border-gray-200 hover:bg-gray-50\">\n          {/* Content column */}\n          <td\n            className=\"px-4 py-3\"\n            style={{ width: columnWidths?.content || 'auto' }}\n          >\n            <div className=\"flex items-center gap-2\">\n              <button\n                onClick={handleToggleExpansion}\n                className=\"p-1 hover:bg-gray-200 rounded\"\n              >\n                <Icon\n                  path={isExpanded ? mdiChevronDown : mdiChevronRight}\n                  size={0.8}\n                  className=\"text-gray-500\"\n                />\n              </button>\n              <div className=\"flex-1 min-w-0\">\n                <div className=\"font-medium text-gray-900 leading-tight\">\n                  {item?.title && item.title.length > 40 ? (\n                    <>\n                      <div>{item.title.substring(0, 40)}</div>\n                      <div className=\"text-sm text-gray-600\">\n                        {item.title.substring(40)}\n                      </div>\n                    </>\n                  ) : (\n                    item?.title || 'Untitled'\n                  )}\n                </div>\n              </div>\n            </div>\n          </td>\n\n          {/* Progress column */}\n          <td\n            className=\"px-4 py-3\"\n            style={{ width: columnWidths?.progress || 'auto' }}\n          >\n            <div className=\"flex items-center gap-2\">\n              <div className=\"flex-1\">\n                <div className=\"w-full bg-gray-200 rounded-full h-2\">\n                  <div\n                    className={`h-2 rounded-full ${\n                      (progressDisplay?.percentage || 0) === 0\n                        ? 'bg-gray-400'\n                        : (progressDisplay?.percentage || 0) === 100\n                          ? 'bg-[#10B981]'\n                          : 'bg-[#4ECDC4]'\n                    }`}\n                    style={{ width: `${progressDisplay?.percentage || 0}%` }}\n                  />\n                </div>\n              </div>\n              <span className=\"text-sm text-gray-600 min-w-[3rem]\">\n                {progressDisplay?.text || '0%'}\n              </span>\n            </div>\n          </td>\n\n          {/* Start Date column */}\n          <td\n            className=\"px-4 py-3\"\n            style={{ width: columnWidths?.startDate || 'auto' }}\n          >\n            {(progressDisplay?.percentage || 0) > 0 && item?.lastUpdated ? (\n              <span className=\"text-sm text-gray-700\">\n                {(() => {\n                  try {\n                    return new Date(item.lastUpdated).toLocaleDateString();\n                  } catch (err) { console.error(err); throw err; }\n                    return 'Invalid date';\n                  }\n                })()}\n              </span>\n            ) : (\n              <span className=\"text-sm text-gray-400\">-</span>\n            )}\n          </td>\n\n          {/* Assigned column */}\n          <td\n            className=\"px-4 py-3\"\n            style={{ width: columnWidths?.assigned || 'auto' }}\n          >\n            <div className=\"flex items-center justify-center\">\n              <span\n                className={`text-lg font-medium ${\n                  (progressDisplay?.percentage || 0) > 0\n                    ? 'text-[#10B981]'\n                    : 'text-gray-400'\n                }`}\n              >\n                {(progressDisplay?.percentage || 0) > 0 ? '‚úì' : '‚úó'}\n              </span>\n            </div>\n          </td>\n\n          {/* Actions column */}\n          <td\n            className=\"px-4 py-3\"\n            style={{ width: columnWidths?.actions || 'auto' }}\n          >\n            <div className=\"flex items-center gap-1\">\n              {/* Start/Resume/Stop button */}\n              <button\n                onClick={handleStartContent}\n                disabled={actionButton?.disabled || false}\n                className={`w-8 h-8 rounded flex items-center justify-center transition-colors ${\n                  actionButton?.variant === 'primary'\n                    ? 'bg-[#4ECDC4] text-white hover:bg-[#3DB8B0] disabled:bg-gray-300'\n                    : actionButton?.variant === 'secondary'\n                      ? 'bg-[#5B5B5B] text-white hover:bg-[#4A4A4A] disabled:bg-gray-300'\n                      : 'bg-[#EF4444] text-white hover:bg-[#DC2626] disabled:bg-gray-300'\n                } disabled:cursor-not-allowed`}\n                title={\n                  (progressDisplay?.percentage || 0) === 100\n                    ? 'View'\n                    : (progressDisplay?.percentage || 0) > 0\n                      ? 'Resume'\n                      : 'Start'\n                }\n              >\n                <Icon\n                  path={\n                    (progressDisplay?.percentage || 0) === 100\n                      ? mdiStop\n                      : (progressDisplay?.percentage || 0) > 0\n                        ? mdiPause\n                        : mdiPlay\n                  }\n                  size={0.8}\n                />\n              </button>\n\n              {/* Delete button */}\n              <button\n                onClick={handleDelete}\n                className=\"w-8 h-8 text-[#EF4444] hover:bg-red-50 rounded flex items-center justify-center transition-colors\"\n                title=\"Delete\"\n              >\n                <Icon path={mdiDelete} size={0.8} />\n              </button>\n            </div>\n          </td>\n        </tr>\n\n        {/* Expanded content */}\n        {isExpanded && (\n          <tr className=\"bg-gray-50\">\n            <td colSpan={5} className=\"px-4 py-3\">\n              <div className=\"space-y-3\">\n                {/* Description */}\n                {item?.description && (\n                  <div>\n                    <h4 className=\"font-medium text-gray-900 mb-1\">\n                      Description\n                    </h4>\n                    <p className=\"text-sm text-gray-600\">\n                      {item.data?.description}\n                    </p>\n                  </div>\n                )}\n\n                {/* Additional details */}\n                <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                  {/* Category */}\n                  <div>\n                    <h4 className=\"font-medium text-gray-900 mb-1\">Category</h4>\n                    <p className=\"text-sm text-gray-600\">\n                      {item?.category || 'No category'}\n                    </p>\n                  </div>\n\n                  {/* Due Date */}\n                  <div>\n                    <h4 className=\"font-medium text-gray-900 mb-1\">Due Date</h4>\n                    <div className=\"flex items-center gap-1\">\n                      <Icon\n                        path={mdiCalendar}\n                        size={0.6}\n                        className=\"text-gray-400\"\n                      />\n                      <span\n                        className={`text-sm ${dueDateDisplay?.color || 'text-gray-600'}`}\n                      >\n                        {dueDateDisplay?.text || 'No due date'}\n                      </span>\n                    </div>\n                  </div>\n\n                  {/* Tags */}\n                  {item?.data?.tags && item.data.tags.length > 0 && (\n                    <div>\n                      <h4 className=\"font-medium text-gray-900 mb-1\">Tags</h4>\n                      <div className=\"flex flex-wrap gap-1\">\n                        {item.data.tags.map((tag, index) => (\n                          <span\n                            key={index}\n                            className=\"px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded\"\n                          >\n                            {tag}\n                          </span>\n                        ))}\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n            </td>\n          </tr>\n        )}\n      </>\n    );\n  } catch (error) {\n    console.error('Error rendering TableRow:', error);\n    // Return a fallback row that won't crash\n    return (\n      <tr className=\"border-b border-gray-200\">\n        <td colSpan={5} className=\"px-4 py-3 text-center text-red-600\">\n          Error loading row data. Please refresh the page.{' '}\n          {error instanceof Error ? error.message : 'Unknown error'}\n        </td>\n      </tr>\n    );\n  }\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\TableUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\VirtualizedRow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\components\\tables\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\config\\courseConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\config\\knowledgeHubConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useAILearning.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useColumnResizing.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useContentFiltering.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useCourseTableLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useCourses.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useKnowledgeHubContent.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useKnowledgeHubOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\usePolicies.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useProcedureState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useSearchValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useTableData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useTableFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useTableSorting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useUIRenderState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\hooks\\useUserDataIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\models.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\providers\\SimplifiedKnowledgeHubProvider.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'selectedCategory'. Either include it or remove the dependency array.",
        "line": 178,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 178,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [selectedCategory]",
            "fix": { "range": [6060, 6062], "text": "[selectedCategory]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\providers\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\__tests__\\contentActions.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\__tests__\\serviceHierarchy.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\__tests__\\unifiedAdapter.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\actions\\contentActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\adapters\\unifiedDatabaseAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\aiLearningService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\contentFilterService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\courseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\courseTableService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\data\\knowledgeDataService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'testInsert' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 515,
        "column": 23,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 515,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabase';\nimport {\n  KnowledgeArticle,\n  KnowledgeCategory,\n  KnowledgeLearningPath,\n  RecentUpdate,\n  KnowledgeUserProgress,\n  KnowledgeArticleView,\n  KnowledgeQuizAttempt,\n  KnowledgeArticleRating,\n  KnowledgeBookmark,\n  BulkUpdateResult,\n  BulkDeleteResult,\n  ContentStatus,\n  LearningPathStatus,\n} from '../types/knowledgeHubTypes';\nimport { KnowledgeHubBulkService } from '../knowledgeHubBulkService';\n\nexport class KnowledgeDataService {\n  /**\n   * Fetch all knowledge articles from Supabase\n   * @deprecated Use KnowledgeHubService.getKnowledgeArticles() instead\n   */\n  static async getKnowledgeArticles(): Promise<KnowledgeArticle[]> {\n    console.warn(\n      'KnowledgeDataService.getKnowledgeArticles() is deprecated. Use KnowledgeHubService.getKnowledgeArticles() instead.'\n    );\n    try {\n      const { data, error } = await supabase\n        .from('knowledge_articles')\n        .select('*')\n        .eq('status', 'published')\n        .order('published_at', { ascending: false });\n\n      if (error) {\n        console.error('Error fetching knowledge articles:', error);\n        throw new Error(`Failed to fetch knowledge articles: ${error.message}`);\n      }\n\n      return (data as unknown as KnowledgeArticle[]) || [];\n    } catch (error) {\n      console.error('KnowledgeDataService.getKnowledgeArticles error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch all knowledge categories from Supabase\n   */\n  static async getKnowledgeCategories(): Promise<KnowledgeCategory[]> {\n    try {\n      const { data, error } = await supabase\n        .from('knowledge_categories')\n        .select('*')\n        .eq('is_active', true)\n        .order('sort_order', { ascending: true });\n\n      if (error) {\n        console.error('Error fetching knowledge categories:', error);\n        throw new Error(\n          `Failed to fetch knowledge categories: ${error.message}`\n        );\n      }\n\n      return (data as unknown as KnowledgeCategory[]) || [];\n    } catch (error) {\n      console.error(\n        'KnowledgeDataService.getKnowledgeCategories error:',\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch all learning paths from Supabase\n   */\n  static async getLearningPathways(): Promise<KnowledgeLearningPath[]> {\n    try {\n      const { data, error } = await supabase\n        .from('knowledge_learning_paths')\n        .select('*')\n        .eq('is_active', true)\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        console.error('Error fetching learning pathways:', error);\n        throw new Error(`Failed to fetch learning pathways: ${error.message}`);\n      }\n\n      return (data as unknown as KnowledgeLearningPath[]) || [];\n    } catch (error) {\n      console.error('KnowledgeDataService.getLearningPathways error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Bulk update knowledge articles status using .in() operator\n   */\n  static async bulkUpdateArticlesStatus(\n    articleIds: string[],\n    status: ContentStatus\n  ): Promise<BulkUpdateResult> {\n    try {\n      if (!articleIds || articleIds.length === 0) {\n        return {\n          success: false,\n          updatedCount: 0,\n          processedCount: 0,\n          errors: ['No article IDs provided'],\n        };\n      }\n\n      const { error, count } = await supabase\n        .from('knowledge_articles')\n        .update({\n          status,\n          updated_at: new Date().toISOString(),\n        })\n        .in('id', articleIds)\n        .select('id');\n\n      if (error) {\n        console.error('Error bulk updating articles status:', error);\n        return {\n          success: false,\n          updatedCount: 0,\n          processedCount: articleIds.length,\n          errors: [error.message],\n        };\n      }\n\n      return {\n        success: true,\n        updatedCount: count || 0,\n        processedCount: articleIds.length,\n        errors: [],\n      };\n    } catch (error) {\n      console.error(\n        'KnowledgeDataService.bulkUpdateArticlesStatus error:',\n        error\n      );\n      return {\n        success: false,\n        updatedCount: 0,\n        processedCount: articleIds.length,\n        errors: [error instanceof Error ? error.message : 'Unknown error'],\n      };\n    }\n  }\n\n  /**\n   * Bulk update learning paths status using .in() operator\n   */\n  static async bulkUpdateLearningPathsStatus(\n    pathwayIds: string[],\n    status: LearningPathStatus\n  ): Promise<BulkUpdateResult> {\n    try {\n      if (!pathwayIds || pathwayIds.length === 0) {\n        return {\n          success: false,\n          updatedCount: 0,\n          processedCount: 0,\n          errors: ['No pathway IDs provided'],\n        };\n      }\n\n      const isActive = status === 'active';\n      const { error, count } = await supabase\n        .from('knowledge_learning_paths')\n        .update({\n          is_active: isActive,\n          updated_at: new Date().toISOString(),\n        })\n        .in('id', pathwayIds)\n        .select('id');\n\n      if (error) {\n        console.error('Error bulk updating learning paths status:', error);\n        return {\n          success: false,\n          updatedCount: 0,\n          processedCount: pathwayIds.length,\n          errors: [error.message],\n        };\n      }\n\n      return {\n        success: true,\n        updatedCount: count || 0,\n        processedCount: pathwayIds.length,\n        errors: [],\n      };\n    } catch (error) {\n      console.error(\n        'KnowledgeDataService.bulkUpdateLearningPathsStatus error:',\n        error\n      );\n      return {\n        success: false,\n        updatedCount: 0,\n        processedCount: pathwayIds.length,\n        errors: [error instanceof Error ? error.message : 'Unknown error'],\n      };\n    }\n  }\n\n  /**\n   * Bulk delete knowledge articles (soft delete) using .in() operator\n   */\n  static async bulkDeleteArticles(\n    articleIds: string[]\n  ): Promise<BulkDeleteResult> {\n    try {\n      if (!articleIds || articleIds.length === 0) {\n        return {\n          success: false,\n          deletedCount: 0,\n          processedCount: 0,\n          errors: ['No article IDs provided'],\n        };\n      }\n\n      const { error, count } = await supabase\n        .from('knowledge_articles')\n        .update({\n          status: 'archived',\n          updated_at: new Date().toISOString(),\n        })\n        .in('id', articleIds)\n        .select('id');\n\n      if (error) {\n        console.error('Error bulk deleting articles:', error);\n        return {\n          success: false,\n          deletedCount: 0,\n          processedCount: articleIds.length,\n          errors: [error.message],\n        };\n      }\n\n      return {\n        success: true,\n        deletedCount: count || 0,\n        processedCount: articleIds.length,\n        errors: [],\n      };\n    } catch (error) {\n      console.error('KnowledgeDataService.bulkDeleteArticles error:', error);\n      return {\n        success: false,\n        deletedCount: 0,\n        processedCount: articleIds.length,\n        errors: [error instanceof Error ? error.message : 'Unknown error'],\n      };\n    }\n  }\n\n  /**\n   * Bulk delete learning paths (soft delete) using .in() operator\n   */\n  static async bulkDeleteLearningPaths(\n    pathwayIds: string[]\n  ): Promise<BulkDeleteResult> {\n    try {\n      if (!pathwayIds || pathwayIds.length === 0) {\n        return {\n          success: false,\n          deletedCount: 0,\n          processedCount: 0,\n          errors: ['No pathway IDs provided'],\n        };\n      }\n\n      const { error, count } = await supabase\n        .from('knowledge_learning_paths')\n        .update({\n          is_active: false,\n          updated_at: new Date().toISOString(),\n        })\n        .in('id', pathwayIds)\n        .select('id');\n\n      if (error) {\n        console.error('Error bulk deleting learning paths:', error);\n        return {\n          success: false,\n          deletedCount: 0,\n          processedCount: pathwayIds.length,\n          errors: [error.message],\n        };\n      }\n\n      return {\n        success: true,\n        deletedCount: count || 0,\n        processedCount: pathwayIds.length,\n        errors: [],\n      };\n    } catch (error) {\n      console.error(\n        'KnowledgeDataService.bulkDeleteLearningPaths error:',\n        error\n      );\n      return {\n        success: false,\n        deletedCount: 0,\n        processedCount: pathwayIds.length,\n        errors: [error instanceof Error ? error.message : 'Unknown error'],\n      };\n    }\n  }\n\n  /**\n   * Transaction-like bulk operation for mixed content types\n   */\n  static async bulkOperationWithTransaction(\n    operations: Array<{\n      type:\n        | 'update_article_status'\n        | 'update_pathway_status'\n        | 'delete_article'\n        | 'delete_pathway';\n      ids: string[];\n      data?: Record<string, unknown>;\n    }>\n  ): Promise<{\n    success: boolean;\n    results: Array<{\n      type: string;\n      success: boolean;\n      count: number;\n      error?: string;\n    }>;\n  }> {\n    try {\n      const results: Array<{\n        type: string;\n        success: boolean;\n        count: number;\n        error?: string;\n      }> = [];\n\n      // Use standardized bulk operation service\n      const bulkResult = await KnowledgeHubBulkService.transactionBulkOperation(\n        operations,\n        async (operation) => {\n          let result: {\n            success: boolean;\n            updatedCount?: number;\n            deletedCount?: number;\n            error?: string;\n          };\n\n          switch (operation.type) {\n            case 'update_article_status':\n              if (\n                operation.data &&\n                typeof operation.data === 'object' &&\n                'status' in operation.data\n              ) {\n                result = await this.bulkUpdateArticlesStatus(\n                  operation.ids,\n                  operation.data.status as ContentStatus\n                );\n              } else {\n                result = {\n                  success: false,\n                  error: 'Invalid operation data for status update',\n                };\n              }\n              break;\n\n            case 'update_pathway_status':\n              if (\n                operation.data &&\n                typeof operation.data === 'object' &&\n                'isActive' in operation.data\n              ) {\n                const isActive = operation.data.isActive as boolean;\n                const status: LearningPathStatus = isActive\n                  ? 'active'\n                  : 'inactive';\n                result = await this.bulkUpdateLearningPathsStatus(\n                  operation.ids,\n                  status\n                );\n              } else {\n                result = {\n                  success: false,\n                  error: 'Invalid operation data for pathway status update',\n                };\n              }\n              break;\n\n            case 'delete_article':\n              result = await this.bulkDeleteArticles(operation.ids);\n              break;\n\n            case 'delete_pathway':\n              result = await this.bulkDeleteLearningPaths(operation.ids);\n              break;\n\n            default:\n              result = {\n                success: false,\n                error: `Unknown operation type: ${operation.type}`,\n              };\n          }\n\n          return {\n            type: operation.type,\n            success: result.success,\n            count: result.updatedCount || result.deletedCount || 0,\n            error: result.error,\n          };\n        }\n      );\n\n      // Convert bulk result to expected format\n      results.push(...bulkResult.results);\n\n      // Add any failed operations to results\n      bulkResult.failed.forEach((operation, index) => {\n        results.push({\n          type: (() => {\n            if (\n              operation &&\n              typeof operation === 'object' &&\n              'type' in operation\n            ) {\n              const typeValue = operation.type;\n              if (typeof typeValue === 'string' && typeValue.trim() !== '') {\n                return typeValue;\n              }\n            }\n            return 'unknown';\n          })(),\n          success: false,\n          count: 0,\n          error: bulkResult.errors[index] || 'Operation failed',\n        });\n      });\n\n      const overallSuccess = results.every((r) => r.success);\n\n      return {\n        success: overallSuccess,\n        results,\n      };\n    } catch (error) {\n      console.error(\n        'KnowledgeDataService.bulkOperationWithTransaction error:',\n        error\n      );\n      return {\n        success: false,\n        results: [\n          {\n            type: 'transaction',\n            success: false,\n            count: 0,\n            error: error instanceof Error ? error.message : 'Unknown error',\n          },\n        ],\n      };\n    }\n  }\n\n  /**\n   * Fetch recent user activity for the recent updates panel\n   */\n  static async getRecentUserActivity(\n    userId: string,\n    limit: number = 10\n  ): Promise<RecentUpdate[]> {\n    try {\n      console.log(\n        'üîç KnowledgeDataService.getRecentUserActivity: Starting for user:',\n        userId\n      );\n      const recentUpdates: RecentUpdate[] = [];\n\n      // Get user progress updates\n      console.log('üìä Fetching user progress for user:', userId);\n      const { data: progressData, error: progressError } = await supabase\n        .from('knowledge_user_progress')\n        .select('*')\n        .eq('user_id', userId)\n        .order('updated_at', { ascending: false })\n        .limit(limit);\n\n      console.log('üìä Progress data:', { progressData, progressError });\n\n      // Debug: Check if any data exists in the table at all\n      const { data: allProgressData, error: allProgressError } = await supabase\n        .from('knowledge_user_progress')\n        .select('user_id, progress_status, created_at')\n        .limit(5);\n\n      console.log('üîç All progress data in table:', {\n        allProgressData,\n        allProgressError,\n      });\n\n      // If no data exists, let's try to insert some test data directly\n      if (allProgressData && allProgressData.length === 0) {\n        // Performance optimization: Removed excessive logging\n\n        // First, let's check if we can insert into the table at all\n        const { data: testInsert, error: testError } = await supabase\n          .from('knowledge_user_progress')\n          .insert({\n            id: crypto.randomUUID(),\n            user_id: userId,\n            article_id: '550e8400-e29b-41d4-a716-446655440010', // Use the course ID we created\n            learning_path_id: '550e8400-e29b-41d4-a716-446655440100',\n            step_id: '550e8400-e29b-41d4-a716-446655440200',\n            progress_status: 'completed',\n            completion_percentage: 100,\n            time_spent_minutes: 5,\n            started_at: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours ago\n            completed_at: new Date(\n              Date.now() - 1 * 60 * 60 * 1000\n            ).toISOString(), // 1 hour ago\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          })\n          .select();\n\n        // Performance optimization: Removed excessive logging\n        if (testError) {\n          console.error('üîß Insert error details:', testError);\n        }\n      }\n\n      if (progressError) {\n        console.error('Error fetching user progress:', progressError);\n      } else if (progressData) {\n        (progressData as unknown as KnowledgeUserProgress[]).forEach(\n          (progress) => {\n            const title = 'Unknown Content';\n            const type =\n              progress.status === 'completed' ? 'completed' : 'assigned';\n\n            recentUpdates.push({\n              id: progress.id,\n              type,\n              title,\n              timestamp: new Date().toISOString(),\n              time: new Date().toISOString(), // Use current time since updated_at is not available\n            });\n          }\n        );\n      }\n\n      // Get article views\n      const { data: viewsData, error: viewsError } = await supabase\n        .from('knowledge_article_views')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      if (viewsError) {\n        console.error('Error fetching article views:', viewsError);\n      } else if (viewsData) {\n        (viewsData as unknown as KnowledgeArticleView[]).forEach((view) => {\n          recentUpdates.push({\n            id: view.id,\n            type: 'viewed',\n            title: 'Unknown Article',\n            timestamp: view.created_at,\n            time: view.created_at,\n          });\n        });\n      }\n\n      // Get quiz attempts\n      const { data: quizData, error: quizError } = await supabase\n        .from('knowledge_quiz_attempts')\n        .select('*')\n        .eq('user_id', userId)\n        .order('completed_at', { ascending: false })\n        .limit(limit);\n\n      if (quizError) {\n        console.error('Error fetching quiz attempts:', quizError);\n      } else if (quizData) {\n        (quizData as unknown as KnowledgeQuizAttempt[]).forEach((quiz) => {\n          if (quiz.status === 'completed') {\n            recentUpdates.push({\n              id: quiz.id,\n              type: 'completed',\n              title: 'Unknown Quiz',\n              timestamp: quiz.completed_at || quiz.started_at || '',\n              time: quiz.completed_at || quiz.started_at || '',\n            });\n          }\n        });\n      }\n\n      // Get article ratings\n      const { data: ratingsData, error: ratingsError } = await supabase\n        .from('knowledge_article_ratings')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      if (ratingsError) {\n        console.error('Error fetching article ratings:', ratingsError);\n      } else if (ratingsData) {\n        (ratingsData as unknown as KnowledgeArticleRating[]).forEach(\n          (rating) => {\n            recentUpdates.push({\n              id: rating.id,\n              type: 'rated',\n              title: 'Unknown Article',\n              timestamp: rating.created_at,\n              time: rating.created_at,\n            });\n          }\n        );\n      }\n\n      // Get bookmarks\n      const { data: bookmarksData, error: bookmarksError } = await supabase\n        .from('knowledge_bookmarks')\n        .select('*')\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n        .limit(limit);\n\n      if (bookmarksError) {\n        console.error('Error fetching bookmarks:', bookmarksError);\n      } else if (bookmarksData) {\n        (bookmarksData as unknown as KnowledgeBookmark[]).forEach(\n          (bookmark) => {\n            recentUpdates.push({\n              id: bookmark.id,\n              type: 'bookmarked',\n              title: 'Unknown Article',\n              timestamp: bookmark.created_at,\n              time: bookmark.created_at,\n            });\n          }\n        );\n      }\n\n      // Sort all updates by time and return the most recent ones\n      const sortedUpdates = recentUpdates\n        .sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime())\n        .slice(0, limit);\n\n      console.log(\n        '‚úÖ KnowledgeDataService.getRecentUserActivity: Returning updates:',\n        sortedUpdates\n      );\n      return sortedUpdates;\n    } catch (error) {\n      console.error(\n        '‚ùå KnowledgeDataService.getRecentUserActivity error:',\n        error\n      );\n      return [];\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\duplicatePreventionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\implementations\\mockDatabase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\implementations\\supabaseDatabase.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\interfaces\\databaseInterface.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubApiService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected keyword or identifier.",
        "line": 556,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ContentItem, ContentStatus } from '../types';\nimport {\n  ApiError,\n  NetworkError,\n  ValidationError,\n  ContentNotFoundError,\n} from '../types/errors';\nimport { supabase } from '@/lib/supabase';\n\n// API response types\nexport interface PaginatedResponse<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    pageSize: number;\n    total: number;\n    totalPages: number;\n  };\n}\n\nexport interface KnowledgeHubFilters {\n  category?: string;\n  status?: ContentStatus;\n  search?: string;\n  department?: string;\n  sortBy?: 'title' | 'status' | 'dueDate' | 'progress' | 'lastUpdated';\n  sortDirection?: 'asc' | 'desc';\n}\n\nexport interface KnowledgeHubQueryParams extends KnowledgeHubFilters {\n  page?: number;\n  pageSize?: number;\n}\n\n// Use Supabase instead of external API\n// const useSupabase = true;\n\n// Rate limiting configuration\nconst RATE_LIMIT_CONFIG = {\n  // Maximum requests per window\n  MAX_REQUESTS_PER_WINDOW: 100,\n  // Time window in milliseconds (1 minute)\n  WINDOW_MS: 60 * 1000,\n  // Burst limit for immediate requests\n  BURST_LIMIT: 10,\n  // Retry delay for rate limited requests (in milliseconds)\n  RETRY_DELAY: 1000,\n  // Maximum retry attempts\n  MAX_RETRIES: 3,\n};\n\n// Rate limiter class\nclass RateLimiter {\n  private requests: number[] = [];\n  private burstRequests: number[] = [];\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n  private readonly burstLimit: number;\n  private readonly retryDelay: number;\n  private readonly maxRetries: number;\n\n  constructor(config: typeof RATE_LIMIT_CONFIG) {\n    this.maxRequests = config.MAX_REQUESTS_PER_WINDOW;\n    this.windowMs = config.WINDOW_MS;\n    this.burstLimit = config.BURST_LIMIT;\n    this.retryDelay = config.RETRY_DELAY;\n    this.maxRetries = config.MAX_RETRIES;\n  }\n\n  private cleanup(): void {\n    const now = Date.now();\n    this.requests = this.requests.filter((time) => now - time < this.windowMs);\n    this.burstRequests = this.burstRequests.filter((time) => now - time < 1000); // 1 second burst window\n  }\n\n  private canMakeRequest(): boolean {\n    this.cleanup();\n    return this.requests.length < this.maxRequests;\n  }\n\n  private canMakeBurstRequest(): boolean {\n    this.cleanup();\n    return this.burstRequests.length < this.burstLimit;\n  }\n\n  async acquireToken(): Promise<void> {\n    let retries = 0;\n\n    while (!this.canMakeRequest()) {\n      if (retries >= this.maxRetries) {\n        throw new Error('Rate limit exceeded. Please try again later.');\n      }\n\n      // Wait for the retry delay\n      await new Promise((resolve) => setTimeout(resolve, this.retryDelay));\n      retries++;\n    }\n\n    // Record the request\n    this.requests.push(Date.now());\n  }\n\n  async acquireBurstToken(): Promise<void> {\n    let retries = 0;\n\n    while (!this.canMakeBurstRequest()) {\n      if (retries >= this.maxRetries) {\n        throw new Error('Burst rate limit exceeded. Please try again later.');\n      }\n\n      // Wait for a shorter delay for burst requests\n      await new Promise((resolve) => setTimeout(resolve, this.retryDelay / 2));\n      retries++;\n    }\n\n    // Record the burst request\n    this.burstRequests.push(Date.now());\n  }\n\n  getStats(): {\n    currentRequests: number;\n    currentBurstRequests: number;\n    maxRequests: number;\n    maxBurstRequests: number;\n    windowMs: number;\n  } {\n    this.cleanup();\n    return {\n      currentRequests: this.requests.length,\n      currentBurstRequests: this.burstRequests.length,\n      maxRequests: this.maxRequests,\n      maxBurstRequests: this.burstLimit,\n      windowMs: this.windowMs,\n    };\n  }\n\n  reset(): void {\n    this.requests = [];\n    this.burstRequests = [];\n  }\n}\n\n// Request timeout utility\n// const createTimeoutPromise = (timeoutMs: number): Promise<never> => {\n//   return new Promise((_, reject) => {\n//     setTimeout(() => {\n//       reject(new NetworkError(`Request timeout after ${timeoutMs}ms`));\n//     }, timeoutMs);\n//   });\n// };\n\n// Supabase-based API request function\nconst apiRequest = async <T>(\n  endpoint: string,\n  rateLimiter?: RateLimiter,\n  useBurstLimit: boolean = false\n): Promise<T> => {\n  // Apply rate limiting if rate limiter is provided\n  if (rateLimiter) {\n    try {\n      if (useBurstLimit) {\n        await rateLimiter.acquireBurstToken();\n      } else {\n        await rateLimiter.acquireToken();\n      }\n    } catch (error) {\n      throw new NetworkError(\n        error instanceof Error ? error.message : 'Rate limit exceeded',\n        {\n          endpoint,\n          rateLimited: true,\n        }\n      );\n    }\n  }\n\n  try {\n    // Use Supabase instead of external API\n    const { data, error } = await supabase\n      .from('knowledge_articles')\n      .select('*');\n\n    if (error) {\n      throw new NetworkError(error.message, { endpoint, originalError: error });\n    }\n\n    return data as T;\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (error instanceof Error) {\n      throw new NetworkError(error.message, { endpoint, originalError: error });\n    }\n\n    throw new NetworkError('Unknown error occurred', { endpoint });\n  }\n};\n\n// Content validation\nconst validateContentItem = (data: unknown): ContentItem => {\n  if (!data || typeof data !== 'object') {\n    throw new ValidationError('Invalid content item data');\n  }\n\n  const item = data as Partial<ContentItem>;\n\n  if (!item.id || typeof item.id !== 'string') {\n    throw new ValidationError('Content item must have a valid ID');\n  }\n\n  if (!item.title || typeof item.title !== 'string') {\n    throw new ValidationError('Content item must have a valid title');\n  }\n\n  if (\n    !item.category ||\n    ![\n      'Courses',\n      'Procedures',\n      'Policies',\n      'Learning Pathways',\n      'Advanced',\n    ].includes(item.category)\n  ) {\n    throw new ValidationError('Content item must have a valid category');\n  }\n\n  if (\n    !item.status ||\n    !['Not Started', 'In Progress', 'Completed'].includes(item.status)\n  ) {\n    throw new ValidationError('Content item must have a valid status');\n  }\n\n  if (\n    typeof item.progress !== 'number' ||\n    item.progress < 0 ||\n    item.progress > 100\n  ) {\n    throw new ValidationError(\n      'Content item must have a valid progress value (0-100)'\n    );\n  }\n\n  return item as ContentItem;\n};\n\n// API Service class\nclass KnowledgeHubApiService {\n  private requestCache = new Map<\n    string,\n    { data: unknown; timestamp: number }\n  >();\n  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n  private rateLimiter: RateLimiter;\n\n  constructor() {\n    this.rateLimiter = new RateLimiter(RATE_LIMIT_CONFIG);\n  }\n\n  // Cache management\n  private getCachedData<T>(key: string): T | null {\n    const cached = this.requestCache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {\n      return cached.data as T;\n    }\n    this.requestCache.delete(key);\n    return null;\n  }\n\n  private setCachedData<T>(key: string, data: T): void {\n    this.requestCache.set(key, { data, timestamp: Date.now() });\n  }\n\n  private clearCache(): void {\n    this.requestCache.clear();\n  }\n\n  private invalidateRelatedCaches(contentId?: string): void {\n    // Clear specific cache entries instead of everything\n    const keysToRemove: string[] = [];\n\n    for (const key of this.requestCache.keys()) {\n      // Always clear content-related caches\n      if (key.includes('fetchContent') || key.includes('contentStats')) {\n        keysToRemove.push(key);\n      }\n\n      // Clear specific item cache if contentId provided\n      if (contentId && key.includes(contentId)) {\n        keysToRemove.push(key);\n      }\n    }\n\n    keysToRemove.forEach((key) => this.requestCache.delete(key));\n  }\n\n  // Fetch all content\n  async fetchContent(): Promise<ContentItem[]> {\n    const cacheKey = 'fetchContent';\n    const cached = this.getCachedData<ContentItem[]>(cacheKey);\n\n    if (cached) {\n      return cached;\n    }\n\n    // Use fetch in test environment, otherwise return mock data\n    if (\n      typeof global !== 'undefined' &&\n      typeof global.fetch === 'function' &&\n      process.env.NODE_ENV === 'test'\n    ) {\n      try {\n        const data = await apiRequest<ContentItem[]>(\n          '/content',\n          this.rateLimiter\n        );\n        this.setCachedData(cacheKey, data);\n        return data;\n      } catch (error) {\n        // Fallback to mock data if fetch fails\n        console.warn('Fetch failed, using mock data:', error);\n      }\n    }\n\n    // Return mock data for now since we're using Supabase\n    const mockData: ContentItem[] = [\n      {\n        id: '1',\n        title: 'Basic Sterilization Training',\n        description: 'Learn the fundamentals of sterilization procedures',\n        category: 'Courses',\n        status: 'draft',\n        progress: 0,\n        dueDate: '2024-12-31',\n        lastUpdated: '2024-12-01',\n        department: 'Sterilization',\n        tags: ['beginner', 'required'],\n        estimatedDuration: 30,\n        difficultyLevel: 'Beginner',\n      },\n      {\n        id: '2',\n        title: 'Advanced Autoclave Procedures',\n        description: 'Master advanced autoclave operation techniques',\n        category: 'Procedures',\n        status: 'draft',\n        progress: 45,\n        dueDate: '2024-12-15',\n        lastUpdated: '2024-12-05',\n        department: 'Sterilization',\n        tags: ['advanced', 'hands-on'],\n        estimatedDuration: 60,\n        difficultyLevel: 'Advanced',\n      },\n      {\n        id: '3',\n        title: 'Safety Protocols',\n        description: 'Essential safety protocols for medical facilities',\n        category: 'Policies',\n        status: 'draft',\n        progress: 100,\n        dueDate: '2024-11-30',\n        lastUpdated: '2024-11-25',\n        department: 'General',\n        tags: ['safety', 'mandatory'],\n        estimatedDuration: 45,\n        difficultyLevel: 'Intermediate',\n      },\n    ];\n\n    this.setCachedData(cacheKey, mockData);\n    return mockData;\n  }\n\n  // Fetch content by category\n  async fetchContentByCategory(category: string): Promise<ContentItem[]> {\n    const cacheKey = `fetchContentByCategory:${category}`;\n    const cached = this.getCachedData<ContentItem[]>(cacheKey);\n\n    if (cached) {\n      return cached;\n    }\n\n    // Use fetch in test environment, otherwise filter mock data\n    if (\n      typeof global !== 'undefined' &&\n      typeof global.fetch === 'function' &&\n      process.env.NODE_ENV === 'test'\n    ) {\n      try {\n        const data = await apiRequest<ContentItem[]>(\n          `/content?category=${encodeURIComponent(category)}`,\n          this.rateLimiter\n        );\n        this.setCachedData(cacheKey, data);\n        return data;\n      } catch (error) {\n        // Fallback to filtering mock data if fetch fails\n        console.warn('Fetch failed, using filtered mock data:', error);\n      }\n    }\n\n    // Return mock data filtered by category\n    const allContent = await this.fetchContent();\n    const filteredContent = allContent.filter(\n      (item) => item.category === category\n    );\n\n    this.setCachedData(cacheKey, filteredContent);\n    return filteredContent;\n  }\n\n  // Update content\n  async updateContent(\n    contentId: string,\n    updates?: Partial<ContentItem>\n  ): Promise<ContentItem> {\n    try {\n      // If updates are provided, merge them with existing content\n      let data: ContentItem;\n      if (updates) {\n        // For now, just return the updates as the updated content\n        // In a real implementation, this would merge with existing data\n        data = updates as ContentItem;\n      } else {\n        data = await apiRequest<ContentItem>(\n          `/content/${contentId}`,\n          this.rateLimiter,\n          true // Use burst limit for updates\n        );\n      }\n\n      const validatedData = validateContentItem(data);\n\n      // Invalidate related cache entries\n      this.invalidateRelatedCaches(contentId);\n\n      return validatedData;\n    } catch (error) {\n      if (error instanceof ContentNotFoundError) {\n        throw new ContentNotFoundError(contentId);\n      }\n      throw error;\n    }\n  }\n\n  // Update content status\n  async updateContentStatus(\n    contentId: string,\n    status: string\n  ): Promise<ContentItem> {\n    if (!['Not Started', 'In Progress', 'Completed'].includes(status)) {\n      throw new ValidationError(`Invalid status: ${status}`);\n    }\n\n    return this.updateContent(contentId, { status: status as ContentStatus });\n  }\n\n  // Delete content\n  async deleteContent(contentId: string): Promise<void> {\n    try {\n      await apiRequest(\n        `/content/${contentId}`,\n        this.rateLimiter,\n        true // Use burst limit for deletions\n      );\n\n      // Invalidate cache\n      this.invalidateRelatedCaches(contentId);\n    } catch (error) {\n      if (error instanceof ContentNotFoundError) {\n        throw new ContentNotFoundError(contentId);\n      }\n      throw error;\n    }\n  }\n\n  // Search content\n  async searchContent(\n    query: string,\n    filters?: {\n      category?: string;\n      status?: string;\n      department?: string;\n    }\n  ): Promise<ContentItem[]> {\n    const params = new URLSearchParams();\n    params.append('q', query);\n\n    if (filters?.category) params.append('category', filters.category);\n    if (filters?.status) params.append('status', filters.status);\n    if (filters?.department) params.append('department', filters.department);\n\n    try {\n      const data = await apiRequest<ContentItem[]>(\n        `/content/search?${params.toString()}`,\n        this.rateLimiter\n      );\n      return data.map((item) => validateContentItem(item));\n    } catch (error) {\n      if (error instanceof ContentNotFoundError) {\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  // Get content statistics\n  async getContentStats(): Promise<{\n    total: number;\n    byCategory: Record<string, number>;\n    byStatus: Record<string, number>;\n  }> {\n    const cacheKey = 'contentStats';\n    const cached = this.getCachedData<{\n      total: number;\n      byCategory: Record<string, number>;\n      byStatus: Record<string, number>;\n    }>(cacheKey);\n\n    if (cached) {\n      return cached;\n    }\n\n    // Use fetch in test environment, otherwise calculate from mock data\n    if (\n      typeof global !== 'undefined' &&\n      typeof global.fetch === 'function' &&\n      process.env.NODE_ENV === 'test'\n    ) {\n      try {\n        const data = await apiRequest<{\n          total: number;\n          byCategory: Record<string, number>;\n          byStatus: Record<string, number>;\n        }>('/content/stats', this.rateLimiter);\n        this.setCachedData(cacheKey, data);\n        return data;\n      } catch (err) { console.error(err); throw err; }\n        // Fallback to calculating from mock data if fetch fails\n        console.warn('Fetch failed, calculating stats from mock data');\n      }\n    }\n\n    // Calculate stats from mock data\n    const allContent = await this.fetchContent();\n    const stats = {\n      total: allContent.length,\n      byCategory: {} as Record<string, number>,\n      byStatus: {} as Record<string, number>,\n    };\n\n    allContent.forEach((item) => {\n      stats.byCategory[item.category] =\n        (stats.byCategory[item.category] || 0) + 1;\n      stats.byStatus[item.status] = (stats.byStatus[item.status] || 0) + 1;\n    });\n\n    this.setCachedData(cacheKey, stats);\n    return stats;\n  }\n\n  // Health check\n  async healthCheck(): Promise<boolean> {\n    // Use fetch in test environment, otherwise return true\n    if (\n      typeof global !== 'undefined' &&\n      typeof global.fetch === 'function' &&\n      process.env.NODE_ENV === 'test'\n    ) {\n      try {\n        await apiRequest<{ status: string }>('/health', this.rateLimiter, true);\n        return true;\n      } catch (err) { console.error(err); throw err; }\n        return false;\n      }\n    }\n\n    // Since we're using mock data, always return true\n    return true;\n  }\n\n  // Rate limiter management methods\n  getRateLimitStats() {\n    return this.rateLimiter.getStats();\n  }\n\n  resetRateLimiter() {\n    this.rateLimiter.reset();\n  }\n\n  // Update rate limit configuration\n  updateRateLimitConfig(config: Partial<typeof RATE_LIMIT_CONFIG>) {\n    this.rateLimiter = new RateLimiter({ ...RATE_LIMIT_CONFIG, ...config });\n  }\n}\n\n// Export singleton instance\nexport const knowledgeHubApiService = new KnowledgeHubApiService();\n\n// Add clearCache method to the service instance\n(knowledgeHubApiService as unknown as { clearCache: () => void }).clearCache =\n  () => {\n    // Clear any cached data\n    console.log('Cache cleared');\n  };\n\n// Export fetchContent as a standalone function for direct imports\nexport const fetchContent = async (): Promise<ContentItem[]> => {\n  return knowledgeHubApiService.fetchContent();\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubBulkService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubLogger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubServiceLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\knowledgeHubSupabaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\progressTrackingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\providerService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 38,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ContentItem } from '../types';\nimport { knowledgeHubApiService } from './knowledgeHubApiService';\n\nexport class ProviderService {\n  static getCategoryCount(content: ContentItem[], category: string): number {\n    return content.filter((item) => item.category === category).length;\n  }\n\n  static updateContentInList(\n    content: ContentItem[],\n    contentId: string,\n    updates: Partial<ContentItem>\n  ): ContentItem[] {\n    return content.map((item) =>\n      item.id === contentId ? { ...item, ...updates } : item\n    );\n  }\n\n  static removeContentFromList(\n    content: ContentItem[],\n    contentId: string\n  ): ContentItem[] {\n    return content.filter((item) => item.id !== contentId);\n  }\n\n  static async performContentUpdate(\n    contentId: string,\n    updates: Partial<ContentItem>\n  ): Promise<ContentItem> {\n    try {\n      return await knowledgeHubApiService.updateContent(contentId, updates);\n    } catch (err) { console.error(err); throw err; }\n      // If API is not available, return a mock updated item\n      return { id: contentId, ...updates } as ContentItem;\n    }\n  }\n\n  static async performContentDeletion(contentId: string): Promise<void> {\n    try {\n      return await knowledgeHubApiService.deleteContent(contentId);\n    } catch (err) { console.error(err); throw err; }\n      // If API is not available, just return (deletion \"succeeded\")\n      return;\n    }\n  }\n\n  static async performContentStatusUpdate(\n    contentId: string,\n    status: string\n  ): Promise<ContentItem> {\n    try {\n      return await knowledgeHubApiService.updateContentStatus(\n        contentId,\n        status\n      );\n    } catch (err) { console.error(err); throw err; }\n      // If API is not available, return a mock updated item\n      return { id: contentId, status } as ContentItem;\n    }\n  }\n\n  static async performContentFetch(): Promise<ContentItem[]> {\n    try {\n      return await knowledgeHubApiService.fetchContent();\n    } catch (err) { console.error(err); throw err; }\n      // If API is not available, return empty array\n      return [];\n    }\n  }\n\n  static createError(message: string): Error {\n    return new Error(message);\n  }\n\n  static getErrorMessage(error: unknown): string {\n    return error instanceof Error ? error.message : 'An unknown error occurred';\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\quizService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\supabaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\transformers\\unifiedDataTransformer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\types\\knowledgeHubTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\uiStateService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userDataIntegrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\ContentRecommendationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\UserLearningProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\UserPerformanceMetricsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\UserProfileService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\services\\userData\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\authStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\businessLogicStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\contentStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\knowledgeHubActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\knowledgeHubSelectors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\knowledgeHubStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\knowledgeHubStoreWithSlices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\knowledgeHubTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\performanceMonitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\performanceStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\rateLimitStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\authSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\businessLogicSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\contentSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\performanceSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\rateLimitSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\slices\\uiSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\uiStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\useKnowledgeHubStores.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\store\\useKnowledgeHubStoresWithSlices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\types.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 137,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as yup from 'yup';\n\n// Re-export Course from models to fix import issues\nexport interface Course {\n  id: string;\n  title: string;\n  domain: string;\n  contentType?: string;\n  tags?: string[];\n  progress: number;\n  status: string;\n  dueDate?: string;\n  assignedBy?: string;\n  lastCompleted?: string;\n  isRepeat?: boolean;\n  score?: number;\n  media?: {\n    type: string;\n    url: string;\n  };\n  description?: string; // Add description property to fix CourseCard error\n}\n\n// Specific types for better type safety - Updated to match database schema\nexport type ContentStatus = 'draft' | 'published' | 'archived' | 'review';\nexport type ContentCategory =\n  | 'Courses'\n  | 'Procedures'\n  | 'Policies'\n  | 'Learning Pathways'\n  | 'Advanced';\n\nexport interface ContentItem {\n  id: string;\n  title: string;\n  category: ContentCategory;\n  status: ContentStatus;\n  dueDate: string; // ISO date string\n  progress: number; // 0-100\n  department?: string;\n  lastUpdated?: string; // ISO date string\n  description?: string; // Add description property to fix provider error\n  tags?: string[]; // Add tags for filtering\n  domain?: string; // Add domain for filtering\n  contentType?: string; // Add contentType for filtering\n  type?: string; // Add type property for table components\n  createdAt?: string; // Add createdAt property for table components\n  isActive?: boolean; // Add isActive property for filtering\n  estimatedDuration?: number; // Add estimated duration in minutes\n  difficultyLevel?: string; // Add difficulty level\n  // Additional properties for course functionality\n  repeatSettings?: {\n    frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';\n    interval: number;\n    lastCompleted?: string;\n  };\n  mandatoryRepeat?: boolean;\n  passingScore?: number;\n  data?: {\n    description?: string;\n    tags?: string[];\n    createdAt?: string;\n    isActive?: boolean;\n    [key: string]: unknown;\n  };\n}\n\nexport interface RecentUpdate {\n  type: 'new' | 'completed' | 'assigned' | 'overdue';\n  title: string;\n  icon: React.ComponentType<{\n    size?: number;\n    color?: string;\n    className?: string;\n  }>;\n  time: string;\n}\n\n// Validation schemas\nexport const contentItemSchema = yup.object({\n  id: yup.string().required('ID is required'),\n  title: yup\n    .string()\n    .required('Title is required')\n    .min(1, 'Title cannot be empty'),\n  category: yup\n    .string()\n    .oneOf([\n      'Courses',\n      'Procedures',\n      'Policies',\n      'Learning Pathways',\n      'Advanced',\n    ] as const)\n    .required('Category is required'),\n  status: yup\n    .string()\n    .oneOf(['draft', 'published', 'archived', 'review'] as const)\n    .required('Status is required'),\n  dueDate: yup\n    .string()\n    .required('Due date is required')\n    .matches(/^\\d{4}-\\d{2}-\\d{2}$/, 'Due date must be in YYYY-MM-DD format'),\n  progress: yup\n    .number()\n    .required('Progress is required')\n    .min(0, 'Progress cannot be negative')\n    .max(100, 'Progress cannot exceed 100'),\n  department: yup.string().optional(),\n  lastUpdated: yup\n    .string()\n    .optional()\n    .matches(\n      /^\\d{4}-\\d{2}-\\d{2}$/,\n      'Last updated must be in YYYY-MM-DD format'\n    ),\n});\n\nexport const recentUpdateSchema = yup.object({\n  type: yup\n    .string()\n    .oneOf(['new', 'completed', 'assigned', 'overdue'] as const)\n    .required('Type is required'),\n  title: yup.string().required('Title is required'),\n  icon: yup.mixed().required('Icon is required'),\n  time: yup.string().required('Time is required'),\n});\n\n// Type guards for runtime validation\nexport const isValidContentItem = (data: unknown): data is ContentItem => {\n  try {\n    contentItemSchema.validateSync(data);\n    return true;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\nexport const isValidRecentUpdate = (data: unknown): data is RecentUpdate => {\n  try {\n    recentUpdateSchema.validateSync(data);\n    return true;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\n// Utility functions for validation\nexport const validateContentItem = (data: unknown): ContentItem => {\n  return contentItemSchema.validateSync(data) as ContentItem;\n};\n\nexport const validateRecentUpdate = (data: unknown): RecentUpdate => {\n  return recentUpdateSchema.validateSync(data) as RecentUpdate;\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\types\\errors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\utils\\courseUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\utils\\inputValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\utils\\permissions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\KnowledgeHub\\utils\\validation.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 245,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  ContentItem,\n  RecentUpdate,\n  contentItemSchema,\n  recentUpdateSchema,\n} from '../types';\nimport * as yup from 'yup';\n\n// Security constants\nconst MAX_INPUT_LENGTH = 1000;\nconst MAX_TITLE_LENGTH = 200;\nconst MAX_DESCRIPTION_LENGTH = 2000;\nconst DANGEROUS_PATTERNS = [\n  /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n  /javascript:/gi,\n  /on\\w+\\s*=/gi,\n  /data:text\\/html/gi,\n  /vbscript:/gi,\n  /expression\\s*\\(/gi,\n];\n\n/**\n * Sanitizes input to prevent XSS attacks\n */\nexport const sanitizeInput = (input: string): string => {\n  if (typeof input !== 'string') {\n    return '';\n  }\n\n  // Remove null bytes and control characters\n  // eslint-disable-next-line no-control-regex\n  let sanitized = input.replace(/[\\u0000-\\u001F\\u007F]/g, '');\n\n  // Remove dangerous patterns\n  DANGEROUS_PATTERNS.forEach((pattern) => {\n    sanitized = sanitized.replace(pattern, '');\n  });\n\n  // HTML entity encoding for special characters\n  sanitized = sanitized\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n\n  // Limit length\n  return sanitized.slice(0, MAX_INPUT_LENGTH);\n};\n\n/**\n * Sanitizes search query with additional security measures\n */\nexport const sanitizeSearchQuery = (query: string): string => {\n  if (typeof query !== 'string') {\n    return '';\n  }\n\n  // Basic sanitization\n  let sanitized = sanitizeInput(query);\n\n  // Remove SQL injection patterns\n  const sqlPatterns = [\n    /(\\b(union|select|insert|update|delete|drop|create|alter)\\b)/gi,\n    /(\\b(or|and)\\b\\s+\\d+\\s*=\\s*\\d+)/gi,\n    /(\\b(union|select|insert|update|delete|drop|create|alter)\\b.*\\b(union|select|insert|update|delete|drop|create|alter)\\b)/gi,\n  ];\n\n  sqlPatterns.forEach((pattern) => {\n    sanitized = sanitized.replace(pattern, '');\n  });\n\n  // Remove excessive whitespace\n  sanitized = sanitized.replace(/\\s+/g, ' ').trim();\n\n  return sanitized.slice(0, 100); // Limit search query length\n};\n\n/**\n * Validates a single content item and returns validation result\n */\nexport const validateSingleContentItem = (\n  data: unknown\n): { isValid: boolean; errors?: string[] } => {\n  try {\n    // Pre-validation sanitization\n    if (data && typeof data === 'object') {\n      const sanitizedData = { ...data } as Record<string, unknown>;\n\n      if (typeof sanitizedData.title === 'string') {\n        sanitizedData.title = sanitizeInput(sanitizedData.title).slice(\n          0,\n          MAX_TITLE_LENGTH\n        );\n      }\n\n      if (typeof sanitizedData.description === 'string') {\n        sanitizedData.description = sanitizeInput(\n          sanitizedData.description\n        ).slice(0, MAX_DESCRIPTION_LENGTH);\n      }\n\n      data = sanitizedData;\n    }\n\n    contentItemSchema.validateSync(data, { abortEarly: false });\n    return { isValid: true };\n  } catch (error: unknown) {\n    if (error && typeof error === 'object' && 'inner' in error) {\n      const errors = (error as { inner: Array<{ message: string }> }).inner.map(\n        (err) => err.message\n      );\n      return { isValid: false, errors };\n    }\n    return { isValid: false, errors: [(error as Error).message] };\n  }\n};\n\n/**\n * Validates an array of content items and returns validation result\n */\nexport const validateContentItems = (\n  data: unknown[]\n): {\n  isValid: boolean;\n  validItems: ContentItem[];\n  invalidItems: { index: number; errors: string[] }[];\n} => {\n  const validItems: ContentItem[] = [];\n  const invalidItems: { index: number; errors: string[] }[] = [];\n\n  data.forEach((item, index) => {\n    const result = validateSingleContentItem(item);\n    if (result.isValid) {\n      validItems.push(item as ContentItem);\n    } else {\n      invalidItems.push({ index, errors: result.errors || [] });\n    }\n  });\n\n  return {\n    isValid: invalidItems.length === 0,\n    validItems,\n    invalidItems,\n  };\n};\n\n/**\n * Validates a single recent update and returns validation result\n */\nexport const validateSingleRecentUpdate = (\n  data: unknown\n): { isValid: boolean; errors?: string[] } => {\n  try {\n    // Pre-validation sanitization\n    if (data && typeof data === 'object') {\n      const sanitizedData = { ...data } as Record<string, unknown>;\n\n      if (typeof sanitizedData.title === 'string') {\n        sanitizedData.title = sanitizeInput(sanitizedData.title).slice(\n          0,\n          MAX_TITLE_LENGTH\n        );\n      }\n\n      data = sanitizedData;\n    }\n\n    recentUpdateSchema.validateSync(data, { abortEarly: false });\n    return { isValid: true };\n  } catch (error: unknown) {\n    if (error && typeof error === 'object' && 'inner' in error) {\n      const errors = (error as { inner: Array<{ message: string }> }).inner.map(\n        (err) => err.message\n      );\n      return { isValid: false, errors };\n    }\n    return { isValid: false, errors: [(error as Error).message] };\n  }\n};\n\n/**\n * Validates an array of recent updates and returns validation result\n */\nexport const validateRecentUpdates = (\n  data: unknown[]\n): {\n  isValid: boolean;\n  validItems: RecentUpdate[];\n  invalidItems: { index: number; errors: string[] }[];\n} => {\n  const validItems: RecentUpdate[] = [];\n  const invalidItems: { index: number; errors: string[] }[] = [];\n\n  data.forEach((item, index) => {\n    const result = validateSingleRecentUpdate(item);\n    if (result.isValid) {\n      validItems.push(item as RecentUpdate);\n    } else {\n      invalidItems.push({ index, errors: result.errors || [] });\n    }\n  });\n\n  return {\n    isValid: invalidItems.length === 0,\n    validItems,\n    invalidItems,\n  };\n};\n\n/**\n * Sanitizes and validates content item data from API\n */\nexport const sanitizeContentItem = (\n  data: Record<string, unknown>\n): ContentItem | null => {\n  try {\n    // Comprehensive sanitization\n    const sanitized = {\n      id: String(data.id || '').trim(),\n      title: sanitizeInput(String(data.title || ''))\n        .trim()\n        .slice(0, MAX_TITLE_LENGTH),\n      category: String(data.category || 'Courses'),\n      status: String(data.status || 'draft'),\n      dueDate: String(data.dueDate || ''),\n      progress: Number(data.progress || 0),\n      department: data.department\n        ? sanitizeInput(String(data.department)).trim()\n        : undefined,\n      lastUpdated: data.lastUpdated ? String(data.lastUpdated) : undefined,\n      description: data.description\n        ? sanitizeInput(String(data.description)).slice(\n            0,\n            MAX_DESCRIPTION_LENGTH\n          )\n        : undefined,\n    };\n\n    // Validate the sanitized data\n    return validateContentItem(sanitized);\n  } catch (err) { console.error(err); throw err; }\n    return null;\n  }\n};\n\n/**\n * Sanitizes and validates recent update data from API\n */\nexport const sanitizeRecentUpdate = (\n  data: Record<string, unknown>\n): RecentUpdate | null => {\n  try {\n    // Comprehensive sanitization\n    const sanitized = {\n      type: String(data.type || 'new'),\n      title: sanitizeInput(String(data.title || ''))\n        .trim()\n        .slice(0, MAX_TITLE_LENGTH),\n      icon: data.icon,\n      time: String(data.time || ''),\n    };\n\n    // Validate the sanitized data\n    return validateRecentUpdate(sanitized);\n  } catch (err) { console.error(err); throw err; }\n    return null;\n  }\n};\n\n/**\n * Type guard for checking if data is a valid content item\n */\nexport const isContentItem = (data: unknown): data is ContentItem => {\n  return isValidContentItem(data);\n};\n\n/**\n * Type guard for checking if data is a valid recent update\n */\nexport const isRecentUpdate = (data: unknown): data is RecentUpdate => {\n  return isValidRecentUpdate(data);\n};\n\n// Enhanced validation schemas for user-generated content\nexport const userContentValidationSchema = yup.object({\n  id: yup.string().required('ID is required').min(1, 'ID cannot be empty'),\n\n  title: yup\n    .string()\n    .required('Title is required')\n    .min(3, 'Title must be at least 3 characters')\n    .max(MAX_TITLE_LENGTH, `Title cannot exceed ${MAX_TITLE_LENGTH} characters`)\n    .matches(/^[a-zA-Z0-9\\s\\-_.,!?()]+$/, 'Title contains invalid characters')\n    .trim(),\n\n  category: yup\n    .string()\n    .oneOf([\n      'Courses',\n      'Procedures',\n      'Policies',\n      'Learning Pathways',\n      'Advanced',\n    ] as const)\n    .required('Category is required'),\n\n  status: yup\n    .string()\n    .oneOf(['draft', 'review', 'published', 'archived'] as const)\n    .required('Status is required'),\n\n  dueDate: yup\n    .string()\n    .required('Due date is required')\n    .matches(/^\\d{4}-\\d{2}-\\d{2}$/, 'Due date must be in YYYY-MM-DD format'),\n\n  progress: yup\n    .mixed()\n    .required('Progress is required')\n    .transform((value) => {\n      const num = Number(value);\n      return isNaN(num) ? 0 : num;\n    })\n    .test('range', 'Progress must be between 0 and 100', function (value) {\n      const num = Number(value);\n      return num >= 0 && num <= 100;\n    }),\n\n  department: yup\n    .string()\n    .optional()\n    .max(100, 'Department name cannot exceed 100 characters')\n    .matches(/^[a-zA-Z0-9\\s\\-_]+$/, 'Department contains invalid characters'),\n\n  description: yup\n    .string()\n    .optional()\n    .max(\n      MAX_DESCRIPTION_LENGTH,\n      `Description cannot exceed ${MAX_DESCRIPTION_LENGTH} characters`\n    )\n    .matches(\n      /^[a-zA-Z0-9\\s\\-_.,!?()\\n\\r]+$/,\n      'Description contains invalid characters'\n    ),\n});\n\n// Validation for content updates\nexport const contentUpdateValidationSchema = yup.object({\n  id: yup\n    .string()\n    .required('Content ID is required')\n    .uuid('Invalid content ID'),\n  status: yup\n    .string()\n    .oneOf(['Not Started', 'In Progress', 'Completed'] as const)\n    .required('Status is required'),\n  progress: yup\n    .number()\n    .min(0, 'Progress cannot be negative')\n    .max(100, 'Progress cannot exceed 100')\n    .integer('Progress must be a whole number'),\n});\n\n// Validation for search queries\nexport const searchQueryValidationSchema = yup.object({\n  query: yup\n    .string()\n    .max(100, 'Search query cannot exceed 100 characters')\n    .matches(\n      /^[a-zA-Z0-9\\s\\-_.,!?()]+$/,\n      'Search query contains invalid characters'\n    ),\n  category: yup\n    .string()\n    .oneOf([\n      'all',\n      'Courses',\n      'Procedures',\n      'Policies',\n      'Learning Pathways',\n      'Advanced',\n    ] as const)\n    .optional(),\n});\n\n// Validation for bulk operations\nexport const bulkOperationValidationSchema = yup.object({\n  itemIds: yup\n    .array()\n    .of(yup.string().uuid('Invalid item ID'))\n    .min(1, 'At least one item must be selected')\n    .max(100, 'Cannot process more than 100 items at once'),\n  operation: yup\n    .string()\n    .oneOf(['delete', 'updateStatus', 'export'] as const)\n    .required('Operation type is required'),\n});\n\n// Rate limiting utility\nexport class RateLimiter {\n  private requests = new Map<string, { count: number; resetTime: number }>();\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n\n  constructor(maxRequests: number = 100, windowMs: number = 60000) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n  }\n\n  checkLimit(userId: string, operation: string): boolean {\n    const key = `${userId}:${operation}`;\n    const now = Date.now();\n    const record = this.requests.get(key);\n\n    if (!record || now > record.resetTime) {\n      this.requests.set(key, { count: 1, resetTime: now + this.windowMs });\n      return true;\n    }\n\n    if (record.count >= this.maxRequests) {\n      return false;\n    }\n\n    record.count++;\n    return true;\n  }\n\n  resetLimit(userId: string, operation: string): void {\n    const key = `${userId}:${operation}`;\n    this.requests.delete(key);\n  }\n}\n\n// Export rate limiter instance\nexport const rateLimiter = new RateLimiter();\n\n// Validation functions\nexport const validateContentItem = (data: unknown): ContentItem | null => {\n  try {\n    return userContentValidationSchema.validateSync(data) as ContentItem;\n  } catch (err) { console.error(err); throw err; }\n    return null;\n  }\n};\n\nexport const validateContentUpdate = (data: unknown) => {\n  return userContentValidationSchema.validateSync(data);\n};\n\nexport const validateSearchQuery = (data: unknown) => {\n  return yup.string().max(100).validateSync(data);\n};\n\nexport const validateBulkOperation = (data: unknown) => {\n  return yup.array().of(yup.string()).max(100).validateSync(data);\n};\n\nexport const validateRecentUpdate = (data: unknown): RecentUpdate => {\n  return recentUpdateSchema.validateSync(data) as RecentUpdate;\n};\n\nexport const isValidContentItem = (data: unknown): data is ContentItem => {\n  try {\n    userContentValidationSchema.validateSync(data);\n    return true;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\nexport const isValidContentUpdate = (data: unknown): boolean => {\n  try {\n    userContentValidationSchema.validateSync(data);\n    return true;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\nexport const isValidRecentUpdate = (data: unknown): boolean => {\n  try {\n    recentUpdateSchema.validateSync(data);\n    return true;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\nexport const formatValidationError = (error: yup.ValidationError): string => {\n  return error.errors.join(', ');\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Learning\\logic\\__tests__\\useDragAndDropHandlers.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Learning\\logic\\__tests__\\useLearningPathwayData.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginActions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginFooter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginFormFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginFormInputs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\LoginHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\CheckboxFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\EmailField.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\LoadingIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\LoginProgressIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\OfflineWarning.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\OtpField.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\PasswordField.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\PasswordResetModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\PasswordStrengthIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\SecurityStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\SecurityWarnings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\hooks\\useLoginForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\hooks\\useLoginSecurity.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Login\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\UserProfile.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\AIAnalyticsSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\AccountManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\AccountSecurity.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\BasicInformation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\BillingSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\BillingTierManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\ClinicInformation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\ContentManagementSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\DeleteAccountModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\EnvironmentalCleaningSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\FormInput.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\FormSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\FormSelect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\AITab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\CategoriesTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\FormGroup.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\GeneralTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\ReportingTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\StockTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\ToggleSwitch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\index.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 60,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiPackageVariant,\n  mdiBrain,\n  mdiCog,\n  mdiContentSave,\n  mdiRefresh,\n  mdiAlertCircle,\n  mdiCheckCircle,\n  mdiChartBar,\n  mdiTune,\n} from '@mdi/js';\nimport GeneralTab from './GeneralTab';\nimport StockTab from './StockTab';\nimport CategoriesTab from './CategoriesTab';\nimport ReportingTab from './ReportingTab';\nimport AITab from './AITab';\nimport { useInventorySettings } from './useInventorySettings';\n\nconst InventoryManagementSettings: React.FC = () => {\n  const [activeTab, setActiveTab] = useState('general');\n  const [isSaving, setIsSaving] = useState(false);\n  const [message, setMessage] = useState<{\n    type: 'success' | 'error';\n    text: string;\n  } | null>(null);\n\n  const {\n    settings,\n    setSettings,\n    aiSettings,\n    aiMessage,\n    isLoading,\n    handleAISettingChange,\n    handleAISettingsSave,\n    handleAISettingsReset,\n    saveSettings,\n    loadSettings,\n  } = useInventorySettings();\n\n  const tabs = [\n    { id: 'general', label: 'General Settings', icon: mdiCog },\n    { id: 'stock', label: 'Stock Management', icon: mdiPackageVariant },\n    { id: 'categories', label: 'Categories & Tags', icon: mdiTune },\n    { id: 'reporting', label: 'Reporting & Analytics', icon: mdiChartBar },\n    { id: 'ai', label: 'AI & Machine Learning', icon: mdiBrain },\n  ];\n\n  const handleSaveSettings = async () => {\n    try {\n      setIsSaving(true);\n      setMessage(null);\n\n      await saveSettings();\n      setMessage({ type: 'success', text: 'Settings saved successfully' });\n      setTimeout(() => setMessage(null), 3000);\n    } catch (err) { console.error(err); throw err; }\n      setMessage({ type: 'error', text: 'Failed to save settings' });\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'general':\n        return (\n          <GeneralTab settings={settings} onSettingsChange={setSettings} />\n        );\n      case 'stock':\n        return <StockTab settings={settings} onSettingsChange={setSettings} />;\n      case 'categories':\n        return (\n          <CategoriesTab settings={settings} onSettingsChange={setSettings} />\n        );\n      case 'reporting':\n        return (\n          <ReportingTab settings={settings} onSettingsChange={setSettings} />\n        );\n      case 'ai':\n        return (\n          <AITab\n            aiSettings={aiSettings}\n            onAISettingChange={handleAISettingChange}\n            onAISettingsSave={handleAISettingsSave}\n            onAISettingsReset={handleAISettingsReset}\n            isLoading={isLoading}\n            aiMessage={aiMessage}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center py-8\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600\"></div>\n        <span className=\"ml-2 text-gray-600\">\n          Loading inventory settings...\n        </span>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <h4 className=\"text-lg font-semibold mb-4\">\n        Inventory Management Settings\n      </h4>\n      <p className=\"text-sm text-gray-600 mb-6\">\n        Configure inventory behavior, AI features, and system preferences\n      </p>\n\n      {/* Message Display */}\n      {message && (\n        <div\n          className={`p-4 rounded-lg border mb-6 ${\n            message.type === 'success'\n              ? 'bg-green-50 border-green-200 text-green-800'\n              : 'bg-red-50 border-red-200 text-red-800'\n          }`}\n        >\n          <div className=\"flex items-center gap-2\">\n            <Icon\n              path={\n                message.type === 'success' ? mdiCheckCircle : mdiAlertCircle\n              }\n              size={1}\n              className=\"text-current\"\n            />\n            {message.text}\n          </div>\n        </div>\n      )}\n\n      {/* Tab Navigation */}\n      <div className=\"mb-6\">\n        <div className=\"border-b border-gray-200\">\n          <nav className=\"-mb-px flex space-x-8\">\n            {tabs.map((tab) => (\n              <button\n                key={tab.id}\n                onClick={() => setActiveTab(tab.id)}\n                className={`py-2 px-1 border-b-2 font-medium text-sm flex items-center space-x-2 ${\n                  activeTab === tab.id\n                    ? 'border-[#4ECDC4] text-[#4ECDC4]'\n                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\n                }`}\n              >\n                <Icon path={tab.icon} size={1} />\n                <span>{tab.label}</span>\n              </button>\n            ))}\n          </nav>\n        </div>\n      </div>\n\n      {/* Tab Content */}\n      <div className=\"tab-content-area\">{renderTabContent()}</div>\n\n      {/* Save Button */}\n      <div className=\"flex justify-end gap-3 mt-8 pt-6 border-t border-gray-200\">\n        <button\n          onClick={loadSettings}\n          className=\"px-4 py-2 text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500\"\n        >\n          <Icon path={mdiRefresh} size={1} className=\"inline mr-2\" />\n          Reset\n        </button>\n\n        <button\n          onClick={handleSaveSettings}\n          disabled={isSaving}\n          className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50\"\n        >\n          <Icon path={mdiContentSave} size={1} className=\"inline mr-2\" />\n          {isSaving ? 'Saving...' : 'Save Settings'}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default InventoryManagementSettings;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\InventoryManagementSettings\\useInventorySettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\AITab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\AdvancedTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\CertificationsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\FormGroup.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\GeneralTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\LearningPathsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\ToggleSwitch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\index.tsx",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 64,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiCog,\n  mdiBrain,\n  mdiCertificate,\n  mdiTarget,\n  mdiContentSave,\n  mdiAlertCircle,\n  mdiCheckCircle,\n  mdiTune,\n} from '@mdi/js';\nimport GeneralTab from './GeneralTab';\nimport AITab from './AITab';\nimport CertificationsTab from './CertificationsTab';\nimport LearningPathsTab from './LearningPathsTab';\nimport AdvancedTab from './AdvancedTab';\nimport { useLearningSettings } from './useLearningSettings';\n\nconst LearningTrainingSettings: React.FC = () => {\n  const [activeTab, setActiveTab] = useState('general');\n  const [isSaving, setIsSaving] = useState(false);\n  const [message, setMessage] = useState<{\n    type: 'success' | 'error';\n    text: string;\n  } | null>(null);\n\n  const {\n    aiSettings,\n    setAiSettings,\n    generalSettings,\n    setGeneralSettings,\n    certificationSettings,\n    setCertificationSettings,\n    learningPathSettings,\n    setLearningPathSettings,\n  } = useLearningSettings();\n\n  const tabs = [\n    { id: 'general', label: 'General Settings', icon: mdiCog },\n    { id: 'ai', label: 'AI & Analytics', icon: mdiBrain },\n    { id: 'certifications', label: 'Certifications', icon: mdiCertificate },\n    { id: 'learning-paths', label: 'Learning Paths', icon: mdiTarget },\n    { id: 'advanced', label: 'Advanced', icon: mdiTune },\n  ];\n\n  const handleSaveSettings = async () => {\n    try {\n      setIsSaving(true);\n      setMessage(null);\n\n      // Save settings to database/local storage\n      // This would integrate with your existing settings system\n\n      setMessage({ type: 'success', text: 'Settings saved successfully!' });\n\n      // Clear success message after 3 seconds\n      setTimeout(() => setMessage(null), 3000);\n    } catch (err) { console.error(err); throw err; }\n      setMessage({\n        type: 'error',\n        text: 'Failed to save settings. Please try again.',\n      });\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'general':\n        return (\n          <GeneralTab\n            settings={generalSettings}\n            onSettingsChange={setGeneralSettings}\n          />\n        );\n      case 'ai':\n        return <AITab settings={aiSettings} onSettingsChange={setAiSettings} />;\n      case 'certifications':\n        return (\n          <CertificationsTab\n            settings={certificationSettings}\n            onSettingsChange={setCertificationSettings}\n          />\n        );\n      case 'learning-paths':\n        return (\n          <LearningPathsTab\n            settings={learningPathSettings}\n            onSettingsChange={setLearningPathSettings}\n          />\n        );\n      case 'advanced':\n        return (\n          <AdvancedTab\n            aiSettings={aiSettings}\n            onAiSettingsChange={setAiSettings}\n          />\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h3 className=\"text-2xl font-bold text-gray-900\">\n            Learning & Training Settings\n          </h3>\n          <p className=\"text-gray-600\">\n            Configure AI-powered learning features and training modules\n          </p>\n        </div>\n        <button\n          onClick={handleSaveSettings}\n          disabled={isSaving}\n          className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-[#4ECDC4] hover:bg-[#3db8b0] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#4ECDC4] disabled:opacity-50\"\n        >\n          <Icon path={mdiContentSave} size={1} className=\"mr-2\" />\n          {isSaving ? 'Saving...' : 'Save Settings'}\n        </button>\n      </div>\n\n      {/* Message Display */}\n      {message && (\n        <div\n          className={`rounded-md p-4 ${\n            message.type === 'success'\n              ? 'bg-green-50 border border-green-200 text-green-800'\n              : 'bg-red-50 border border-red-200 text-red-800'\n          }`}\n        >\n          <div className=\"flex items-center\">\n            <Icon\n              path={\n                message.type === 'success' ? mdiCheckCircle : mdiAlertCircle\n              }\n              size={1.2}\n              className={`mr-2 ${message.type === 'success' ? 'text-green-400' : 'text-red-400'}`}\n            />\n            {message.text}\n          </div>\n        </div>\n      )}\n\n      {/* Tab Navigation */}\n      <div className=\"border-b border-gray-200\">\n        <nav className=\"-mb-px flex space-x-8\">\n          {tabs.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`py-2 px-1 border-b-2 font-medium text-sm flex items-center space-x-2 ${\n                activeTab === tab.id\n                  ? 'border-[#4ECDC4] text-[#4ECDC4]'\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\n              }`}\n            >\n              <Icon path={tab.icon} size={1} />\n              <span>{tab.label}</span>\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Tab Content */}\n      <div className=\"tab-content-area\">{renderTabContent()}</div>\n    </div>\n  );\n};\n\nexport default LearningTrainingSettings;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\LearningTrainingSettings\\useLearningSettings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\NotificationBanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\NotificationPreferences.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\OfficeClosuresManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\OfficeHoursSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\ProfileAccountSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\ProfilePhotoSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SecuritySessionsSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SessionActivity.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SterilizationAISettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SterilizationSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SterilizationSettingsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\SystemAdministrationSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\UserForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\UserManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\UserModals.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\AITab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\AdvancedTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\ComplianceTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\GeneralTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\NotificationsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\ProtocolsTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\api.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\featureFlags.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\useEnvironmentalCleaningSettings.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 76,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState } from 'react';\nimport {\n  EnvironmentalCleaningAISettings,\n  CleaningProtocolSettings,\n  NotificationSettings,\n  DEFAULT_AI_SETTINGS,\n  DEFAULT_PROTOCOL_SETTINGS,\n  DEFAULT_NOTIFICATION_SETTINGS,\n  MESSAGE_TIMEOUT,\n} from './constants';\nimport { Message } from './types';\nimport { coerceAndValidateForm } from './validation';\nimport { saveAllSettings } from './api';\n\nexport const useEnvironmentalCleaningSettings = () => {\n  const [aiSettings, setAiSettings] =\n    useState<EnvironmentalCleaningAISettings>(DEFAULT_AI_SETTINGS);\n  const [protocolSettings, setProtocolSettings] =\n    useState<CleaningProtocolSettings>(DEFAULT_PROTOCOL_SETTINGS);\n  const [notificationSettings, setNotificationSettings] =\n    useState<NotificationSettings>(DEFAULT_NOTIFICATION_SETTINGS);\n  const [message, setMessage] = useState<Message | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // AI Settings Helper Functions\n  const handleAISettingChange = (\n    field: keyof EnvironmentalCleaningAISettings,\n    value: boolean | number | string\n  ) => {\n    setAiSettings((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleProtocolSettingChange = (\n    field: keyof CleaningProtocolSettings,\n    value: boolean | number | string | string[]\n  ) => {\n    setProtocolSettings((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleNotificationSettingChange = (\n    field: keyof NotificationSettings,\n    value: boolean\n  ) => {\n    setNotificationSettings((prev) => ({ ...prev, [field]: value }));\n  };\n\n  const handleSaveSettings = async () => {\n    try {\n      setIsLoading(true);\n      setMessage(null);\n\n      // Validate settings before saving\n      const validation = coerceAndValidateForm(\n        aiSettings,\n        protocolSettings,\n        notificationSettings\n      );\n      if (!validation.isValid) {\n        setMessage({\n          type: 'error',\n          text: validation.errors[0] || 'Validation failed',\n        });\n        return;\n      }\n\n      // Save all settings using extracted API logic\n      await saveAllSettings(aiSettings, protocolSettings, notificationSettings);\n\n      setMessage({ type: 'success', text: 'Settings saved successfully!' });\n      setTimeout(() => setMessage(null), MESSAGE_TIMEOUT);\n    } catch (err) { console.error(err); throw err; }\n      setMessage({\n        type: 'error',\n        text: 'Failed to save settings. Please try again.',\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const clearMessage = () => setMessage(null);\n\n  return {\n    aiSettings,\n    protocolSettings,\n    notificationSettings,\n    message,\n    isLoading,\n    handleAISettingChange,\n    handleProtocolSettingChange,\n    handleNotificationSettingChange,\n    handleSaveSettings,\n    clearMessage,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\environmentalCleaning\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\modals\\PasswordChangeModal.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\modals\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\navigation\\TabNavigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\navigation\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilizationAI\\api.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilizationAI\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilizationAI\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilizationAI\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilizationAI\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\AISettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\CycleManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\EnforcementSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\ReceiptSettings.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\analytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\api.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 42,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  SterilizationAIService,\n  SterilizationAISettings,\n} from '../../../../../services/ai/sterilizationAIService';\nimport { AI_SETTINGS_DEFAULTS } from './constants';\n\nexport const fetchSettings = async (\n  facilityId: string\n): Promise<SterilizationAISettings | null> => {\n  try {\n    const aiService = new SterilizationAIService(facilityId);\n    return await aiService.loadSettings();\n  } catch (error) {\n    console.error('Failed to load AI settings:', error);\n    return null;\n  }\n};\n\nexport const saveSettings = async (\n  facilityId: string,\n  settings: SterilizationAISettings\n): Promise<boolean> => {\n  try {\n    const aiService = new SterilizationAIService(facilityId);\n    return await aiService.saveSettings(settings);\n  } catch (error) {\n    console.error('Failed to save AI settings:', error);\n    return false;\n  }\n};\n\nexport const testConnections = async (): Promise<{\n  success: boolean;\n  message: string;\n}> => {\n  try {\n    // This would test API connections if implemented\n    return { success: true, message: 'All connections successful' };\n  } catch (err) { console.error(err); throw err; }\n    return { success: false, message: 'Connection test failed' };\n  }\n};\n\nexport const resetDefaults = async (facilityId: string): Promise<boolean> => {\n  try {\n    const defaultSettings: SterilizationAISettings = {\n      facility_id: facilityId,\n      ai_enabled: false,\n      ai_version: AI_SETTINGS_DEFAULTS.AI_VERSION,\n      computer_vision_enabled: false,\n      tool_condition_assessment: false,\n      barcode_quality_detection: false,\n      tool_type_recognition: false,\n      cleaning_validation: false,\n      predictive_analytics_enabled: false,\n      cycle_optimization: false,\n      failure_prediction: false,\n      efficiency_optimization: false,\n      resource_planning: false,\n      smart_workflow_enabled: false,\n      intelligent_workflow_selection: false,\n      automated_problem_detection: false,\n      smart_phase_transitions: false,\n      batch_optimization: false,\n      quality_assurance_enabled: false,\n      biological_indicator_analysis: false,\n      compliance_monitoring: false,\n      audit_trail_enhancement: false,\n      risk_assessment: false,\n      scanner_intelligence_enabled: false,\n      multi_format_barcode_support: false,\n      tool_history_integration: false,\n      smart_validation: false,\n      error_prevention: false,\n      real_time_monitoring_enabled: false,\n      anomaly_detection: false,\n      predictive_maintenance: false,\n      quality_drift_detection: false,\n      smart_notifications: false,\n      ai_confidence_threshold: AI_SETTINGS_DEFAULTS.AI_CONFIDENCE_THRESHOLD,\n      ai_data_retention_days: AI_SETTINGS_DEFAULTS.AI_DATA_RETENTION_DAYS,\n      real_time_processing_enabled: false,\n      batch_processing_enabled: false,\n      data_sharing_enabled: false,\n      local_ai_processing_enabled: false,\n      encrypted_data_transmission:\n        AI_SETTINGS_DEFAULTS.ENCRYPTED_DATA_TRANSMISSION,\n      ai_model_training: false,\n      auto_optimization_enabled: false,\n      performance_monitoring: false,\n      resource_optimization: false,\n      openai_api_key_encrypted: '',\n      google_vision_api_key_encrypted: '',\n      azure_computer_vision_key_encrypted: '',\n    };\n\n    const aiService = new SterilizationAIService(facilityId);\n    return await aiService.saveSettings(defaultSettings);\n  } catch (error) {\n    console.error('Failed to reset AI settings:', error);\n    return false;\n  }\n};\n\nexport const createDefaultSettings = (\n  facilityId: string\n): SterilizationAISettings => {\n  return {\n    facility_id: facilityId,\n    ai_enabled: false,\n    ai_version: AI_SETTINGS_DEFAULTS.AI_VERSION,\n    computer_vision_enabled: false,\n    tool_condition_assessment: false,\n    barcode_quality_detection: false,\n    tool_type_recognition: false,\n    cleaning_validation: false,\n    predictive_analytics_enabled: false,\n    cycle_optimization: false,\n    failure_prediction: false,\n    efficiency_optimization: false,\n    resource_planning: false,\n    smart_workflow_enabled: false,\n    intelligent_workflow_selection: false,\n    automated_problem_detection: false,\n    smart_phase_transitions: false,\n    batch_optimization: false,\n    quality_assurance_enabled: false,\n    biological_indicator_analysis: false,\n    compliance_monitoring: false,\n    audit_trail_enhancement: false,\n    risk_assessment: false,\n    scanner_intelligence_enabled: false,\n    multi_format_barcode_support: false,\n    tool_history_integration: false,\n    smart_validation: false,\n    error_prevention: false,\n    real_time_monitoring_enabled: false,\n    anomaly_detection: false,\n    predictive_maintenance: false,\n    quality_drift_detection: false,\n    smart_notifications: false,\n    ai_confidence_threshold: AI_SETTINGS_DEFAULTS.AI_CONFIDENCE_THRESHOLD,\n    ai_data_retention_days: AI_SETTINGS_DEFAULTS.AI_DATA_RETENTION_DAYS,\n    real_time_processing_enabled: false,\n    batch_processing_enabled: false,\n    data_sharing_enabled: false,\n    local_ai_processing_enabled: false,\n    encrypted_data_transmission:\n      AI_SETTINGS_DEFAULTS.ENCRYPTED_DATA_TRANSMISSION,\n    ai_model_training: false,\n    auto_optimization_enabled: false,\n    performance_monitoring: false,\n    resource_optimization: false,\n    openai_api_key_encrypted: '',\n    google_vision_api_key_encrypted: '',\n    azure_computer_vision_key_encrypted: '',\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\sterilization\\settings\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\tabs\\AccountTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\tabs\\BasicInfoTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\tabs\\MobileTab.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 260,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 260,
        "endColumn": 19
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 295,
        "column": 18,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 296,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [7921, 7928], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 296,
        "column": 14,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 297,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [7936, 7943], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 298,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 298,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useCallback } from 'react';\nimport Icon from '@mdi/react';\nimport {\n  mdiBarcode,\n  mdiTestTube,\n  mdiBroom,\n  mdiFileDocument,\n  mdiPackage,\n  mdiPlus,\n  mdiMinus,\n  mdiAlertCircle,\n} from '@mdi/js';\nimport ToggleSwitch from '../InventoryManagementSettings/ToggleSwitch';\nimport { supabase } from '../../../../lib/supabase';\n\ninterface WorkflowShortcut {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  enabled: boolean;\n  shortcutSlot: string | null;\n}\n\ninterface MobileTabProps {\n  mobileShortcuts: Array<Record<string, unknown>>;\n  setMobileShortcuts: React.Dispatch<\n    React.SetStateAction<Array<Record<string, unknown>>>\n  >;\n  availableShortcuts: Array<Record<string, unknown>>;\n}\n\nexport const MobileTab: React.FC<MobileTabProps> = () => {\n  // Available workflow shortcuts\n  const [workflowShortcuts, setWorkflowShortcuts] = useState<\n    WorkflowShortcut[]\n  >([\n    {\n      id: 'clean-tool',\n      name: 'Clean Tool Scan',\n      description: 'Scan clean tools ready for use',\n      icon: mdiTestTube,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'dirty-tool',\n      name: 'Dirty Tool Scan',\n      description: 'Scan tools that need sterilization',\n      icon: mdiTestTube,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'problem-tool',\n      name: 'Problem Tool Scan',\n      description: 'Scan tools with issues/repair needs',\n      icon: mdiAlertCircle,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'import-receipt',\n      name: 'Import Autoclave Receipt',\n      description: 'Import physical autoclave documentation',\n      icon: mdiFileDocument,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'package-tools',\n      name: 'Package Tools',\n      description: 'Package tools for sterilization',\n      icon: mdiPackage,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'single-scan',\n      name: 'Single Scan Mode',\n      description: 'Individual tool scanning',\n      icon: mdiBarcode,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'batch-scan',\n      name: 'Batch Scan Mode',\n      description: 'Multiple tools at once',\n      icon: mdiBarcode,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'add-inventory',\n      name: 'Add Inventory',\n      description: 'Scan new items to add',\n      icon: mdiPlus,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'use-inventory',\n      name: 'Use Inventory',\n      description: 'Scan items to remove/consume',\n      icon: mdiMinus,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'scan-room',\n      name: 'Scan Room',\n      description: 'Scan room barcodes for cleaning',\n      icon: mdiBroom,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'complete-cleaning',\n      name: 'Complete Cleaning',\n      description: 'Mark room as cleaned',\n      icon: mdiBroom,\n      enabled: false,\n      shortcutSlot: null,\n    },\n    {\n      id: 'update-status',\n      name: 'Update Status',\n      description: 'Change room cleaning status',\n      icon: mdiBroom,\n      enabled: false,\n      shortcutSlot: null,\n    },\n  ]);\n\n  const handleWorkflowToggle = (workflowId: string, enabled: boolean) => {\n    if (enabled) {\n      // When enabling, check if there are available shortcuts\n      const availableShortcuts = getAvailableShortcuts();\n      if (availableShortcuts.length === 0) {\n        alert(\n          'No mobile shortcuts available. Please disable another workflow first or assign this workflow to an existing shortcut.'\n        );\n        return;\n      }\n    }\n\n    setWorkflowShortcuts((prev) =>\n      prev.map((workflow) =>\n        workflow.id === workflowId\n          ? {\n              ...workflow,\n              enabled,\n              shortcutSlot: enabled ? workflow.shortcutSlot : null,\n            }\n          : workflow\n      )\n    );\n  };\n\n  const getAvailableShortcuts = () => {\n    const usedShortcuts = workflowShortcuts\n      .filter((w) => w.enabled && w.shortcutSlot !== null)\n      .map((w) => w.shortcutSlot);\n\n    const allShortcuts = [\n      'volume-up',\n      'volume-down',\n      'volume-up-double',\n      'volume-down-double',\n      'power-double',\n      'double-tap',\n      'shake',\n      'flip',\n    ];\n\n    return allShortcuts.filter((shortcut) => !usedShortcuts.includes(shortcut));\n  };\n\n  const handleShortcutSlotChange = (\n    workflowId: string,\n    slot: string | null\n  ) => {\n    if (slot === null) {\n      // If no slot is selected, disable the workflow after a delay\n      setTimeout(() => {\n        setWorkflowShortcuts((prev) =>\n          prev.map((workflow) =>\n            workflow.id === workflowId && workflow.shortcutSlot === null\n              ? { ...workflow, enabled: false }\n              : workflow\n          )\n        );\n      }, 5000); // 5 second delay\n    }\n\n    // Clear any other workflows using this slot\n    setWorkflowShortcuts((prev) =>\n      prev.map((workflow) =>\n        workflow.shortcutSlot === slot && workflow.id !== workflowId\n          ? { ...workflow, shortcutSlot: null }\n          : workflow.id === workflowId\n            ? { ...workflow, shortcutSlot: slot }\n            : workflow\n      )\n    );\n  };\n\n  const getShortcutLabel = (shortcutId: string) => {\n    const shortcuts = [\n      { id: 'volume-up', label: 'Volume Up' },\n      { id: 'volume-down', label: 'Volume Down' },\n      { id: 'volume-up-double', label: 'Volume Up (2x)' },\n      { id: 'volume-down-double', label: 'Volume Down (2x)' },\n      { id: 'power-double', label: 'Power (2x)' },\n      { id: 'double-tap', label: 'Double Tap' },\n      { id: 'shake', label: 'Shake' },\n      { id: 'flip', label: 'Flip' },\n    ];\n    return shortcuts.find((s) => s.id === shortcutId)?.label || shortcutId;\n  };\n\n  // Load mobile shortcuts from Supabase\n  const loadMobileShortcuts = async () => {\n    try {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) return;\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('mobile_shortcuts')\n        .eq('id', user.id)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        return;\n      }\n\n      if (data?.mobile_shortcuts && typeof data.mobile_shortcuts === 'object') {\n        // Update workflow shortcuts with saved data\n        setWorkflowShortcuts((prev) =>\n          prev.map((workflow) => {\n            const shortcuts = data.mobile_shortcuts as Record<\n              string,\n              { enabled: boolean; shortcut: string }\n            >;\n            const saved = shortcuts[workflow.id];\n            return saved\n              ? {\n                  ...workflow,\n                  enabled: saved.enabled,\n                  shortcutSlot: saved.shortcut,\n                }\n              : workflow;\n          })\n        );\n      }\n    } catch (error) {\n      // TODO: handle error\n    }\n  };\n\n  // Save mobile shortcuts to Supabase\n  const saveMobileShortcuts = useCallback(async () => {\n    try {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) return;\n\n      // Convert workflow shortcuts to saveable format\n      const shortcutsToSave = workflowShortcuts.reduce(\n        (acc, workflow) => {\n          if (workflow.enabled && workflow.shortcutSlot) {\n            acc[workflow.id] = {\n              enabled: workflow.enabled,\n              shortcut: workflow.shortcutSlot,\n            };\n          }\n          return acc;\n        },\n        {} as Record<string, { enabled: boolean; shortcut: string }>\n      );\n\n      const { error } = await supabase\n        .from('users')\n        .update({\n          mobile_shortcuts: shortcutsToSave,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', user.id);\n\n      if (error) {\n      } else {\n      }\n    } catch (error) {\n      // TODO: handle error\n    }\n  }, [workflowShortcuts]);\n\n  // Load shortcuts on component mount\n  useEffect(() => {\n    loadMobileShortcuts();\n  }, []);\n\n  // Save shortcuts whenever they change\n  useEffect(() => {\n    if (workflowShortcuts.some((w) => w.enabled)) {\n      saveMobileShortcuts();\n    }\n  }, [workflowShortcuts, saveMobileShortcuts]);\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-6\">\n        <h5 className=\"text-md font-medium text-gray-700 mb-4\">\n          Mobile Scanner Shortcuts\n        </h5>\n        <p className=\"text-sm text-gray-600 mb-4\">\n          Configure up to 4 mobile shortcuts for quick access to your most-used\n          scanning workflows.\n        </p>\n\n        {/* Workflow Shortcuts Configuration */}\n        <div className=\"space-y-4\">\n          {workflowShortcuts.map((workflow) => (\n            <div\n              key={workflow.id}\n              className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg border border-gray-200\"\n            >\n              <div className=\"flex items-center space-x-3\">\n                <Icon\n                  path={workflow.icon}\n                  size={1.2}\n                  className=\"text-gray-600\"\n                />\n                <div>\n                  <p className=\"text-sm font-medium text-gray-700\">\n                    {workflow.name}\n                  </p>\n                  <p className=\"text-xs text-gray-500\">\n                    {workflow.description}\n                  </p>\n                </div>\n              </div>\n\n              <div className=\"flex items-center space-x-3\">\n                {/* Enable/Disable Toggle */}\n                <div className=\"flex items-center space-x-3\">\n                  <span className=\"text-sm text-gray-600\">Enable</span>\n                  <ToggleSwitch\n                    id={`toggle-${workflow.id}`}\n                    label={`Enable ${workflow.name}`}\n                    checked={workflow.enabled}\n                    onChange={(checked) =>\n                      handleWorkflowToggle(workflow.id, checked)\n                    }\n                  />\n                </div>\n\n                {/* Shortcut Slot Dropdown */}\n                {workflow.enabled && (\n                  <div className=\"space-y-2\">\n                    <select\n                      value={workflow.shortcutSlot || ''}\n                      onChange={(e) =>\n                        handleShortcutSlotChange(\n                          workflow.id,\n                          e.target.value ? e.target.value : null\n                        )\n                      }\n                      className={`px-3 py-1 border rounded text-sm ${\n                        !workflow.shortcutSlot\n                          ? 'border-red-300 bg-red-50'\n                          : 'border-gray-300'\n                      }`}\n                    >\n                      <option value=\"\">Select Shortcut</option>\n                      {[\n                        {\n                          id: 'volume-up',\n                          label: 'Volume Up (Single Press)',\n                          description: 'Press volume up button once',\n                        },\n                        {\n                          id: 'volume-down',\n                          label: 'Volume Down (Single Press)',\n                          description: 'Press volume down button once',\n                        },\n                        {\n                          id: 'volume-up-double',\n                          label: 'Volume Up (Double Press)',\n                          description: 'Press volume up button twice quickly',\n                        },\n                        {\n                          id: 'volume-down-double',\n                          label: 'Volume Down (Double Press)',\n                          description: 'Press volume down button twice quickly',\n                        },\n                        {\n                          id: 'power-double',\n                          label: 'Power Button (Double Press)',\n                          description: 'Press power button twice quickly',\n                        },\n                        {\n                          id: 'double-tap',\n                          label: 'Double Tap Screen',\n                          description: 'Tap screen twice quickly',\n                        },\n                        {\n                          id: 'shake',\n                          label: 'Shake Device',\n                          description: 'Shake your phone',\n                        },\n                        {\n                          id: 'flip',\n                          label: 'Flip Device',\n                          description: 'Turn phone face down',\n                        },\n                      ].map((shortcut) => (\n                        <option\n                          key={shortcut.id}\n                          value={shortcut.id}\n                          disabled={workflowShortcuts.some(\n                            (w) =>\n                              w.id !== workflow.id &&\n                              w.shortcutSlot === shortcut.id\n                          )}\n                        >\n                          {shortcut.label}\n                        </option>\n                      ))}\n                    </select>\n                    {!workflow.shortcutSlot && (\n                      <p className=\"text-xs text-red-500\">\n                        ‚ö†Ô∏è Please select a mobile shortcut or this workflow will\n                        be disabled in 5 seconds\n                      </p>\n                    )}\n                  </div>\n                )}\n              </div>\n            </div>\n          ))}\n        </div>\n\n        {/* Current Shortcuts Summary */}\n        <div className=\"mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n          <h6 className=\"text-sm font-medium text-blue-700 mb-3\">\n            Current Shortcuts\n          </h6>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3\">\n            {workflowShortcuts\n              .filter((w) => w.enabled && w.shortcutSlot)\n              .map((workflow) => (\n                <div key={workflow.id} className=\"text-center\">\n                  <div className=\"w-12 h-12 mx-auto mb-2 bg-blue-100 rounded-lg flex items-center justify-center\">\n                    <Icon\n                      path={workflow.icon}\n                      size={1.2}\n                      className=\"text-blue-600\"\n                    />\n                  </div>\n                  <p className=\"text-xs text-blue-700 font-medium\">\n                    {workflow.name}\n                  </p>\n                  <p className=\"text-xs text-blue-500\">\n                    {getShortcutLabel(workflow.shortcutSlot!)}\n                  </p>\n                </div>\n              ))}\n            {workflowShortcuts.filter((w) => w.enabled && w.shortcutSlot)\n              .length === 0 && (\n              <div className=\"col-span-2 md:col-span-4 text-center py-4\">\n                <p className=\"text-blue-500 text-sm\">\n                  No shortcuts configured yet\n                </p>\n                <p className=\"text-blue-400 text-xs\">\n                  Enable workflows and assign mobile shortcuts above\n                </p>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* How to Use Section */}\n        <div className=\"mt-6 p-4 bg-gray-50 rounded-lg border border-gray-200\">\n          <h6 className=\"text-sm font-medium text-gray-700 mb-3\">\n            How to Use Mobile Shortcuts\n          </h6>\n          <div className=\"text-sm text-gray-600 space-y-2\">\n            <p>\n              ‚Ä¢ <strong>Enable workflows:</strong> Use the toggles for scanning\n              workflows you use frequently\n            </p>\n            <p>\n              ‚Ä¢ <strong>Assign shortcuts:</strong> Choose mobile device actions\n              (volume buttons, double tap, shake, etc.)\n            </p>\n            <p>\n              ‚Ä¢ <strong>Mobile access:</strong> These shortcuts will trigger on\n              your mobile device for quick scanning\n            </p>\n            <p>\n              ‚Ä¢ <strong>Unique assignments:</strong> Each mobile shortcut can\n              only be used by one workflow\n            </p>\n            <p>\n              ‚Ä¢ <strong>Quick launch:</strong> Perform the assigned action to\n              directly open that scanner workflow\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\tabs\\PreferencesTab.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\components\\tabs\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\contexts\\SettingsContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useEnhancedPhotoUpload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useEnhancedProfileForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\usePhotoUpload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\usePreferencesForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useProfileAccountSettings.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 243,
        "column": 14,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 244,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [7902, 7909], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 258,
        "column": 14,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 259,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [8376, 8383], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 313,
        "column": 36,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 314,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [9993, 10002], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 314,
        "column": 16,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 315,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [10010, 10019], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect } from 'react';\nimport { supabase } from '../../../lib/supabaseClient';\nimport { useUser } from '../../../contexts/UserContext';\nimport {\n  UserProfileData,\n  BasicInformationFormData,\n  SecurityFormData,\n  PreferencesFormData,\n  LearningProfileFormData,\n} from '../types/UserProfileTypes';\n\nexport const useProfileAccountSettings = () => {\n  const { refreshUserData } = useUser();\n  const [userData, setUserData] = useState<UserProfileData | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [uploadingPhoto, setUploadingPhoto] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Form data for each tab\n  const [basicInfoForm, setBasicInfoForm] = useState<BasicInformationFormData>({\n    first_name: '',\n    last_name: '',\n    email: '',\n    phone: '',\n    department: '',\n    position: '',\n    date_of_birth: '',\n  });\n\n  const [securityForm, setSecurityForm] = useState<SecurityFormData>({\n    two_factor_enabled: false,\n    auto_logout_minutes: 30,\n  });\n\n  const [preferencesForm, setPreferencesForm] = useState<PreferencesFormData>({\n    default_module: 'Sterilization',\n    compliance_alert_frequency: 'Daily',\n    report_preferences: 'Detailed',\n    compact_layout: false,\n    show_quick_actions: true,\n  });\n\n  const [learningForm, setLearningForm] = useState<LearningProfileFormData>({\n    skill_level: 'Beginner',\n    time_availability: 120,\n    preferred_categories: ['Sterilization Procedures', 'Equipment Operation'],\n    learning_goals: '',\n  });\n\n  // Load user data from Supabase\n  const loadUserData = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('No authenticated user found');\n      }\n\n      const { data, error } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      setUserData({\n        id: String(data.id || ''),\n        email: String(data.email || ''),\n        full_name: String(data.full_name || ''),\n        phone: String(data.phone || ''),\n        department: String(data.department || ''),\n        position: String(data.position || ''),\n        avatar_url: String(data.avatar_url || ''),\n        preferences: (data.preferences as Record<string, unknown>) || {},\n        created_at: String(data.created_at || ''),\n        updated_at: String(data.updated_at || ''),\n      } as UserProfileData);\n\n      // Parse full_name into first and last name\n      const fullName = (data as { full_name?: string }).full_name || '';\n      const nameParts = fullName.split(' ');\n      const firstName = nameParts[0] || '';\n      const lastName = nameParts.slice(1).join(' ') || '';\n\n      // Set form data from user data\n      setBasicInfoForm({\n        first_name: firstName,\n        last_name: lastName,\n        email: (data as { email?: string }).email || '',\n        phone: (data as { phone?: string }).phone || '',\n        department: (data as { department?: string }).department || '',\n        position: (data as { position?: string }).position || '',\n        date_of_birth:\n          (data as { preferences?: { date_of_birth?: string } }).preferences\n            ?.date_of_birth || '',\n      });\n\n      // Set preferences from user preferences\n      const preferences =\n        (data as { preferences?: Record<string, unknown> }).preferences || {};\n      setSecurityForm({\n        two_factor_enabled:\n          (preferences as { two_factor_enabled?: boolean })\n            .two_factor_enabled || false,\n        auto_logout_minutes:\n          (preferences as { auto_logout_minutes?: number })\n            .auto_logout_minutes || 30,\n      });\n\n      setPreferencesForm({\n        default_module:\n          (preferences as { default_module?: string }).default_module ||\n          'Sterilization',\n        compliance_alert_frequency:\n          (preferences as { compliance_alert_frequency?: string })\n            .compliance_alert_frequency || 'Daily',\n        report_preferences:\n          (preferences as { report_preferences?: string }).report_preferences ||\n          'Detailed',\n        compact_layout:\n          (preferences as { compact_layout?: boolean }).compact_layout || false,\n        show_quick_actions:\n          (preferences as { show_quick_actions?: boolean })\n            .show_quick_actions !== false,\n      });\n\n      setLearningForm({\n        skill_level: ((preferences as { skill_level?: string }).skill_level ||\n          'Beginner') as 'Beginner' | 'Intermediate' | 'Advanced',\n        time_availability:\n          (preferences as { time_availability?: number }).time_availability ||\n          120,\n        preferred_categories: (\n          preferences as { preferred_categories?: string[] }\n        ).preferred_categories || [\n          'Sterilization Procedures',\n          'Equipment Operation',\n        ],\n        learning_goals:\n          (preferences as { learning_goals?: string }).learning_goals || '',\n      });\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load user data');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Upload profile photo\n  const uploadProfilePhoto = async (file: File) => {\n    if (!userData) {\n      return;\n    }\n\n    try {\n      setUploadingPhoto(true);\n      setError(null);\n\n      // Validate file\n      if (!file.type.startsWith('image/')) {\n        throw new Error('Please select an image file');\n      }\n\n      if (file.size > 2 * 1024 * 1024) {\n        // 2MB limit\n        throw new Error('File size must be less than 2MB');\n      }\n\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('No authenticated user found');\n      }\n\n      // Convert file to base64 data URL with size optimization\n      const reader = new FileReader();\n      const dataUrl = await new Promise<string>((resolve, reject) => {\n        reader.onload = () => {\n          const result = reader.result as string;\n\n          // If the data URL is too large, try to compress it\n          if (result.length > 100000) {\n            // 100KB limit\n            const img = new Image();\n            img.onload = () => {\n              const canvas = document.createElement('canvas');\n              const ctx = canvas.getContext('2d');\n\n              // Resize to reasonable dimensions\n              const maxSize = 200;\n              let { width, height } = img;\n              if (width > height) {\n                if (width > maxSize) {\n                  height = (height * maxSize) / width;\n                  width = maxSize;\n                }\n              } else {\n                if (height > maxSize) {\n                  width = (width * maxSize) / height;\n                  height = maxSize;\n                }\n              }\n\n              canvas.width = width;\n              canvas.height = height;\n              ctx?.drawImage(img, 0, 0, width, height);\n\n              const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);\n              resolve(compressedDataUrl);\n            };\n            img.onerror = () => resolve(result); // Fallback to original\n            img.src = result;\n          } else {\n            resolve(result);\n          }\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(file);\n      });\n\n      // Update user profile with base64 avatar data\n\n      // Test if we can update any field first\n      const { error: testError } = await supabase\n        .from('users')\n        .update({\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', user.id);\n\n      if (testError) {\n        console.error('Basic update test failed:', testError);\n        throw testError;\n      } else {\n      }\n\n      // Test with a simple string first to see if avatar_url field can be updated\n      const { error: simpleTestError } = await supabase\n        .from('users')\n        .update({\n          avatar_url: 'test-simple-avatar-url',\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', user.id);\n\n      if (simpleTestError) {\n        console.error('Simple avatar_url test failed:', simpleTestError);\n        throw simpleTestError;\n      } else {\n      }\n\n      // Now try the actual avatar update\n\n      // Check if dataUrl is valid\n      if (!dataUrl.startsWith('data:image/')) {\n        console.error('Invalid data URL format:', dataUrl.substring(0, 100));\n        throw new Error('Invalid image data format');\n      }\n\n      const { error: updateError } = await supabase\n        .from('users')\n        .update({\n          avatar_url: dataUrl,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', user.id);\n\n      if (updateError) {\n        console.error('Database update error:', updateError);\n        console.error(\n          'Error details:',\n          updateError.message,\n          updateError.details,\n          updateError.hint\n        );\n        throw updateError;\n      }\n\n      // For now, trust the update response and proceed with local state update\n\n      // Update local state immediately\n      if (userData) {\n        setUserData({\n          ...userData,\n          avatar_url: dataUrl,\n          updated_at: new Date().toISOString(),\n        });\n      }\n\n      // Add a small delay to ensure database transaction is committed\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      // Verify the update worked by querying the database\n      const { data: verifyData, error: verifyError } = await supabase\n        .from('users')\n        .select('avatar_url')\n        .eq('id', user.id)\n        .single();\n\n      if (verifyError) {\n        console.error('Verification error:', verifyError);\n      } else {\n        console.log('Database verification result:', verifyData);\n        if (verifyData.avatar_url) {\n        } else {\n        }\n      }\n\n      // Refresh user context to update avatar in navigation\n      await refreshUserData();\n    } catch (err) {\n      console.error('Photo upload error:', err);\n      setError(err instanceof Error ? err.message : 'Failed to upload photo');\n    } finally {\n      setUploadingPhoto(false);\n    }\n  };\n\n  // Remove profile photo\n  const removeProfilePhoto = async () => {\n    if (!userData || !userData.avatar_url) return;\n\n    try {\n      setUploadingPhoto(true);\n      setError(null);\n\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('No authenticated user found');\n      }\n\n      // Update user profile to remove avatar URL\n      const { error: updateError } = await supabase\n        .from('users')\n        .update({\n          avatar_url: null,\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', user.id);\n\n      if (updateError) {\n        throw updateError;\n      }\n\n      // Update local state immediately\n      setUserData({\n        ...userData,\n        avatar_url: null,\n        updated_at: new Date().toISOString(),\n      });\n\n      // Refresh user context to update avatar in navigation\n      await refreshUserData();\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to remove photo');\n    } finally {\n      setUploadingPhoto(false);\n    }\n  };\n\n  // Save basic information\n  const saveBasicInformation = async () => {\n    if (!userData) return;\n\n    try {\n      setSaving(true);\n      setError(null);\n\n      const fullName =\n        `${basicInfoForm.first_name} ${basicInfoForm.last_name}`.trim();\n\n      const { error } = await supabase\n        .from('users')\n        .update({\n          full_name: fullName,\n          email: basicInfoForm.email,\n          phone: basicInfoForm.phone,\n          department: basicInfoForm.department,\n          position: basicInfoForm.position,\n          preferences: {\n            ...userData.preferences,\n            date_of_birth: basicInfoForm.date_of_birth,\n          },\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userData.id);\n\n      if (error) {\n        throw error;\n      }\n\n      // Update local state instead of reloading\n      setUserData({\n        ...userData,\n        full_name: fullName,\n        email: basicInfoForm.email,\n        phone: basicInfoForm.phone,\n        department: basicInfoForm.department,\n        position: basicInfoForm.position,\n        preferences: {\n          ...userData.preferences,\n          date_of_birth: basicInfoForm.date_of_birth,\n        },\n        updated_at: new Date().toISOString(),\n      });\n\n      // Refresh user context to update navigation\n      await refreshUserData();\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : 'Failed to save basic information'\n      );\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  // Save security settings\n  const saveSecuritySettings = async () => {\n    if (!userData) return;\n\n    try {\n      setSaving(true);\n      setError(null);\n\n      const { error } = await supabase\n        .from('users')\n        .update({\n          preferences: {\n            ...userData.preferences,\n            two_factor_enabled: securityForm.two_factor_enabled,\n            auto_logout_minutes: securityForm.auto_logout_minutes,\n          },\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userData.id);\n\n      if (error) {\n        throw error;\n      }\n\n      // Update local state instead of reloading\n      setUserData({\n        ...userData,\n        preferences: {\n          ...userData.preferences,\n          two_factor_enabled: securityForm.two_factor_enabled,\n          auto_logout_minutes: securityForm.auto_logout_minutes,\n        },\n        updated_at: new Date().toISOString(),\n      });\n\n      // Refresh user context to update navigation\n      await refreshUserData();\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : 'Failed to save security settings'\n      );\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  // Save preferences\n  const savePreferences = async () => {\n    if (!userData) return;\n\n    try {\n      setSaving(true);\n      setError(null);\n\n      const { error } = await supabase\n        .from('users')\n        .update({\n          preferences: {\n            ...userData.preferences,\n            default_module: preferencesForm.default_module,\n            compliance_alert_frequency:\n              preferencesForm.compliance_alert_frequency,\n            report_preferences: preferencesForm.report_preferences,\n            compact_layout: preferencesForm.compact_layout,\n            show_quick_actions: preferencesForm.show_quick_actions,\n          },\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userData.id);\n\n      if (error) {\n        throw error;\n      }\n\n      // Update local state instead of reloading\n      setUserData({\n        ...userData,\n        preferences: {\n          ...userData.preferences,\n          default_module: preferencesForm.default_module,\n          compliance_alert_frequency:\n            preferencesForm.compliance_alert_frequency,\n          report_preferences: preferencesForm.report_preferences,\n          compact_layout: preferencesForm.compact_layout,\n          show_quick_actions: preferencesForm.show_quick_actions,\n        },\n        updated_at: new Date().toISOString(),\n      });\n\n      // Refresh user context to update navigation\n      await refreshUserData();\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : 'Failed to save preferences'\n      );\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  // Save learning profile\n  const saveLearningProfile = async () => {\n    if (!userData) return;\n\n    try {\n      setSaving(true);\n      setError(null);\n\n      const { error } = await supabase\n        .from('users')\n        .update({\n          preferences: {\n            ...userData.preferences,\n            skill_level: learningForm.skill_level,\n            time_availability: learningForm.time_availability,\n            preferred_categories: JSON.stringify(\n              learningForm.preferred_categories\n            ),\n            learning_goals: learningForm.learning_goals,\n          },\n          updated_at: new Date().toISOString(),\n        })\n        .eq('id', userData.id);\n\n      if (error) {\n        throw error;\n      }\n\n      // Update local state instead of reloading\n      setUserData({\n        ...userData,\n        preferences: {\n          ...userData.preferences,\n          skill_level: learningForm.skill_level,\n          time_availability: learningForm.time_availability,\n          preferred_categories: JSON.stringify(\n            learningForm.preferred_categories\n          ),\n          learning_goals: learningForm.learning_goals,\n        },\n        updated_at: new Date().toISOString(),\n      });\n\n      // Refresh user context to update navigation\n      await refreshUserData();\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : 'Failed to save learning profile'\n      );\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  // Load data on component mount\n  useEffect(() => {\n    loadUserData();\n  }, []);\n\n  return {\n    // State\n    userData,\n    loading,\n    saving,\n    uploadingPhoto,\n    error,\n    basicInfoForm,\n    securityForm,\n    preferencesForm,\n    learningForm,\n\n    // Actions\n    setBasicInfoForm,\n    setSecurityForm,\n    setPreferencesForm,\n    setLearningForm,\n    uploadProfilePhoto,\n    removeProfilePhoto,\n    saveBasicInformation,\n    saveSecuritySettings,\n    savePreferences,\n    saveLearningProfile,\n    loadUserData,\n    setError,\n    setUserData,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useProfileForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useUserData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useUserProfile.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'passwordData' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 121,
        "column": 39,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 121,
        "endColumn": 51
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect } from 'react';\nimport { supabase } from '../../../lib/supabaseClient';\nimport { useUser } from '../../../contexts/UserContext';\nimport {\n  UserProfileData,\n  BasicInformationFormData,\n  PasswordData,\n  SecurityFormData,\n} from '../types/UserProfileTypes';\nimport {\n  getDefaultUserData,\n  getDefaultFormData,\n  getDefaultPasswordData,\n} from '../utils/userProfileUtils';\n\nexport const useUserProfile = () => {\n  const { currentUser, refreshUserData } = useUser();\n  const [isEditing, setIsEditing] = useState(false);\n  const [showPasswordModal, setShowPasswordModal] = useState(false);\n  const [showDeleteModal, setShowDeleteModal] = useState(false);\n  const [showPassword, setShowPassword] = useState(false);\n  const [showConfirmPassword, setShowConfirmPassword] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // User data from auth system\n  const [userData, setUserData] =\n    useState<UserProfileData>(getDefaultUserData());\n\n  const [formData, setFormData] = useState<BasicInformationFormData>(\n    getDefaultFormData(userData)\n  );\n\n  const [passwordData, setPasswordData] = useState<PasswordData>(\n    getDefaultPasswordData()\n  );\n\n  // Security settings state\n  const [securityData, setSecurityData] = useState<SecurityFormData>({\n    two_factor_enabled: false,\n    auto_logout_minutes: 30,\n  });\n\n  // Load user data and security settings\n  useEffect(() => {\n    const loadUserData = async () => {\n      if (!currentUser) return;\n\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Load user profile data\n        const { data: profileData, error: profileError } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', currentUser.id)\n          .single();\n\n        if (profileError) {\n          throw profileError;\n        }\n\n        if (profileData) {\n          setUserData(profileData as unknown as UserProfileData);\n          setFormData(\n            getDefaultFormData(profileData as unknown as UserProfileData)\n          );\n        }\n\n        // Load security settings\n        const { data: securitySettings, error: securityError } = await supabase\n          .from('user_security_settings')\n          .select('two_factor_enabled, auto_logout_minutes')\n          .eq('user_id', currentUser.id)\n          .single();\n\n        if (securityError && securityError.code !== 'PGRST116') {\n          // PGRST116 is \"not found\" - we'll create default settings\n          throw securityError;\n        }\n\n        if (securitySettings) {\n          setSecurityData({\n            two_factor_enabled:\n              Boolean(securitySettings.two_factor_enabled) || false,\n            auto_logout_minutes:\n              Number(securitySettings.auto_logout_minutes) || 30,\n          });\n        }\n      } catch (err) {\n        setError(\n          err instanceof Error ? err.message : 'Failed to load user data'\n        );\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadUserData();\n  }, [currentUser]);\n\n  const handleSave = () => {\n    setUserData((prev) => ({\n      ...prev,\n      full_name: `${formData.first_name} ${formData.last_name}`.trim(),\n      email: formData.email,\n      phone: formData.phone,\n      department: formData.department,\n      position: formData.position,\n    }));\n    setIsEditing(false);\n  };\n\n  const handleCancel = () => {\n    setFormData(getDefaultFormData(userData));\n    setIsEditing(false);\n  };\n\n  const handlePasswordChange = async (passwordData: {\n    currentPassword: string;\n    newPassword: string;\n    confirmPassword: string;\n  }) => {\n    // Implement password change logic\n    try {\n      // TODO: Implement actual password change logic // TRACK: Migrate to GitHub issue\n      setShowPasswordModal(false);\n      setPasswordData(getDefaultPasswordData());\n    } catch (error) {\n      console.error('Password change failed:', error);\n    }\n  };\n\n  const handleDeleteAccount = () => {\n    // Implement account deletion logic\n    setShowDeleteModal(false);\n  };\n\n  const handleNotificationChange = (key: string, value: boolean) => {\n    setUserData((prev) => ({ ...prev, [key]: value }));\n  };\n\n  const handleTwoFactorToggle = async () => {\n    if (!currentUser) return;\n\n    try {\n      setSaving(true);\n      setError(null);\n\n      const newTwoFactorEnabled = !securityData.two_factor_enabled;\n\n      // Check if user has existing security settings\n      const { data: existingSettings } = await supabase\n        .from('user_security_settings')\n        .select('id')\n        .eq('user_id', currentUser.id)\n        .single();\n\n      if (existingSettings) {\n        // Update existing settings\n        const { error } = await supabase\n          .from('user_security_settings')\n          .update({\n            two_factor_enabled: newTwoFactorEnabled,\n            updated_at: new Date().toISOString(),\n          })\n          .eq('user_id', currentUser.id);\n\n        if (error) {\n          throw error;\n        }\n      } else {\n        // Create new security settings record\n        const { error } = await supabase.from('user_security_settings').insert({\n          user_id: currentUser.id,\n          two_factor_enabled: newTwoFactorEnabled,\n          session_timeout: 480, // 8 hours default\n          inactive_timeout: 30, // 30 minutes default\n          remember_me_duration: 7, // 7 days default\n          require_reauth_for_sensitive: true,\n        });\n\n        if (error) {\n          throw error;\n        }\n      }\n\n      // Update local state\n      setSecurityData((prev) => ({\n        ...prev,\n        two_factor_enabled: newTwoFactorEnabled,\n      }));\n\n      // Refresh user context\n      await refreshUserData();\n    } catch (err) {\n      setError(\n        err instanceof Error ? err.message : 'Failed to update 2FA settings'\n      );\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const handleForceLogout = () => {\n    // Implement force logout logic\n  };\n\n  const handleFormDataChange = (data: BasicInformationFormData) => {\n    setFormData(data);\n  };\n\n  const handlePasswordDataChange = (data: PasswordData) => {\n    setPasswordData(data);\n  };\n\n  const handleShowPasswordToggle = () => {\n    setShowPassword(!showPassword);\n  };\n\n  const handleShowConfirmPasswordToggle = () => {\n    setShowConfirmPassword(!showConfirmPassword);\n  };\n\n  return {\n    // State\n    isEditing,\n    showPasswordModal,\n    showDeleteModal,\n    showPassword,\n    showConfirmPassword,\n    userData,\n    formData,\n    passwordData,\n    securityData,\n    loading,\n    saving,\n    error,\n\n    // Actions\n    setIsEditing,\n    setShowPasswordModal,\n    setShowDeleteModal,\n    setShowPassword,\n    setShowConfirmPassword,\n    handleSave,\n    handleCancel,\n    handlePasswordChange,\n    handleDeleteAccount,\n    handleNotificationChange,\n    handleTwoFactorToggle,\n    handleForceLogout,\n    handleFormDataChange,\n    handlePasswordDataChange,\n    handleShowPasswordToggle,\n    handleShowConfirmPasswordToggle,\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\hooks\\useValidatedForm.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\index.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\services\\errorHandlingService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 275,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 275,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Error types\nexport interface AppError {\n  code: string;\n  message: string;\n  details?: string;\n  timestamp: Date;\n  context?: Record<string, unknown>;\n}\n\nexport interface ErrorHandlingOptions {\n  showNotification?: boolean;\n  logToConsole?: boolean;\n  retryable?: boolean;\n  fallbackValue?: unknown;\n}\n\n// Error codes\nexport const ERROR_CODES = {\n  // Authentication errors\n  AUTH_REQUIRED: 'AUTH_REQUIRED',\n  AUTH_EXPIRED: 'AUTH_EXPIRED',\n  AUTH_INVALID: 'AUTH_INVALID',\n\n  // Network errors\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n  CONNECTION_ERROR: 'CONNECTION_ERROR',\n\n  // Database errors\n  DB_CONNECTION_ERROR: 'DB_CONNECTION_ERROR',\n  DB_QUERY_ERROR: 'DB_QUERY_ERROR',\n  DB_CONSTRAINT_ERROR: 'DB_CONSTRAINT_ERROR',\n\n  // File upload errors\n  FILE_TOO_LARGE: 'FILE_TOO_LARGE',\n  FILE_TYPE_INVALID: 'FILE_TYPE_INVALID',\n  UPLOAD_FAILED: 'UPLOAD_FAILED',\n\n  // Validation errors\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  REQUIRED_FIELD_MISSING: 'REQUIRED_FIELD_MISSING',\n  INVALID_FORMAT: 'INVALID_FORMAT',\n\n  // Permission errors\n  PERMISSION_DENIED: 'PERMISSION_DENIED',\n  INSUFFICIENT_PRIVILEGES: 'INSUFFICIENT_PRIVILEGES',\n\n  // General errors\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n  OPERATION_FAILED: 'OPERATION_FAILED',\n} as const;\n\n// Error messages\nexport const ERROR_MESSAGES = {\n  [ERROR_CODES.AUTH_REQUIRED]: 'Please log in to continue',\n  [ERROR_CODES.AUTH_EXPIRED]: 'Your session has expired. Please log in again',\n  [ERROR_CODES.AUTH_INVALID]: 'Invalid authentication credentials',\n\n  [ERROR_CODES.NETWORK_ERROR]: 'Network error. Please check your connection',\n  [ERROR_CODES.TIMEOUT_ERROR]: 'Request timed out. Please try again',\n  [ERROR_CODES.CONNECTION_ERROR]: 'Unable to connect to the server',\n\n  [ERROR_CODES.DB_CONNECTION_ERROR]: 'Database connection error',\n  [ERROR_CODES.DB_QUERY_ERROR]: 'Database query error',\n  [ERROR_CODES.DB_CONSTRAINT_ERROR]: 'Data validation error',\n\n  [ERROR_CODES.FILE_TOO_LARGE]: 'File is too large. Maximum size is 5MB',\n  [ERROR_CODES.FILE_TYPE_INVALID]:\n    'Invalid file type. Please use JPG, PNG, or GIF',\n  [ERROR_CODES.UPLOAD_FAILED]: 'File upload failed. Please try again',\n\n  [ERROR_CODES.VALIDATION_ERROR]: 'Please check your input and try again',\n  [ERROR_CODES.REQUIRED_FIELD_MISSING]: 'Required field is missing',\n  [ERROR_CODES.INVALID_FORMAT]: 'Invalid format',\n\n  [ERROR_CODES.PERMISSION_DENIED]:\n    'You do not have permission to perform this action',\n  [ERROR_CODES.INSUFFICIENT_PRIVILEGES]:\n    'Insufficient privileges for this operation',\n\n  [ERROR_CODES.UNKNOWN_ERROR]: 'An unexpected error occurred',\n  [ERROR_CODES.OPERATION_FAILED]: 'Operation failed. Please try again',\n} as const;\n\n// Error handling service\nexport class ErrorHandlingService {\n  private static instance: ErrorHandlingService;\n  private errorLog: AppError[] = [];\n  private maxErrorLogSize = 100;\n\n  private constructor() {}\n\n  public static getInstance(): ErrorHandlingService {\n    if (!ErrorHandlingService.instance) {\n      ErrorHandlingService.instance = new ErrorHandlingService();\n    }\n    return ErrorHandlingService.instance;\n  }\n\n  // Create a standardized error object\n  createError(\n    code: keyof typeof ERROR_CODES,\n    message?: string,\n    details?: string,\n    context?: Record<string, unknown>\n  ): AppError {\n    const error: AppError = {\n      code: ERROR_CODES[code],\n      message: message || ERROR_MESSAGES[code],\n      details,\n      timestamp: new Date(),\n      context,\n    };\n\n    this.logError(error);\n    return error;\n  }\n\n  // Handle different types of errors\n  handleError(error: unknown, options: ErrorHandlingOptions = {}): AppError {\n    const { showNotification = true, logToConsole = true } = options;\n\n    let appError: AppError;\n\n    if (this.isAppError(error)) {\n      appError = error;\n    } else if (this.isSupabaseError(error)) {\n      // Type guard to ensure error has required properties\n      if (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        'details' in error\n      ) {\n        appError = this.convertSupabaseError(\n          error as { message?: string; details?: string; code?: string }\n        );\n      } else {\n        appError = this.createError('UNKNOWN_ERROR', 'Database error occurred');\n      }\n    } else if (this.isNetworkError(error)) {\n      appError = this.createError('NETWORK_ERROR', 'Network error occurred');\n    } else {\n      appError = this.createError(\n        'UNKNOWN_ERROR',\n        'An unexpected error occurred'\n      );\n    }\n\n    // Log to console if requested\n    if (logToConsole) {\n      console.error('Error handled:', appError);\n    }\n\n    // Show notification if requested\n    if (showNotification) {\n      this.showErrorNotification(appError);\n    }\n\n    return appError;\n  }\n\n  // Check if error is retryable\n  isRetryableError(error: AppError): boolean {\n    const retryableCodes = [\n      ERROR_CODES.NETWORK_ERROR,\n      ERROR_CODES.TIMEOUT_ERROR,\n      ERROR_CODES.CONNECTION_ERROR,\n      ERROR_CODES.DB_CONNECTION_ERROR,\n    ] as const;\n\n    return retryableCodes.includes(\n      error.code as (typeof retryableCodes)[number]\n    );\n  }\n\n  // Get user-friendly error message\n  getUserFriendlyMessage(error: AppError): string {\n    return error.message;\n  }\n\n  // Get technical error details for debugging\n  getTechnicalDetails(error: AppError): string {\n    return `${error.code}: ${error.message}${error.details ? ` - ${error.details}` : ''}`;\n  }\n\n  // Log error to internal log\n  private logError(error: AppError): void {\n    this.errorLog.push(error);\n\n    // Keep log size manageable\n    if (this.errorLog.length > this.maxErrorLogSize) {\n      this.errorLog = this.errorLog.slice(-this.maxErrorLogSize);\n    }\n  }\n\n  // Get error log\n  getErrorLog(): AppError[] {\n    return [...this.errorLog];\n  }\n\n  // Clear error log\n  clearErrorLog(): void {\n    this.errorLog = [];\n  }\n\n  // Check if error is AppError\n  private isAppError(error: unknown): error is AppError {\n    return (\n      typeof error === 'object' &&\n      error !== null &&\n      'code' in error &&\n      'message' in error &&\n      'timestamp' in error\n    );\n  }\n\n  // Check if error is Supabase error\n  private isSupabaseError(error: unknown): boolean {\n    return (\n      typeof error === 'object' &&\n      error !== null &&\n      'message' in error &&\n      'details' in error\n    );\n  }\n\n  // Convert Supabase error to AppError\n  private convertSupabaseError(error: {\n    message?: string;\n    details?: string;\n    code?: string;\n  }): AppError {\n    let code: keyof typeof ERROR_CODES = 'UNKNOWN_ERROR';\n    let message = error.message || 'Database error occurred';\n    const details = error.details || '';\n\n    // Map Supabase error codes to our error codes\n    if (error.code === 'PGRST116') {\n      code = 'AUTH_REQUIRED';\n      message = 'Authentication required';\n    } else if (error.code === 'PGRST301') {\n      code = 'PERMISSION_DENIED';\n      message = 'Permission denied';\n    } else if (error.code === '23505') {\n      code = 'DB_CONSTRAINT_ERROR';\n      message = 'Data already exists';\n    } else if (error.code === '23503') {\n      code = 'DB_CONSTRAINT_ERROR';\n      message = 'Referenced data not found';\n    }\n\n    return this.createError(code, message, details);\n  }\n\n  // Check if error is network error\n  private isNetworkError(error: unknown): boolean {\n    if (error instanceof Error) {\n      const networkErrorMessages = [\n        'network error',\n        'fetch failed',\n        'connection refused',\n        'timeout',\n        'aborted',\n      ];\n\n      return networkErrorMessages.some((msg) =>\n        error.message.toLowerCase().includes(msg)\n      );\n    }\n    return false;\n  }\n\n  // Show error notification (placeholder - would integrate with notification system)\n  private showErrorNotification(error: AppError): void {\n    // This would integrate with your notification system\n    // For now, we'll just log it\n  }\n\n  // Retry operation with optimized retry logic\n  async retryOperation<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n    baseDelay: number = 100\n  ): Promise<T> {\n    const { OptimizedRetryService } = await import(\n      '@/services/retry/OptimizedRetryService'\n    );\n\n    const result = await OptimizedRetryService.executeWithRetry(operation, {\n      maxRetries,\n      baseDelay,\n      backoffStrategy: 'linear',\n      retryCondition: (error) => this.isRetryableError(error as AppError),\n    });\n\n    if (!result.success) {\n      throw this.handleError(result.error!, { showNotification: false });\n    }\n\n    return result.data!;\n  }\n\n  // Handle async operations with error handling\n  async safeExecute<T>(\n    operation: () => Promise<T>,\n    options: ErrorHandlingOptions = {}\n  ): Promise<{ success: boolean; data?: T; error?: AppError }> {\n    try {\n      const data = await operation();\n      return { success: true, data };\n    } catch (error) {\n      const appError = this.handleError(error, options);\n      return { success: false, error: appError };\n    }\n  }\n}\n\n// Export singleton instance\nexport const errorHandlingService = ErrorHandlingService.getInstance();\n\n// Utility functions\nexport function createError(\n  code: keyof typeof ERROR_CODES,\n  message?: string,\n  details?: string,\n  context?: Record<string, unknown>\n): AppError {\n  return errorHandlingService.createError(code, message, details, context);\n}\n\nexport function handleError(\n  error: unknown,\n  options?: ErrorHandlingOptions\n): AppError {\n  return errorHandlingService.handleError(error, options);\n}\n\nexport function safeExecute<T>(\n  operation: () => Promise<T>,\n  options?: ErrorHandlingOptions\n): Promise<{ success: boolean; data?: T; error?: AppError }> {\n  return errorHandlingService.safeExecute(operation, options);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\services\\settingsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\types\\UserProfileTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\utils\\formValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Settings\\utils\\userProfileUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\ScannerPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\Sterilization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\components\\SterilizationDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\components\\SterilizationErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\config\\workflowConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\hooks\\useSterilizationWorkflow.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\services\\sterilizationWorkflowService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\types\\sterilizationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\Sterilization\\utils\\sterilizationUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\components\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\constants\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\providers\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\pages\\library\\utils\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\providers\\GlobalBIFailureProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ConsoleNotificationChannel.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\PerformanceAlertingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\PerformanceAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\PerformanceMonitoringIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ServiceAccess.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ServiceConsolidator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ServicePerformanceMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ServiceRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\SterilizationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\__tests__\\tableService.integration.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\realtimeAutoOptimizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\realtimeCompatibility.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\realtimeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\realtimeOptimizer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'percentage' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 116,
        "column": 38,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 116,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 139,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 139,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'status' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 140,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 140,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'stats' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 172,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 172,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { RealtimeManager } from './realtimeManager';\n\nexport interface RealtimeOptimizationConfig {\n  maxChannels: number;\n  maxSubscribersPerTable: number;\n  cleanupInterval: number;\n  subscriptionTimeout: number;\n}\n\nimport { logger } from '../../utils/_core/logger';\n\nexport class RealtimeOptimizer {\n  private static cleanupInterval: NodeJS.Timeout | null = null;\n  private static isOptimizing = false;\n  // Reduced cleanup intervals for better performance\n  private static aggressiveCleanupInterval = 60000; // 60 seconds for aggressive mode\n  private static standardCleanupInterval = 120000; // 120 seconds for standard mode\n\n  /**\n   * Auto-start optimization when service is imported - DISABLED for performance\n   */\n  static {\n    // DISABLED: Auto-start causes excessive background processing\n    // setTimeout(() => {\n    //   logger.realtime('üöÄ Auto-starting CRITICAL realtime optimization...');\n    //   this.startOptimization();\n    // }, 2000);\n  }\n\n  /**\n   * Start automatic optimization with CRITICAL performance focus\n   */\n  static startOptimization(config: Partial<RealtimeOptimizationConfig> = {}) {\n    if (this.isOptimizing) {\n      logger.realtime('üîÑ Realtime optimization already running');\n      return;\n    }\n\n    this.isOptimizing = true;\n    // CRITICAL: Use aggressive interval by default\n    const interval = config.cleanupInterval || this.aggressiveCleanupInterval;\n\n    this.cleanupInterval = setInterval(() => {\n      this.performOptimization();\n    }, interval);\n\n    logger.realtime(\n      `üöÄ Started CRITICAL realtime optimization (interval: ${interval}ms)`\n    );\n  }\n\n  /**\n   * Stop automatic optimization\n   */\n  static stopOptimization() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    this.isOptimizing = false;\n    logger.realtime('‚èπÔ∏è Stopped realtime optimization');\n  }\n\n  /**\n   * Perform CRITICAL optimization cycle\n   */\n  private static performOptimization() {\n    try {\n      const stats = RealtimeManager.getStats();\n\n      // CRITICAL: Immediate aggressive cleanup for poor performance\n      if (!stats.performance.isHealthy) {\n        this.emergencyCleanup();\n        return;\n      }\n\n      // CRITICAL: Aggressive cleanup if approaching limits\n      if (stats.activeChannels > 3) {\n        // Reduced threshold from 8 to 3\n        this.aggressiveCleanup();\n        return;\n      }\n\n      // CRITICAL: Standard cleanup for normal conditions\n      if (stats.activeChannels > 2) {\n        // Reduced threshold from 8 to 2\n        this.standardCleanup();\n      }\n\n      // Log optimization results\n      this.logOptimizationResults(stats);\n    } catch (error) {\n      console.error('‚ùå Error during realtime optimization:', error);\n    }\n  }\n\n  /**\n   * CRITICAL: Standard cleanup for normal conditions\n   */\n  private static standardCleanup() {\n    // Trigger cleanup in RealtimeManager\n    // This will be handled by the existing cleanup mechanisms\n  }\n\n  /**\n   * CRITICAL: Aggressive cleanup for high channel counts\n   */\n  private static aggressiveCleanup() {\n    // Force cleanup of 50% of subscriptions\n    this.forcePartialCleanup(0.5);\n  }\n\n  /**\n   * CRITICAL: Force partial cleanup to maintain performance\n   */\n  private static forcePartialCleanup(percentage: number) {\n    // This will trigger the force cleanup in RealtimeManager\n    // by temporarily exceeding the channel limit\n    const stats = RealtimeManager.getStats();\n    if (stats.activeChannels > 0) {\n      // Force a cleanup cycle\n      RealtimeManager.cleanup();\n    }\n  }\n\n  /**\n   * Log optimization results with CRITICAL performance indicators\n   */\n  private static logOptimizationResults(stats: {\n    activeChannels: number;\n    totalSubscribers: number;\n    tableSubscribers: Record<string, number>;\n    performance: {\n      isHealthy: boolean;\n      warnings: string[];\n      recommendations: string[];\n    };\n  }) {\n    const timestamp = new Date().toISOString();\n    const status =\n      stats.activeChannels <= 2\n        ? '‚úÖ'\n        : stats.activeChannels <= 3\n          ? '‚ö†Ô∏è'\n          : 'üö®';\n\n    // CRITICAL: Immediate action for high counts\n    if (stats.activeChannels > 3) {\n      setTimeout(() => this.performOptimization(), 5000); // Cleanup in 5 seconds\n    }\n  }\n\n  /**\n   * Get optimization status\n   */\n  static getStatus() {\n    return {\n      isRunning: this.isOptimizing,\n      interval: this.cleanupInterval ? 'active' : 'inactive',\n      mode: this.cleanupInterval ? 'aggressive' : 'inactive',\n    };\n  }\n\n  /**\n   * CRITICAL: Emergency cleanup for critical situations\n   */\n  static emergencyCleanup() {\n    RealtimeManager.cleanup();\n\n    // Wait and verify\n    setTimeout(() => {\n      const stats = RealtimeManager.getStats();\n    }, 500);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\simpleRealtimeAutoOptimizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\simpleRealtimeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\_core\\simpleRealtimeOptimizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\adminTaskConfigService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiChallengeGenerationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiCostCalculationService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 154,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\n\ninterface AITask {\n  id: string;\n  completed_at: string;\n  time_saved?: number;\n  actual_duration: number;\n  estimated_duration?: number;\n  difficulty?: string;\n  efficiency_score?: number;\n}\n\ninterface FacilityCosts {\n  hourlyRate: number;\n  facilityType: string;\n  staffCount: number;\n}\n\nexport interface AIImpactMetrics {\n  timeSavings: {\n    daily: number;\n    weekly: number;\n    monthly: number;\n    total: number;\n    percentage: number;\n  };\n  proactiveManagement: {\n    issuesPrevented: number;\n    earlyInterventions: number;\n    complianceScore: number;\n    riskMitigation: number;\n    predictiveAccuracy: number;\n  };\n  costSavings: {\n    daily: number;\n    monthly: number;\n    annual: number;\n    roi: number;\n  };\n  efficiencyGains: {\n    taskCompletionRate: number;\n    qualityImprovement: number;\n    resourceOptimization: number;\n    workflowStreamlining: number;\n  };\n  realTimeUpdates: {\n    updated_at: string;\n    nextUpdate: string;\n    dataFreshness: number; // Minutes since last data refresh\n  };\n}\n\nexport class AICostCalculationService {\n  /**\n   * Calculate comprehensive cost savings with AI-driven insights\n   */\n  async calculateCostSavings(\n    timeSavings: AIImpactMetrics['timeSavings'],\n    aiTasks: AITask[]\n  ): Promise<AIImpactMetrics['costSavings']> {\n    try {\n      // Get facility-specific cost data\n      const facilityCosts = await this.getFacilityCosts();\n\n      // Calculate direct time savings (staff cost)\n      const directTimeSavings = this.calculateDirectTimeSavings(\n        timeSavings,\n        facilityCosts.hourlyRate\n      );\n\n      // Calculate indirect cost savings from AI efficiency\n      const indirectSavings = await this.calculateIndirectCostSavings(\n        aiTasks,\n        facilityCosts\n      );\n\n      // Calculate error prevention savings\n      const errorPreventionSavings = await this.calculateErrorPreventionSavings(\n        aiTasks,\n        facilityCosts\n      );\n\n      // Calculate compliance and risk mitigation savings\n      const complianceSavings = await this.calculateComplianceSavings();\n\n      // Calculate resource optimization savings\n      const resourceSavings = await this.calculateResourceOptimizationSavings();\n\n      // Total daily savings\n      const dailySavings =\n        directTimeSavings.daily +\n        indirectSavings.daily +\n        errorPreventionSavings.daily +\n        complianceSavings.daily +\n        resourceSavings.daily;\n\n      // Total monthly savings\n      const monthlySavings =\n        directTimeSavings.monthly +\n        indirectSavings.monthly +\n        errorPreventionSavings.monthly +\n        complianceSavings.monthly +\n        resourceSavings.monthly;\n\n      // Calculate ROI (assuming $10K initial AI investment)\n      const initialInvestment = 10000;\n      const annualSavings = monthlySavings * 12;\n      const roi =\n        initialInvestment > 0 ? (annualSavings / initialInvestment) * 100 : 0;\n\n      return {\n        daily: Math.round(dailySavings * 100) / 100,\n        monthly: Math.round(monthlySavings * 100) / 100,\n        annual: Math.round(annualSavings * 100) / 100,\n        roi: Math.round(roi * 100) / 100,\n      };\n    } catch (error) {\n      console.error('Error calculating cost savings:', error);\n      return this.calculateBasicCostSavings(timeSavings);\n    }\n  }\n\n  /**\n   * Get facility-specific cost data\n   */\n  private async getFacilityCosts(): Promise<FacilityCosts> {\n    try {\n      const { FacilityService } = await import('@/services/facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n      const { data: facility } = await supabase\n        .from('facilities')\n        .select('hourly_rate, type, staff_count')\n        .eq('id', facilityId)\n        .single();\n\n      return {\n        hourlyRate:\n          ((facility as { hourly_rate?: number })?.hourly_rate as number) || 45,\n        facilityType:\n          ((facility as { facility_type?: string })?.facility_type as string) ||\n          'general',\n        staffCount:\n          ((facility as { staff_count?: number })?.staff_count as number) || 10,\n      };\n    } catch (err) { console.error(err); throw err; }\n      return { hourlyRate: 45, facilityType: 'general', staffCount: 10 };\n    }\n  }\n\n  /**\n   * Calculate direct time savings (staff cost)\n   */\n  private calculateDirectTimeSavings(\n    timeSavings: AIImpactMetrics['timeSavings'],\n    hourlyRate: number\n  ) {\n    return {\n      daily: (timeSavings.daily / 60) * hourlyRate,\n      monthly: (timeSavings.monthly / 60) * hourlyRate,\n    };\n  }\n\n  /**\n   * Calculate indirect cost savings from AI efficiency\n   */\n  private async calculateIndirectCostSavings(\n    aiTasks: AITask[],\n    facilityCosts: FacilityCosts\n  ) {\n    // AI reduces decision-making time and improves accuracy\n    const decisionTimeReduction = 0.3; // 30% faster decisions\n\n    const dailyIndirectSavings =\n      facilityCosts.hourlyRate *\n      facilityCosts.staffCount *\n      decisionTimeReduction *\n      0.5; // 0.5 hours per day\n\n    const monthlyIndirectSavings = dailyIndirectSavings * 22; // 22 working days\n\n    return {\n      daily: dailyIndirectSavings,\n      monthly: monthlyIndirectSavings,\n    };\n  }\n\n  /**\n   * Calculate cost savings from error prevention\n   */\n  private async calculateErrorPreventionSavings(\n    aiTasks: AITask[],\n    facilityCosts: FacilityCosts\n  ) {\n    try {\n      // Get current facility ID\n      const { FacilityService } = await import('@/services/facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n      // Get historical error data\n      const { data: errors } = await supabase\n        .from('quality_incidents')\n        .select('cost_impact, severity')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      if (!errors || errors.length === 0) {\n        // Estimate based on industry averages\n        const avgErrorCost =\n          facilityCosts.facilityType === 'dental' ? 150 : 200;\n        return { daily: avgErrorCost * 0.1, monthly: avgErrorCost * 2 };\n      }\n\n      // Calculate prevented errors (AI reduces errors by 40%)\n      const totalErrorCost = errors.reduce(\n        (sum, error) => sum + ((error.cost_impact as number) || 0),\n        0\n      );\n      const preventedErrors = totalErrorCost * 0.4;\n\n      return {\n        daily: preventedErrors / 30,\n        monthly: preventedErrors,\n      };\n    } catch (err) { console.error(err); throw err; }\n      // Fallback estimation\n      const avgErrorCost = 200;\n      return { daily: avgErrorCost * 0.1, monthly: avgErrorCost * 2 };\n    }\n  }\n\n  /**\n   * Calculate compliance and risk mitigation savings\n   */\n  private async calculateComplianceSavings() {\n    // AI reduces compliance violations and associated costs\n    const complianceViolationCost = 500; // Average cost per violation\n    const aiReductionRate = 0.6; // AI reduces violations by 60%\n\n    // Estimate violations prevented per month\n    const violationsPrevented = 2; // Conservative estimate\n    const monthlySavings =\n      violationsPrevented * complianceViolationCost * aiReductionRate;\n\n    return {\n      daily: monthlySavings / 30,\n      monthly: monthlySavings,\n    };\n  }\n\n  /**\n   * Calculate resource optimization savings\n   */\n  private async calculateResourceOptimizationSavings() {\n    try {\n      // Get current facility ID\n      const { FacilityService } = await import('@/services/facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n      // Get inventory and sterilization data\n      const { data: inventory } = await supabase\n        .from('inventory_items')\n        .select('unit_cost, quantity, reorder_point')\n        .eq('facility_id', facilityId);\n\n      const { data: sterilization } = await supabase\n        .from('sterilization_cycles')\n        .select('tools, cycle_time')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      // Filter for low stock items (quantity < reorder_point)\n      const lowStockItems =\n        inventory?.filter(\n          (item) => (item.quantity as number) < (item.reorder_point as number)\n        ) || [];\n\n      // Calculate inventory waste reduction (AI optimizes ordering)\n      const inventorySavings = lowStockItems\n        ? lowStockItems.reduce(\n            (sum, item) => sum + (item.unit_cost as number) * 0.1,\n            0\n          )\n        : 100; // 10% reduction\n\n      // Calculate sterilization efficiency (AI optimizes tool loading)\n      const sterilizationSavings = sterilization\n        ? sterilization.reduce(\n            (sum, cycle) => sum + (cycle.cycle_time as number) * 0.15,\n            0\n          )\n        : 50; // 15% time reduction\n\n      const monthlySavings = inventorySavings + sterilizationSavings;\n\n      return {\n        daily: monthlySavings / 30,\n        monthly: monthlySavings,\n      };\n    } catch (err) { console.error(err); throw err; }\n      // Fallback estimation\n      return { daily: 5, monthly: 150 };\n    }\n  }\n\n  /**\n   * Fallback basic cost calculation\n   */\n  private calculateBasicCostSavings(\n    timeSavings: AIImpactMetrics['timeSavings']\n  ) {\n    const hourlyCost = 45;\n    const dailySavings = (timeSavings.daily / 60) * hourlyCost;\n    const monthlySavings = (timeSavings.monthly / 60) * hourlyCost;\n    const annualSavings = monthlySavings * 12;\n\n    return {\n      daily: Math.round(dailySavings * 100) / 100,\n      monthly: Math.round(monthlySavings * 100) / 100,\n      annual: Math.round(annualSavings * 100) / 100,\n      roi: 0,\n    };\n  }\n}\n\nexport const aiCostCalculationService = new AICostCalculationService();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiDailyTaskConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiDailyTaskExecutor.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 71,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8404, 8407], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8404, 8407], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SupabaseClientType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 24,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 24,
        "endColumn": 24,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SupabaseError' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 26,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 19,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\nimport { askCliniioAI } from './aiService';\nimport { ToolService } from './tools/ToolService';\nimport {\n  OperationalGap,\n  DailyTaskAssignment,\n  generateGapId,\n  generateAITaskId,\n  generateTaskId,\n} from './aiDailyTaskProgress';\nimport {\n  AdminTaskConfig,\n  getDefaultConfig,\n  getPriorityScore,\n  isRoleCompatibleWithCategory,\n} from './aiDailyTaskConfig';\nimport { AdminTaskConfigService } from './adminTaskConfigService';\nimport { InventoryActionService } from '../pages/Inventory/services/inventoryActionService';\nimport type { SupabaseClient } from '@supabase/supabase-js';\nimport type { Database } from '../types/supabase';\n\n// Define proper types for Supabase operations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype SupabaseClientType = SupabaseClient<Database>;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype SupabaseError = {\n  message: string;\n  details?: string;\n  hint?: string;\n  code?: string;\n};\n\n// Database row interfaces\ninterface AutoclaveRow {\n  id: string;\n  facility_id: string;\n  autoclave_name: string;\n  status: string;\n  next_maintenance: string | null;\n  calibration_due: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface ToolRow {\n  id: string;\n  facility_id: string;\n  name: string;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface BITestRow {\n  id: string;\n  facility_id: string;\n  due_date: string;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface CleaningTaskRow {\n  id: string;\n  facility_id: string;\n  name: string;\n  priority: string;\n  due_date: string;\n  estimated_duration_minutes: number | null;\n  location: string;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Scan the entire facility for operational gaps\n */\nexport async function scanOperationalGaps(\n  facilityId: string\n): Promise<OperationalGap[]> {\n  const gaps: OperationalGap[] = [];\n\n  // 1. Equipment maintenance gaps\n  const equipmentGaps = await scanEquipmentMaintenance(facilityId);\n  gaps.push(...equipmentGaps);\n\n  // 2. Compliance gaps\n  const complianceGaps = await scanComplianceGaps(facilityId);\n  gaps.push(...complianceGaps);\n\n  // 3. Operational gaps\n  const operationalGaps = await scanOperationalIssues(facilityId);\n  gaps.push(...operationalGaps);\n\n  // 4. Safety gaps\n  const safetyGaps = await scanSafetyGaps(facilityId);\n  gaps.push(...safetyGaps);\n\n  return gaps;\n}\n\n/**\n * Scan for equipment maintenance needs\n */\nasync function scanEquipmentMaintenance(\n  facilityId: string\n): Promise<OperationalGap[]> {\n  const gaps: OperationalGap[] = [];\n  const today = new Date();\n\n  try {\n    // Check autoclave maintenance\n    const { data: autoclaves, error: autoclaveError } = await supabase\n      .from('autoclaves')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', 'active');\n\n    if (autoclaveError) throw autoclaveError;\n\n    autoclaves?.forEach((autoclave) => {\n      const autoclaveData = autoclave as AutoclaveRow;\n\n      // Check if maintenance is due\n      if (\n        autoclaveData.next_maintenance &&\n        new Date(autoclaveData.next_maintenance) <= today\n      ) {\n        gaps.push({\n          id: generateGapId(),\n          type: 'equipment',\n          priority: 'high',\n          title: `Autoclave Maintenance Due: ${autoclaveData.autoclave_name}`,\n          description: `Maintenance is due for autoclave ${autoclaveData.autoclave_name}. Schedule maintenance to ensure proper operation.`,\n          category: 'equipment',\n          dueDate: autoclaveData.next_maintenance,\n          estimatedPoints: 75,\n          estimatedDuration: 120,\n          assignedRole: 'technician',\n          facilityId,\n          metadata: {\n            autoclaveId: autoclaveData.id,\n            equipmentType: 'autoclave',\n          },\n        });\n      }\n\n      // Check if calibration is due\n      if (\n        autoclaveData.calibration_due &&\n        new Date(autoclaveData.calibration_due) <= today\n      ) {\n        gaps.push({\n          id: generateGapId(),\n          type: 'compliance',\n          priority: 'urgent',\n          title: `Autoclave Calibration Due: ${autoclaveData.autoclave_name}`,\n          description: `Calibration is due for autoclave ${autoclaveData.autoclave_name}. This is critical for compliance.`,\n          category: 'compliance',\n          dueDate: autoclaveData.calibration_due,\n          estimatedPoints: 100,\n          estimatedDuration: 60,\n          assignedRole: 'technician',\n          facilityId,\n          metadata: {\n            autoclaveId: autoclaveData.id,\n            equipmentType: 'autoclave',\n          },\n        });\n      }\n    });\n\n    // Check sterilization tools that need maintenance\n    const facilityTools = await ToolService.getToolsByFacilityAndStatus(\n      facilityId,\n      'maintenance'\n    );\n\n    facilityTools?.forEach((tool) => {\n      const toolData = tool as ToolRow;\n      gaps.push({\n        id: generateGapId(),\n        type: 'equipment',\n        priority: 'medium',\n        title: `Tool Maintenance Required: ${toolData.name}`,\n        description: `Tool ${toolData.name} requires maintenance. Check condition and repair if possible.`,\n        category: 'equipment',\n        dueDate: today.toISOString().split('T')[0],\n        estimatedPoints: 50,\n        estimatedDuration: 45,\n        assignedRole: 'technician',\n        facilityId,\n        metadata: { toolId: toolData.id, toolName: toolData.name },\n      });\n    });\n  } catch (error) {\n    console.error('Error scanning equipment maintenance:', error);\n  }\n\n  return gaps;\n}\n\n/**\n * Scan for compliance gaps\n */\nasync function scanComplianceGaps(\n  facilityId: string\n): Promise<OperationalGap[]> {\n  const gaps: OperationalGap[] = [];\n  const today = new Date();\n\n  try {\n    // Check for overdue BI tests\n    const { data: biTests, error: biError } = await supabase\n      .from('biological_indicator_tests')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', 'pending')\n      .lte('due_date', today.toISOString().split('T')[0]);\n\n    if (biError) throw biError;\n\n    biTests?.forEach((biTest) => {\n      const biTestData = biTest as BITestRow;\n      gaps.push({\n        id: generateGapId(),\n        type: 'compliance',\n        priority: 'urgent',\n        title: 'Daily BI Test Required',\n        description:\n          'Daily Biological Indicator test is required for sterilization compliance.',\n        category: 'compliance',\n        dueDate: biTestData.due_date,\n        estimatedPoints: 80,\n        estimatedDuration: 30,\n        assignedRole: 'operator',\n        facilityId,\n        metadata: { biTestId: biTestData.id, testType: 'daily_bi' },\n      });\n    });\n\n    // Check for overdue cleaning schedules\n    const { data: cleaningTasks, error: cleaningError } = await supabase\n      .from('cleaning_tasks')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', 'pending')\n      .lte('due_date', today.toISOString());\n\n    if (cleaningError) throw cleaningError;\n\n    cleaningTasks?.forEach((task) => {\n      const taskData = task as CleaningTaskRow;\n      gaps.push({\n        id: generateGapId(),\n        type: 'compliance',\n        priority: taskData.priority === 'critical' ? 'urgent' : 'high',\n        title: `Cleaning Task Overdue: ${taskData.name}`,\n        description: `Cleaning task \"${taskData.name}\" is overdue. Complete to maintain compliance.`,\n        category: 'compliance',\n        dueDate: taskData.due_date,\n        estimatedPoints: 60,\n        estimatedDuration: taskData.estimated_duration_minutes || 60,\n        assignedRole: 'cleaning_staff',\n        facilityId,\n        metadata: {\n          taskId: taskData.id,\n          taskName: taskData.name,\n          location: taskData.location,\n        },\n      });\n    });\n  } catch (error) {\n    console.error('Error scanning compliance gaps:', error);\n  }\n\n  return gaps;\n}\n\n/**\n * Scan for operational issues\n */\nasync function scanOperationalIssues(\n  facilityId: string\n): Promise<OperationalGap[]> {\n  const gaps: OperationalGap[] = [];\n\n  try {\n    // Check for tools stuck in sterilization phases\n    const statuses = ['bath1', 'bath2', 'airDry', 'autoclave'];\n    const allStuckTools = await Promise.all(\n      statuses.map((status) =>\n        ToolService.getToolsByFacilityAndStatus(facilityId, status as any)\n      )\n    );\n    const stuckTools = allStuckTools.flat();\n\n    stuckTools?.forEach((tool) => {\n      const toolData = tool as ToolRow;\n      gaps.push({\n        id: generateGapId(),\n        type: 'operational',\n        priority: 'medium',\n        title: `Tool Stuck in Phase: ${toolData.name}`,\n        description: `Tool ${toolData.name} appears to be stuck in ${toolData.status} phase. Check workflow status.`,\n        category: 'operational',\n        dueDate: new Date().toISOString().split('T')[0],\n        estimatedPoints: 40,\n        estimatedDuration: 30,\n        assignedRole: 'operator',\n        facilityId,\n        metadata: {\n          toolId: toolData.id,\n          toolName: toolData.name,\n          currentPhase: toolData.status,\n        },\n      });\n    });\n\n    // Check for low inventory items using centralized service\n    const allItems = await InventoryActionService.getItems();\n    const lowInventory = allItems.filter(\n      (item) =>\n        item.facility_id === facilityId &&\n        (item.quantity || 0) <\n          ((item.data as { min_quantity?: number })?.min_quantity || 0) &&\n        (item.data as { isActive?: boolean })?.isActive === true\n    );\n\n    lowInventory?.forEach((item) => {\n      gaps.push({\n        id: generateGapId(),\n        type: 'operational',\n        priority: 'high',\n        title: `Low Stock Alert: ${item.name}`,\n        description: `Inventory item ${item.name} is running low. Current quantity: ${item.quantity}.`,\n        category: 'operational',\n        dueDate: new Date().toISOString().split('T')[0],\n        estimatedPoints: 35,\n        estimatedDuration: 20,\n        assignedRole: 'inventory_manager',\n        facilityId,\n        metadata: {\n          itemId: item.id,\n          itemName: item.name,\n          currentQuantity: item.quantity,\n          minQuantity: item.data?.min_quantity,\n        },\n      });\n    });\n  } catch (error) {\n    console.error('Error scanning operational issues:', error);\n  }\n\n  return gaps;\n}\n\n/**\n * Scan for safety gaps\n */\nasync function scanSafetyGaps(facilityId: string): Promise<OperationalGap[]> {\n  const gaps: OperationalGap[] = [];\n\n  try {\n    // Check for failed sterilization cycles that need investigation\n    const { data: failedCycles, error: cyclesError } = await supabase\n      .from('sterilization_cycles')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', 'failed')\n      .gte(\n        'created_at',\n        new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n      ); // Last 7 days\n\n    if (cyclesError) throw cyclesError;\n\n    failedCycles?.forEach((cycle) => {\n      const cycleData = cycle as {\n        id: string;\n        failure_reason: string | null;\n        created_at: string;\n      };\n      gaps.push({\n        id: generateGapId(),\n        type: 'safety',\n        priority: 'high',\n        title: `Investigate Failed Cycle: ${cycleData.id}`,\n        description: `Sterilization cycle ${cycleData.id} failed and requires investigation to prevent future failures.`,\n        category: 'safety',\n        dueDate: new Date().toISOString().split('T')[0],\n        estimatedPoints: 70,\n        estimatedDuration: 90,\n        assignedRole: 'supervisor',\n        facilityId,\n        metadata: {\n          cycleId: cycleData.id,\n          failureReason: cycleData.failure_reason,\n        },\n      });\n    });\n  } catch (error) {\n    console.error('Error scanning safety gaps:', error);\n  }\n\n  return gaps;\n}\n\n/**\n * Get facility users and their roles\n */\nexport async function getFacilityUsers(\n  facilityId: string\n): Promise<Array<{ id: string; role: string; [key: string]: unknown }>> {\n  const { data: users, error } = await supabase\n    .from('users')\n    .select('id, full_name, role, department')\n    .eq('facility_id', facilityId)\n    .eq('is_active', true);\n\n  if (error) throw error;\n\n  // Type assertion to ensure proper typing\n  return (users || []).map((user) => {\n    const userData = user as {\n      id: string;\n      role: string;\n      full_name: string;\n      department: string;\n    };\n    return {\n      id: userData.id,\n      role: userData.role,\n      full_name: userData.full_name,\n      department: userData.department,\n    };\n  });\n}\n\n/**\n * Get admin task configuration\n */\nexport async function getAdminTaskConfig(\n  facilityId?: string\n): Promise<AdminTaskConfig> {\n  try {\n    // If no facility ID provided, get from current user context\n    if (!facilityId) {\n      const { FacilityService } = await import('./facilityService');\n      facilityId = await FacilityService.getCurrentFacilityId();\n    }\n\n    // Get configuration from database\n    return await AdminTaskConfigService.getConfig(facilityId);\n  } catch (error) {\n    console.warn(\n      'Failed to get admin config from database, using default:',\n      error\n    );\n    // Fallback to default config if database fails\n    return getDefaultConfig();\n  }\n}\n\n/**\n * Use AI to prioritize and assign tasks\n */\nexport async function assignTasksWithAI(\n  gaps: OperationalGap[],\n  users: Array<{ id: string; role: string; [key: string]: unknown }>,\n  config: AdminTaskConfig\n): Promise<DailyTaskAssignment[]> {\n  try {\n    // Prepare data for AI analysis\n    const analysisData = {\n      operationalGaps: gaps,\n      availableUsers: users,\n      configuration: config,\n      facilityContext: {\n        totalGaps: gaps.length,\n        gapTypes: gaps.reduce(\n          (acc, gap) => {\n            acc[gap.type] = (acc[gap.type] || 0) + 1;\n            return acc;\n          },\n          {} as Record<string, number>\n        ),\n        priorityDistribution: gaps.reduce(\n          (acc, gap) => {\n            acc[gap.priority] = (acc[gap.priority] || 0) + 1;\n            return acc;\n          },\n          {} as Record<string, number>\n        ),\n      },\n    };\n\n    // Use AI to prioritize and assign tasks\n    const aiResponse = await askCliniioAI({\n      prompt: `Analyze the following operational gaps and assign tasks to users optimally:\n\nOperational Gaps: ${JSON.stringify(analysisData.operationalGaps, null, 2)}\nAvailable Users: ${JSON.stringify(analysisData.availableUsers, null, 2)}\nConfiguration: ${JSON.stringify(analysisData.configuration, null, 2)}\nFacility Context: ${JSON.stringify(analysisData.facilityContext, null, 2)}\n\nPlease provide a JSON response with task assignments that:\n1. Respects max tasks per user (${analysisData.configuration.maxTasksPerUser})\n2. Prioritizes urgent and high priority tasks\n3. Matches user roles to task categories\n4. Balances workload across users\n5. Considers task priority and estimated duration\n\nReturn ONLY valid JSON in this exact format:\n[\n  {\n    \"userId\": \"user_id_here\",\n    \"tasks\": [\n      {\n        \"gapId\": \"gap_id_here\"\n      }\n    ]\n  }\n]\n\nEach task should reference a gapId from the operational gaps. Do not include any explanatory text, only the JSON array.`,\n      context: 'Daily Operations Task Assignment',\n    });\n\n    // Parse AI response and create task assignments\n    return parseAITaskAssignments(aiResponse, gaps, users, config);\n  } catch (error) {\n    console.error('AI task assignment failed, using fallback logic:', error);\n    return fallbackTaskAssignment(gaps, users, config);\n  }\n}\n\n/**\n * Parse AI response into task assignments\n */\nfunction parseAITaskAssignments(\n  aiResponse: string,\n  gaps: OperationalGap[],\n  users: Array<{ id: string; role: string; [key: string]: unknown }>,\n  config: AdminTaskConfig\n): DailyTaskAssignment[] {\n  try {\n    // Extract JSON from AI response\n    const jsonMatch = aiResponse.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) {\n      console.warn('No JSON array found in AI response, using fallback');\n      return fallbackTaskAssignment(gaps, users, config);\n    }\n\n    const aiAssignments = JSON.parse(jsonMatch[0]);\n\n    if (!Array.isArray(aiAssignments)) {\n      console.warn('AI response is not an array, using fallback');\n      return fallbackTaskAssignment(gaps, users, config);\n    }\n\n    const assignments: DailyTaskAssignment[] = [];\n    const userMap = new Map(users.map((user) => [user.id, user]));\n    const gapMap = new Map(gaps.map((gap) => [gap.id, gap]));\n\n    for (const aiAssignment of aiAssignments) {\n      if (!aiAssignment.userId || !Array.isArray(aiAssignment.tasks)) {\n        continue;\n      }\n\n      const user = userMap.get(aiAssignment.userId);\n      if (!user) {\n        console.warn(\n          `User ${aiAssignment.userId} not found, skipping assignment`\n        );\n        continue;\n      }\n\n      const userTasks = [];\n      for (const aiTask of aiAssignment.tasks) {\n        if (!aiTask.gapId) continue;\n\n        const gap = gapMap.get(aiTask.gapId);\n        if (!gap) continue;\n\n        userTasks.push({\n          id: generateAITaskId(),\n          title: gap.title,\n          description: gap.description,\n          category: gap.category,\n          priority: gap.priority,\n          points: gap.estimatedPoints,\n          estimatedDuration: gap.estimatedDuration,\n          dueDate: gap.dueDate,\n          type: gap.type,\n          assignedRole: gap.assignedRole,\n          facilityId: gap.facilityId,\n          metadata: gap.metadata,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        });\n      }\n\n      if (userTasks.length > 0) {\n        assignments.push({\n          userId: aiAssignment.userId,\n          tasks: userTasks,\n        });\n      }\n    }\n\n    // If AI parsing produced valid assignments, return them\n    if (assignments.length > 0) {\n      return assignments;\n    }\n\n    console.warn('AI parsing produced no valid assignments, using fallback');\n    return fallbackTaskAssignment(gaps, users, config);\n  } catch (error) {\n    console.error('Error parsing AI response:', error);\n    return fallbackTaskAssignment(gaps, users, config);\n  }\n}\n\n/**\n * Fallback task assignment logic\n */\nfunction fallbackTaskAssignment(\n  gaps: OperationalGap[],\n  users: Array<{ id: string; role: string; [key: string]: unknown }>,\n  config: AdminTaskConfig\n): DailyTaskAssignment[] {\n  const assignments: DailyTaskAssignment[] = [];\n\n  // Sort gaps by priority\n  const sortedGaps = [...gaps].sort((a, b) => {\n    return getPriorityScore(b.priority) - getPriorityScore(a.priority);\n  });\n\n  // Assign tasks to users based on role matching and max tasks per user\n  const userTaskCounts = new Map<string, number>();\n\n  for (const gap of sortedGaps) {\n    // Find available users for this task\n    const availableUsers = users.filter((user) => {\n      const currentTaskCount = userTaskCounts.get(user.id) || 0;\n      return currentTaskCount < config.maxTasksPerUser;\n    });\n\n    if (availableUsers.length === 0) break;\n\n    // Find best user match based on role\n    const bestUser = findBestUserMatch(gap, availableUsers);\n\n    if (bestUser) {\n      const currentTaskCount = userTaskCounts.get(bestUser.id) || 0;\n      userTaskCounts.set(bestUser.id, currentTaskCount + 1);\n\n      // Create or update assignment\n      let assignment = assignments.find((a) => a.userId === bestUser.id);\n      if (!assignment) {\n        assignment = { userId: bestUser.id, tasks: [] };\n        assignments.push(assignment);\n      }\n\n      assignment.tasks.push({\n        id: generateTaskId(),\n        title: gap.title,\n        description: gap.description,\n        category: gap.category,\n        priority: gap.priority,\n        points: gap.estimatedPoints,\n        dueDate: gap.dueDate,\n        type: gap.type,\n        estimatedDuration: gap.estimatedDuration,\n        assignedRole: gap.assignedRole,\n        facilityId: gap.facilityId,\n        metadata: gap.metadata,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      });\n    }\n  }\n\n  return assignments;\n}\n\n/**\n * Find best user match for a task\n */\nfunction findBestUserMatch(\n  gap: OperationalGap,\n  availableUsers: Array<{ id: string; role: string; [key: string]: unknown }>\n): { id: string; role: string; [key: string]: unknown } | null {\n  // First, try to match by assigned role\n  if (gap.assignedRole) {\n    const roleMatch = availableUsers.find(\n      (user) => user.role === gap.assignedRole\n    );\n    if (roleMatch) return roleMatch;\n  }\n\n  // Then try to match by category\n  const categoryMatches = availableUsers.filter((user) =>\n    isRoleCompatibleWithCategory(user.role, gap.category)\n  );\n\n  if (categoryMatches.length > 0) {\n    return categoryMatches[0];\n  }\n\n  // Fallback to any available user\n  return availableUsers[0] || null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiDailyTaskProgress.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiDailyTaskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiDailyTask\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiImpactMeasurementService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiImpactMeasurementService\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiMetricsService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 387,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\n\n// Define proper types to replace 'any'\nexport interface AITask {\n  id: string;\n  completed_at: string;\n  time_saved?: number;\n  actual_duration: number;\n  estimated_duration?: number;\n  difficulty?: string;\n  efficiency_score?: number;\n}\n\ninterface AIChallenge {\n  id: string;\n  quality_score?: number;\n}\n\nexport interface AIImpactMetrics {\n  timeSavings: {\n    daily: number;\n    weekly: number;\n    monthly: number;\n    total: number;\n    percentage: number;\n  };\n  proactiveManagement: {\n    issuesPrevented: number;\n    earlyInterventions: number;\n    complianceScore: number;\n    riskMitigation: number;\n    predictiveAccuracy: number;\n  };\n  costSavings: {\n    daily: number;\n    monthly: number;\n    annual: number;\n    roi: number;\n  };\n  efficiencyGains: {\n    taskCompletionRate: number;\n    qualityImprovement: number;\n    resourceOptimization: number;\n    workflowStreamlining: number;\n  };\n  realTimeUpdates: {\n    lastUpdated: string;\n    nextUpdate: string;\n    dataFreshness: number; // Minutes since last data refresh\n  };\n}\n\nexport interface AIBaselineData {\n  preAITaskDuration: number; // Average task duration before AI\n  preAICompletionRate: number; // Task completion rate before AI\n  preAIErrorRate: number; // Error rate before AI\n  preAICostPerTask: number; // Cost per task before AI\n  implementationDate: string; // When AI was implemented\n}\n\nexport class AIMetricsService {\n  private baselineData: AIBaselineData | null = null;\n  private lastUpdate: number = 0;\n  private readonly UPDATE_INTERVAL = 2 * 60 * 1000; // 2 minutes\n\n  /**\n   * Get comprehensive AI impact metrics for real-time dashboard\n   */\n  async getAIImpactMetrics(): Promise<AIImpactMetrics> {\n    try {\n      // Check if we need to update metrics\n      const now = Date.now();\n      if (now - this.lastUpdate < this.UPDATE_INTERVAL) {\n        return this.getCachedMetrics();\n      }\n\n      // Get baseline data if not loaded\n      if (!this.baselineData) {\n        this.baselineData = await this.getBaselineData();\n      }\n\n      // Calculate real-time metrics\n      const metrics = await this.calculateRealTimeMetrics();\n\n      // Cache and return\n      this.cacheMetrics(metrics);\n      this.lastUpdate = now;\n\n      return metrics;\n    } catch (error) {\n      console.error('Error getting AI impact metrics:', error);\n      return this.getDefaultMetrics();\n    }\n  }\n\n  /**\n   * Calculate real-time AI impact metrics\n   */\n  private async calculateRealTimeMetrics(): Promise<AIImpactMetrics> {\n    const today = new Date();\n    const startOfDay = new Date(\n      today.getFullYear(),\n      today.getMonth(),\n      today.getDate()\n    );\n    const startOfWeek = new Date(\n      startOfDay.getTime() - startOfDay.getDay() * 24 * 60 * 60 * 1000\n    );\n    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\n\n    // Get current facility ID\n    const { FacilityService } = await import('@/services/facilityService');\n    const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n    // Get AI task performance data\n    const { data: aiTasks } = await supabase\n      .from('ai_task_performance')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .gte('completed_at', startOfMonth.toISOString());\n\n    // Get AI challenge completion data\n    const { data: aiChallenges } = await supabase\n      .from('ai_challenge_completions')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .gte('completed_at', startOfMonth.toISOString());\n\n    // Get proactive management data\n    const proactiveData = await this.calculateProactiveManagement(\n      (aiTasks || []) as unknown as AITask[],\n      (aiChallenges || []) as unknown as AIChallenge[]\n    );\n\n    // Calculate time savings\n    const timeSavings = await this.calculateTimeSavings(\n      (aiTasks || []) as unknown as AITask[],\n      startOfDay,\n      startOfWeek,\n      startOfMonth\n    );\n\n    // Calculate cost savings using the cost calculation service\n    const { aiCostCalculationService } = await import(\n      './aiCostCalculationService'\n    );\n    const costSavings = await aiCostCalculationService.calculateCostSavings(\n      timeSavings,\n      (aiTasks || []) as unknown as AITask[]\n    );\n\n    // Calculate efficiency gains\n    const efficiencyGains = await this.calculateEfficiencyGains(\n      (aiTasks || []) as unknown as AITask[]\n    );\n\n    return {\n      timeSavings,\n      proactiveManagement: proactiveData,\n      costSavings,\n      efficiencyGains,\n      realTimeUpdates: {\n        lastUpdated: new Date().toISOString(),\n        nextUpdate: new Date(Date.now() + this.UPDATE_INTERVAL).toISOString(),\n        dataFreshness: Math.floor((Date.now() - this.lastUpdate) / 60000), // minutes\n      },\n    };\n  }\n\n  /**\n   * Calculate time savings with baseline comparison\n   */\n  private async calculateTimeSavings(\n    aiTasks: AITask[],\n    startOfDay: Date,\n    startOfWeek: Date,\n    startOfMonth: Date\n  ): Promise<AIImpactMetrics['timeSavings']> {\n    // Daily time savings\n    const dailyTasks = aiTasks.filter(\n      (task) => new Date(task.completed_at as string) >= startOfDay\n    );\n    const dailyTimeSaved = dailyTasks.reduce(\n      (sum, task) => sum + ((task.time_saved as number) || 0),\n      0\n    );\n\n    // Weekly time savings\n    const weeklyTasks = aiTasks.filter(\n      (task) => new Date(task.completed_at as string) >= startOfWeek\n    );\n    const weeklyTimeSaved = weeklyTasks.reduce(\n      (sum, task) => sum + ((task.time_saved as number) || 0),\n      0\n    );\n\n    // Monthly time savings\n    const monthlyTasks = aiTasks.filter(\n      (task) => new Date(task.completed_at as string) >= startOfMonth\n    );\n    const monthlyTimeSaved = monthlyTasks.reduce(\n      (sum, task) => sum + ((task.time_saved as number) || 0),\n      0\n    );\n\n    // Total time savings since AI implementation\n    const totalTimeSaved = aiTasks.reduce(\n      (sum, task) => sum + ((task.time_saved as number) || 0),\n      0\n    );\n\n    // Calculate percentage improvement vs. baseline\n    const baselineDuration = this.baselineData?.preAITaskDuration || 30;\n    const currentAvgDuration =\n      monthlyTasks.length > 0\n        ? monthlyTasks.reduce(\n            (sum, task) => sum + (task.actual_duration as number),\n            0\n          ) / monthlyTasks.length\n        : baselineDuration;\n\n    const percentageImprovement =\n      baselineDuration > 0\n        ? Math.round(\n            ((baselineDuration - currentAvgDuration) / baselineDuration) * 100\n          )\n        : 0;\n\n    return {\n      daily: dailyTimeSaved,\n      weekly: weeklyTimeSaved,\n      monthly: monthlyTimeSaved,\n      total: totalTimeSaved,\n      percentage: Math.max(0, Math.min(100, percentageImprovement)),\n    };\n  }\n\n  /**\n   * Calculate proactive management metrics\n   */\n  private async calculateProactiveManagement(\n    aiTasks: AITask[],\n    aiChallenges: AIChallenge[]\n  ): Promise<AIImpactMetrics['proactiveManagement']> {\n    // Issues prevented (tasks completed before they become urgent)\n    const urgentThreshold = new Date();\n    urgentThreshold.setHours(urgentThreshold.getHours() + 2); // 2 hours from now\n\n    const issuesPrevented = aiTasks.filter(\n      (task) => new Date(task.completed_at as string) < urgentThreshold\n    ).length;\n\n    // Early interventions (completed before due date)\n    const earlyInterventions = aiTasks.filter(\n      (task) =>\n        (task.estimated_duration as number) &&\n        (task.actual_duration as number) &&\n        (task.actual_duration as number) < (task.estimated_duration as number)\n    ).length;\n\n    // Compliance score (meeting deadlines)\n    const totalTasks = aiTasks.length;\n    const onTimeTasks = aiTasks.filter(\n      (task) =>\n        (task.estimated_duration as number) &&\n        (task.actual_duration as number) &&\n        (task.actual_duration as number) <= (task.estimated_duration as number)\n    ).length;\n\n    const complianceScore =\n      totalTasks > 0 ? Math.round((onTimeTasks / totalTasks) * 100) : 100;\n\n    // Risk mitigation (reduction in high-risk situations)\n    const highRiskTasks = aiTasks.filter(\n      (task) =>\n        (task.difficulty as string) === 'high' ||\n        (task.difficulty as string) === 'urgent'\n    ).length;\n\n    const riskMitigation =\n      totalTasks > 0\n        ? Math.round(((totalTasks - highRiskTasks) / totalTasks) * 100)\n        : 100;\n\n    // Predictive accuracy (AI challenge relevance)\n    const relevantChallenges = aiChallenges.filter(\n      (challenge) =>\n        (challenge.quality_score as number) &&\n        (challenge.quality_score as number) >= 4\n    ).length;\n\n    const predictiveAccuracy =\n      aiChallenges.length > 0\n        ? Math.round((relevantChallenges / aiChallenges.length) * 100)\n        : 100;\n\n    return {\n      issuesPrevented,\n      earlyInterventions,\n      complianceScore,\n      riskMitigation,\n      predictiveAccuracy,\n    };\n  }\n\n  /**\n   * Calculate efficiency gains\n   */\n  private async calculateEfficiencyGains(\n    aiTasks: AITask[]\n  ): Promise<AIImpactMetrics['efficiencyGains']> {\n    // Task completion rate\n    const totalTasks = aiTasks.length;\n    const completedTasks = aiTasks.filter((task) => task.completed_at).length;\n    const taskCompletionRate =\n      totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 100;\n\n    // Quality improvement (efficiency scores)\n    const avgEfficiencyScore =\n      aiTasks.length > 0\n        ? aiTasks.reduce((sum, task) => sum + (task.efficiency_score || 0), 0) /\n          aiTasks.length\n        : 100;\n\n    const qualityImprovement = Math.round(avgEfficiencyScore);\n\n    // Resource optimization (tools per cycle, inventory accuracy)\n    const resourceOptimization = await this.calculateResourceOptimization();\n\n    // Workflow streamlining (reduction in process steps)\n    const workflowStreamlining = await this.calculateWorkflowStreamlining();\n\n    return {\n      taskCompletionRate,\n      qualityImprovement,\n      resourceOptimization,\n      workflowStreamlining,\n    };\n  }\n\n  /**\n   * Calculate resource optimization metrics\n   */\n  private async calculateResourceOptimization(): Promise<number> {\n    try {\n      // Get current facility ID\n      const { FacilityService } = await import('@/services/facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n      // Get sterilization cycle data\n      const { data: cycles } = await supabase\n        .from('sterilization_cycles')\n        .select('tools')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      if (!cycles || cycles.length === 0) return 85; // Default score\n\n      // Calculate optimal tool utilization\n      const totalTools = cycles.reduce(\n        (sum, cycle) => sum + ((cycle.tools as unknown[])?.length || 0),\n        0\n      );\n      const avgToolsPerCycle = totalTools / cycles.length;\n\n      // Optimal is 6-8 tools per cycle\n      const optimalRange = { min: 6, max: 8 };\n      const utilizationScore =\n        avgToolsPerCycle >= optimalRange.min &&\n        avgToolsPerCycle <= optimalRange.max\n          ? 100\n          : Math.max(0, 100 - Math.abs(avgToolsPerCycle - 7) * 10);\n\n      return Math.round(utilizationScore);\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error calculating resource optimization');\n      return 85;\n    }\n  }\n\n  /**\n   * Calculate workflow streamlining metrics\n   */\n  private async calculateWorkflowStreamlining(): Promise<number> {\n    try {\n      // Get current facility ID\n      const { FacilityService } = await import('@/services/facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n\n      // Get task completion data\n      const { data: tasks } = await supabase\n        .from('home_daily_operations_tasks')\n        .select('estimated_duration, actual_duration')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      if (!tasks || tasks.length === 0) return 80; // Default score\n\n      // Calculate process efficiency improvement\n      const efficiencyScores = tasks.map((task) => {\n        if (!task.estimated_duration || !task.actual_duration) return 100;\n        return Math.max(\n          0,\n          Math.min(\n            100,\n            ((task.estimated_duration as number) /\n              (task.actual_duration as number)) *\n              100\n          )\n        );\n      });\n\n      const avgEfficiency =\n        efficiencyScores.reduce((sum, score) => sum + score, 0) /\n        efficiencyScores.length;\n\n      // Convert to streamlining score (higher efficiency = more streamlined)\n      return Math.round(avgEfficiency);\n    } catch (error) {\n      console.error('Error calculating workflow streamlining:', error);\n      return 80;\n    }\n  }\n\n  /**\n   * Get baseline data for comparison\n   */\n  private async getBaselineData(): Promise<AIBaselineData> {\n    try {\n      // In a real implementation, this would come from historical data\n      // For now, use reasonable defaults\n      return {\n        preAITaskDuration: 45, // 45 minutes average\n        preAICompletionRate: 75, // 75% completion rate\n        preAIErrorRate: 15, // 15% error rate\n        preAICostPerTask: 33.75, // $33.75 per task (45 min * $45/hour)\n        implementationDate: '2024-01-01', // AI implementation date\n      };\n    } catch (error) {\n      console.error('Error getting baseline data:', error);\n      return {\n        preAITaskDuration: 45,\n        preAICompletionRate: 75,\n        preAIErrorRate: 15,\n        preAICostPerTask: 33.75,\n        implementationDate: '2024-01-01',\n      };\n    }\n  }\n\n  /**\n   * Cache metrics for performance\n   */\n  private cachedMetrics: AIImpactMetrics | null = null;\n\n  private cacheMetrics(metrics: AIImpactMetrics): void {\n    this.cachedMetrics = metrics;\n  }\n\n  private getCachedMetrics(): AIImpactMetrics {\n    return this.cachedMetrics || this.getDefaultMetrics();\n  }\n\n  /**\n   * Get default metrics when calculation fails\n   */\n  private getDefaultMetrics(): AIImpactMetrics {\n    return {\n      timeSavings: {\n        daily: 0,\n        weekly: 0,\n        monthly: 0,\n        total: 0,\n        percentage: 0,\n      },\n      proactiveManagement: {\n        issuesPrevented: 0,\n        earlyInterventions: 0,\n        complianceScore: 100,\n        riskMitigation: 100,\n        predictiveAccuracy: 100,\n      },\n      costSavings: {\n        daily: 0,\n        monthly: 0,\n        annual: 0,\n        roi: 0,\n      },\n      efficiencyGains: {\n        taskCompletionRate: 100,\n        qualityImprovement: 100,\n        resourceOptimization: 85,\n        workflowStreamlining: 80,\n      },\n      realTimeUpdates: {\n        lastUpdated: new Date().toISOString(),\n        nextUpdate: new Date(Date.now() + this.UPDATE_INTERVAL).toISOString(),\n        dataFreshness: 0,\n      },\n    };\n  }\n\n  /**\n   * Get real-time alerts and insights\n   */\n  async getAIInsights(): Promise<string[]> {\n    try {\n      const metrics = await this.getAIImpactMetrics();\n      const { aiReportingService } = await import('./aiReportingService');\n      return await aiReportingService.getAIInsights(metrics);\n    } catch (error) {\n      console.error('Error getting AI insights:', error);\n      return ['AI system is actively monitoring facility operations'];\n    }\n  }\n}\n\nexport const aiMetricsService = new AIMetricsService();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiReportingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 77,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// File: src/services/aiService.ts\n// ‚ö†Ô∏è STRICT INSTRUCTION FOR CURSOR:\n// DO NOT MODIFY ANY OTHER FILES.\n// DO NOT MODIFY JSX.\n// DO NOT TOUCH STATE LOGIC, STYLING, OR BEHAVIOR.\n// DO NOT ADD OR REMOVE ANY COMPONENTS OR VARIABLES NOT LISTED BELOW.\n// DO NOT COMMIT OR PUSH CHANGES.\n// DO NOT CHANGE UI.\n// DO NOT RENAME ANYTHING.\n// DO NOT REFORMAT CODE UNLESS EXPLICITLY INSTRUCTED.\n// DO NOT RUN LINT OR FIX ERRORS UNLESS EXPLICITLY REQUESTED.\n// ONLY PERFORM THE SPECIFIC EDIT REQUESTED IN THIS PROMPT.\n\nimport { optimizedAIService } from './ai/OptimizedAIService';\nimport { aiRateLimiter } from './rateLimiting/AIRateLimiter';\nimport { logger } from '../utils/_core/logger';\n\nconst FN_URL = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/openai`;\nconst ANON = import.meta.env.VITE_SUPABASE_ANON_KEY || '';\n\nexport type AskAIParams = { prompt: string; context?: string };\n\nexport async function askCliniioAI({\n  prompt,\n  context = '',\n}: AskAIParams): Promise<string> {\n  if (!FN_URL) throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL');\n  if (!ANON) throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY');\n  if (!prompt?.trim()) throw new Error('Missing prompt');\n\n  // Check rate limit before proceeding\n  const rateLimitResult = await aiRateLimiter.checkRateLimit('ai_user', true);\n  if (!rateLimitResult.allowed) {\n    throw new Error(\n      `Rate limit exceeded. Please try again in ${rateLimitResult.retryAfter || 0} seconds.`\n    );\n  }\n\n  // Use optimized AI service with caching and rate limiting\n  const result = await optimizedAIService.execute(\n    {\n      service: 'openai',\n      operation: 'ask_cliniio_ai',\n      priority: 5, // High priority for user-facing requests\n      useCache: true,\n      cacheTtl: 3600, // Cache for 1 hour\n      useBatching: false, // Don't batch user-facing requests\n      maxRetries: 3,\n      timeout: 30000,\n      metadata: {\n        prompt: prompt.substring(0, 100), // Truncated for logging\n        context: context?.substring(0, 50),\n      },\n    },\n    async () => {\n      const res = await fetch(FN_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          // Required when verify_jwt is ON (your case). Harmless if OFF.\n          apikey: ANON,\n          Authorization: `Bearer ${ANON}`,\n        },\n        body: JSON.stringify({ prompt, context }),\n      });\n\n      const text = await res.text();\n      if (!res.ok) throw new Error(`Function error ${res.status}: ${text}`);\n\n      try {\n        const data = JSON.parse(text);\n        return String(data?.answer ?? '');\n      } catch (err) { console.error(err); throw err; }\n        // If the function ever returns plain text\n        return text;\n      }\n    },\n    {\n      parameters: { prompt, context },\n    }\n  );\n\n  // Record the request for rate limiting\n  await aiRateLimiter.recordRequest('ai_user', true);\n\n  if (!result.success) {\n    logger.error('AI request failed:', {\n      error: result.error,\n      prompt: prompt.substring(0, 100),\n    });\n    throw new Error(result.error || 'AI request failed');\n  }\n\n  return result.data || '';\n}\n\n/*\nUSAGE (example):\nconst reply = await askCliniioAI({ prompt: \"Say hello\", context: \"Cliniio test\" });\nconsole.log(\"AI:\", reply);\n*/\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\aiTaskPerformanceService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'learningError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 808,
        "column": 40,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 808,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'inventoryError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 822,
        "column": 41,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 822,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'sterilizationError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 836,
        "column": 45,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 836,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 253,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 253,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6955, 6958], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6955, 6958], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 265,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 265,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7318, 7321], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7318, 7321], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 286,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 286,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7959, 7962], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7959, 7962], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 315,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 315,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8827, 8830], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8827, 8830], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 352,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 352,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9926, 9929], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9926, 9929], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 388,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 388,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11103, 11106], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11103, 11106], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 405,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 405,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11738, 11741], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11738, 11741], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\nimport { aiImpactMeasurementService } from './aiImpactMeasurementService';\n\n// Database row interfaces\ninterface DailyOperationsTaskRow {\n  id: string;\n  type: string;\n  category: string;\n  estimated_duration: number;\n  actual_duration: number;\n  points: number;\n  priority: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface PerformanceMetricsRow {\n  id: string;\n  facility_id: string;\n  metric_type: string;\n  metric_value: number;\n  date: string;\n  created_at: string;\n  updated_at: string;\n  daily_time_saved?: number;\n  monthly_time_saved?: number;\n  time_savings?: number;\n  proactive_mgmt?: number;\n  skills?: number;\n  inventory?: number;\n  sterilization?: number;\n  month?: string;\n  user_id?: string;\n  metric_name?: string;\n}\n\ninterface UserGamificationStatsRow {\n  id: string;\n  user_id: string;\n  facility_id: string;\n  total_tasks: number;\n  completed_tasks: number;\n  total_points: number;\n  current_streak: number;\n  best_streak: number;\n  perfect_days: number;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface AITaskPerformance {\n  taskId: string;\n  userId: string;\n  taskType: string;\n  category: string;\n  estimatedDuration: number;\n  actualDuration: number;\n  points: number;\n  difficulty: string;\n  completedAt: string;\n  timeSaved: number;\n  efficiencyScore: number;\n}\n\nexport interface PerformanceUpdate {\n  timeSaved: {\n    daily: number;\n    monthly: number;\n  };\n  costSavings: {\n    monthly: number;\n    annual: number;\n  };\n  aiEfficiency: {\n    timeSavings: number;\n    proactiveMgmt: number;\n  };\n  teamPerformance: {\n    skills: number;\n    inventory: number;\n    sterilization: number;\n  };\n  gamificationStats: {\n    totalTasks: number;\n    completedTasks: number;\n    perfectDays: number;\n    currentStreak: number;\n    bestStreak: number;\n  };\n}\n\nexport class AITaskPerformanceService {\n  /**\n   * Get current facility ID from authenticated user\n   */\n  private async getCurrentFacilityId(): Promise<string> {\n    try {\n      const { FacilityService } = await import('./facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n      return facilityId;\n    } catch (error) {\n      console.error('Failed to get current facility ID:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Record task completion and calculate performance metrics\n   */\n  async recordTaskCompletion(\n    taskId: string,\n    userId: string\n  ): Promise<AITaskPerformance> {\n    try {\n      // Get the completed task details\n      const { data: task, error: taskError } = await supabase\n        .from('home_daily_operations_tasks')\n        .select('*')\n        .eq('id', taskId)\n        .single();\n\n      if (taskError) throw taskError;\n      if (!task) throw new Error('Task not found');\n\n      // Calculate performance metrics\n      const taskData = task as DailyOperationsTaskRow;\n      const estimatedDuration = taskData.estimated_duration || 30; // minutes\n      const actualDuration = taskData.actual_duration || 0;\n      const timeSaved = Math.max(0, estimatedDuration - actualDuration);\n      const efficiencyScore = Math.min(\n        100,\n        (actualDuration / estimatedDuration) * 100\n      );\n\n      const performance: AITaskPerformance = {\n        taskId,\n        userId,\n        taskType: taskData.type,\n        category: taskData.category,\n        estimatedDuration,\n        actualDuration,\n        points: taskData.points,\n        difficulty: taskData.priority,\n        completedAt: new Date().toISOString(),\n        timeSaved,\n        efficiencyScore,\n      };\n\n      // Store performance data\n      await this.storeTaskPerformance(performance);\n\n      // Update overall performance metrics\n      await this.updatePerformanceMetrics(performance);\n\n      return performance;\n    } catch (error) {\n      console.error('Error recording task completion:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store individual task performance data\n   */\n  private async storeTaskPerformance(\n    performance: AITaskPerformance\n  ): Promise<void> {\n    const facilityId = await this.getCurrentFacilityId();\n\n    // Calculate time_saved in minutes\n    const timeSaved =\n      performance.estimatedDuration && performance.actualDuration\n        ? performance.estimatedDuration - performance.actualDuration\n        : 0;\n\n    const { error } = await supabase.from('ai_task_performance').insert([\n      {\n        id: performance.taskId,\n        user_id: performance.userId,\n        facility_id: facilityId,\n        task_id: performance.taskId,\n        task_type: performance.taskType,\n        completion_time_ms: performance.actualDuration * 60000, // Convert minutes to milliseconds\n        accuracy_score: performance.efficiencyScore,\n        user_satisfaction: 5, // Default satisfaction score\n        completed_at: performance.completedAt,\n        baseline_time: performance.estimatedDuration,\n        actual_duration: performance.actualDuration,\n        time_saved: timeSaved,\n        efficiency_score: performance.efficiencyScore,\n        data: {\n          category: performance.category,\n          points: performance.points,\n          difficulty: performance.difficulty,\n          estimatedDuration: performance.estimatedDuration,\n          actualDuration: performance.actualDuration,\n          timeSaved: timeSaved,\n          efficiencyScore: performance.efficiencyScore,\n        },\n      },\n    ]);\n\n    if (error) throw error;\n  }\n\n  /**\n   * Update overall performance metrics based on task completion\n   */\n  private async updatePerformanceMetrics(\n    performance: AITaskPerformance\n  ): Promise<void> {\n    try {\n      // Get current date info\n      const today = new Date();\n      const startOfDay = new Date(\n        today.getFullYear(),\n        today.getMonth(),\n        today.getDate()\n      );\n      const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\n\n      // Update daily time saved\n      await this.updateDailyTimeSaved(startOfDay, performance.timeSaved);\n\n      // Update monthly time saved\n      await this.updateMonthlyTimeSaved(startOfMonth, performance.timeSaved);\n\n      // Update AI efficiency metrics\n      await this.updateAIEfficiencyMetrics(performance);\n\n      // Update team performance metrics\n      await this.updateTeamPerformanceMetrics(performance);\n\n      // Update gamification stats\n      await this.updateGamificationStats(performance);\n    } catch (error) {\n      console.error('Error updating performance metrics:', error);\n    }\n  }\n\n  /**\n   * Update daily time saved metrics\n   */\n  private async updateDailyTimeSaved(\n    date: Date,\n    timeSaved: number\n  ): Promise<void> {\n    const dateKey = date.toISOString().split('T')[0];\n    const facilityId = await this.getCurrentFacilityId();\n\n    // Try to update existing record\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { error: updateError } = await (supabase as any)\n      .from('performance_metrics')\n      .update({\n        daily_time_saved: timeSaved,\n      })\n      .eq('date', dateKey)\n      .eq('metric_type', 'time_saved')\n      .eq('facility_id', facilityId);\n\n    // If no record exists, create one\n    if (updateError) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      await (supabase as any).from('performance_metrics').insert({\n        date: dateKey,\n        metric_type: 'time_saved',\n        daily_time_saved: timeSaved,\n        monthly_time_saved: timeSaved,\n        facility_id: facilityId,\n      });\n    }\n  }\n\n  /**\n   * Update monthly time saved metrics\n   */\n  private async updateMonthlyTimeSaved(\n    date: Date,\n    timeSaved: number\n  ): Promise<void> {\n    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n    const facilityId = await this.getCurrentFacilityId();\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { error } = await (supabase as any)\n      .from('performance_metrics')\n      .upsert(\n        {\n          month: monthKey,\n          metric_type: 'time_saved',\n          monthly_time_saved: timeSaved,\n          facility_id: facilityId,\n        },\n        { onConflict: 'month,metric_type,facility_id' }\n      );\n\n    if (error) throw error;\n  }\n\n  /**\n   * Update AI efficiency metrics\n   */\n  private async updateAIEfficiencyMetrics(\n    performance: AITaskPerformance\n  ): Promise<void> {\n    const today = new Date().toISOString().split('T')[0];\n    const facilityId = await this.getCurrentFacilityId();\n\n    // Calculate proactive management score (tasks completed before due date)\n    const isProactive = new Date(performance.completedAt) <= new Date();\n    const proactiveScore = isProactive ? 10 : 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    await (supabase as any).from('performance_metrics').upsert(\n      {\n        date: today,\n        metric_type: 'ai_efficiency',\n        time_savings: performance.timeSaved,\n        proactive_mgmt: proactiveScore,\n        facility_id: facilityId,\n      },\n      { onConflict: 'date,metric_type,facility_id' }\n    );\n  }\n\n  /**\n   * Update team performance metrics based on task category\n   */\n  private async updateTeamPerformanceMetrics(\n    performance: AITaskPerformance\n  ): Promise<void> {\n    const today = new Date().toISOString().split('T')[0];\n    const facilityId = await this.getCurrentFacilityId();\n\n    let categoryScore = 0;\n    switch (performance.category) {\n      case 'inventory':\n        categoryScore = performance.efficiencyScore;\n        break;\n      case 'sterilization':\n        categoryScore = performance.efficiencyScore;\n        break;\n      case 'equipment':\n        categoryScore = performance.efficiencyScore;\n        break;\n      default:\n        categoryScore = performance.efficiencyScore;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    await (supabase as any).from('performance_metrics').upsert(\n      {\n        date: today,\n        metric_type: 'team_performance',\n        skills: performance.efficiencyScore,\n        inventory: performance.category === 'inventory' ? categoryScore : 0,\n        sterilization:\n          performance.category === 'sterilization' ? categoryScore : 0,\n        facility_id: facilityId,\n      },\n      { onConflict: 'date,metric_type,facility_id' }\n    );\n  }\n\n  /**\n   * Update gamification stats\n   */\n  private async updateGamificationStats(\n    performance: AITaskPerformance\n  ): Promise<void> {\n    const today = new Date().toISOString().split('T')[0];\n\n    // Get current user stats\n    const facilityId = await this.getCurrentFacilityId();\n    const { data: currentStats } = await supabase\n      .from('user_gamification_stats')\n      .select('*')\n      .eq('user_id', performance.userId)\n      .eq('facility_id', facilityId)\n      .eq('date', today)\n      .single();\n\n    if (currentStats) {\n      // Update existing stats\n      const statsData = currentStats as unknown as UserGamificationStatsRow;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      await (supabase as any)\n        .from('user_gamification_stats')\n        .update({\n          total_tasks: statsData.total_tasks + 1,\n          completed_tasks: statsData.completed_tasks + 1,\n          total_points: statsData.total_points + performance.points,\n          current_streak: statsData.current_streak + 1,\n          best_streak: Math.max(\n            statsData.best_streak,\n            statsData.current_streak + 1\n          ),\n        })\n        .eq('id', statsData.id)\n        .eq('facility_id', facilityId);\n    } else {\n      // Create new stats\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      await (supabase as any).from('user_gamification_stats').insert({\n        user_id: performance.userId,\n        facility_id: facilityId,\n        date: today,\n        total_tasks: 1,\n        completed_tasks: 1,\n        total_points: performance.points,\n        current_streak: 1,\n        best_streak: 1,\n      });\n    }\n  }\n\n  /**\n   * Get current performance metrics for the dashboard\n   */\n  async getCurrentPerformanceMetrics(): Promise<PerformanceUpdate> {\n    try {\n      const facilityId = await this.getCurrentFacilityId();\n      const today = new Date().toISOString().split('T')[0];\n      const startOfMonth = new Date().toISOString().slice(0, 7);\n\n      // Get daily metrics\n      const { data: dailyMetrics } = await supabase\n        .from('performance_metrics')\n        .select('*')\n        .eq('date', today)\n        .eq('facility_id', facilityId);\n\n      // Get monthly metrics\n      const { data: monthlyMetrics } = await supabase\n        .from('performance_metrics')\n        .select('*')\n        .like('month', startOfMonth)\n        .eq('facility_id', facilityId);\n\n      // Get gamification stats for today\n      const { data: gamificationStats } = await supabase\n        .from('user_gamification_stats')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .eq('date', today);\n\n      // Calculate cost savings using AI impact measurement service\n      let costSavings = { monthly: 0, annual: 0 };\n      try {\n        const aiImpactMetrics =\n          await aiImpactMeasurementService.getAIImpactMetrics();\n        costSavings = {\n          monthly: aiImpactMetrics.costSavings.monthly,\n          annual: aiImpactMetrics.costSavings.annual,\n        };\n      } catch (error) {\n        console.warn(\n          'Failed to get AI impact metrics for cost savings:',\n          error\n        );\n        // Keep default values if service fails\n      }\n\n      return {\n        timeSaved: {\n          daily:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'time_saved'\n              ) as unknown as PerformanceMetricsRow\n            )?.daily_time_saved || 0,\n          monthly:\n            (\n              monthlyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'time_saved'\n              ) as unknown as PerformanceMetricsRow\n            )?.monthly_time_saved || 0,\n        },\n        costSavings: {\n          monthly: costSavings.monthly,\n          annual: costSavings.annual,\n        },\n        aiEfficiency: {\n          timeSavings:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'ai_efficiency'\n              ) as unknown as PerformanceMetricsRow\n            )?.time_savings || 0,\n          proactiveMgmt:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'ai_efficiency'\n              ) as unknown as PerformanceMetricsRow\n            )?.proactive_mgmt || 0,\n        },\n        teamPerformance: {\n          skills:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'team_performance'\n              ) as unknown as PerformanceMetricsRow\n            )?.skills || 0,\n          inventory:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'team_performance'\n              ) as unknown as PerformanceMetricsRow\n            )?.inventory || 0,\n          sterilization:\n            (\n              dailyMetrics?.find(\n                (m) =>\n                  (m as unknown as PerformanceMetricsRow).metric_type ===\n                  'team_performance'\n              ) as unknown as PerformanceMetricsRow\n            )?.sterilization || 0,\n        },\n        gamificationStats: {\n          totalTasks:\n            gamificationStats?.reduce(\n              (sum, stat) =>\n                sum + (stat as unknown as UserGamificationStatsRow).total_tasks,\n              0\n            ) || 0,\n          completedTasks:\n            gamificationStats?.reduce(\n              (sum, stat) =>\n                sum +\n                (stat as unknown as UserGamificationStatsRow).completed_tasks,\n              0\n            ) || 0,\n          perfectDays:\n            gamificationStats?.filter(\n              (stat) =>\n                (stat as unknown as UserGamificationStatsRow)\n                  .completed_tasks ===\n                (stat as unknown as UserGamificationStatsRow).total_tasks\n            ).length || 0,\n          currentStreak:\n            gamificationStats?.reduce(\n              (max, stat) =>\n                Math.max(\n                  max,\n                  (stat as unknown as UserGamificationStatsRow).current_streak\n                ),\n              0\n            ) || 0,\n          bestStreak:\n            gamificationStats?.reduce(\n              (max, stat) =>\n                Math.max(\n                  max,\n                  (stat as unknown as UserGamificationStatsRow).best_streak\n                ),\n              0\n            ) || 0,\n        },\n      };\n    } catch (error) {\n      console.error('Error getting performance metrics:', error);\n      return {\n        timeSaved: { daily: 0, monthly: 0 },\n        costSavings: { monthly: 0, annual: 0 },\n        aiEfficiency: { timeSavings: 0, proactiveMgmt: 0 },\n        teamPerformance: { skills: 0, inventory: 0, sterilization: 0 },\n        gamificationStats: {\n          totalTasks: 0,\n          completedTasks: 0,\n          perfectDays: 0,\n          currentStreak: 0,\n          bestStreak: 0,\n        },\n      };\n    }\n  }\n}\n\nexport const aiTaskPerformanceService = new AITaskPerformanceService();\n\nexport async function getRawTaskDeltas() {\n  try {\n    const { FacilityService } = await import('./facilityService');\n    const facilityId = await FacilityService.getCurrentFacilityId();\n\n    if (!facilityId) return [];\n\n    const { data, error } = await supabase\n      .from('ai_task_performance')\n      .select(\n        'id, facility_id, user_id, task_type, baseline_time, actual_duration, completed_at'\n      )\n      .eq('facility_id', facilityId);\n\n    if (error || !data) return [];\n\n    return data.map((row) => ({\n      id: row.id,\n      facility_id: row.facility_id,\n      user_id: row.user_id,\n      task_type: row.task_type,\n      baseline_time: row.baseline_time,\n      actual_time: row.actual_duration,\n      time_saved: (row.baseline_time || 0) - (row.actual_duration || 0),\n      completed_at: row.completed_at,\n    }));\n  } catch (error) {\n    console.error('Error in getRawTaskDeltas:', error);\n    return [];\n  }\n}\n\n// Cache for time savings data\nconst timeSavingsCache = new Map<\n  string,\n  {\n    data: { daily_time_saved: number; monthly_time_saved: number };\n    timestamp: number;\n  }\n>();\nconst TIME_SAVINGS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport async function getTimeSavingsAggregates() {\n  try {\n    const { FacilityService } = await import('./facilityService');\n    const facilityId = await FacilityService.getCurrentFacilityId();\n\n    if (!facilityId) {\n      return { daily_time_saved: 0, monthly_time_saved: 0 };\n    }\n\n    // Check cache first\n    const cacheKey = `time-savings-${facilityId}`;\n    const cached = timeSavingsCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < TIME_SAVINGS_CACHE_TTL) {\n      return cached.data;\n    }\n\n    const tasks = await getRawTaskDeltas();\n    if (!tasks.length) {\n      const result = { daily_time_saved: 0, monthly_time_saved: 0 };\n      timeSavingsCache.set(cacheKey, { data: result, timestamp: Date.now() });\n      return result;\n    }\n\n    const now = new Date();\n    const today = now.toISOString().split('T')[0]; // YYYY-MM-DD\n    const currentMonth = now.getMonth();\n    const currentYear = now.getFullYear();\n\n    let daily = 0;\n    let monthly = 0;\n\n    for (const task of tasks) {\n      const completedAt = new Date(task.completed_at);\n\n      // Daily total\n      if (task.completed_at.startsWith(today)) {\n        daily += task.time_saved;\n      }\n\n      // Monthly total\n      if (\n        completedAt.getMonth() === currentMonth &&\n        completedAt.getFullYear() === currentYear\n      ) {\n        monthly += task.time_saved;\n      }\n    }\n\n    const result = {\n      daily_time_saved: daily,\n      monthly_time_saved: monthly,\n    };\n\n    // Cache the result\n    timeSavingsCache.set(cacheKey, { data: result, timestamp: Date.now() });\n\n    return result;\n  } catch (error) {\n    console.error('Error in getTimeSavingsAggregates:', error);\n    return { daily_time_saved: 0, monthly_time_saved: 0 };\n  }\n}\n\n// Cache for cost savings data\nconst costSavingsCache = new Map<\n  string,\n  {\n    data: { monthly_cost_savings: number; annual_cost_savings: number };\n    timestamp: number;\n  }\n>();\nconst COST_SAVINGS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport async function getCostSavingsAggregates(hourlyRate: number = 30) {\n  try {\n    const { FacilityService } = await import('./facilityService');\n    const facilityId = await FacilityService.getCurrentFacilityId();\n\n    if (!facilityId) {\n      return { monthly_cost_savings: 0, annual_cost_savings: 0 };\n    }\n\n    // Check cache first\n    const cacheKey = `cost-savings-${facilityId}-${hourlyRate}`;\n    const cached = costSavingsCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < COST_SAVINGS_CACHE_TTL) {\n      return cached.data;\n    }\n\n    const tasks = await getRawTaskDeltas();\n    if (!tasks.length) {\n      const result = { monthly_cost_savings: 0, annual_cost_savings: 0 };\n      costSavingsCache.set(cacheKey, { data: result, timestamp: Date.now() });\n      return result;\n    }\n\n    const now = new Date();\n    const currentMonth = now.getMonth();\n    const currentYear = now.getFullYear();\n\n    let monthlySavings = 0;\n    let annualSavings = 0;\n\n    for (const task of tasks) {\n      const completedAt = new Date(task.completed_at);\n      const hoursSaved = task.time_saved / 60; // minutes ‚Üí hours\n      const costSaved = hoursSaved * hourlyRate;\n\n      // Monthly total\n      if (\n        completedAt.getMonth() === currentMonth &&\n        completedAt.getFullYear() === currentYear\n      ) {\n        monthlySavings += costSaved;\n      }\n\n      // Annual total\n      if (completedAt.getFullYear() === currentYear) {\n        annualSavings += costSaved;\n      }\n    }\n\n    const result = {\n      monthly_cost_savings: monthlySavings,\n      annual_cost_savings: annualSavings,\n    };\n\n    // Cache the result\n    costSavingsCache.set(cacheKey, { data: result, timestamp: Date.now() });\n\n    return result;\n  } catch (error) {\n    console.error('Error in getCostSavingsAggregates:', error);\n    return { monthly_cost_savings: 0, annual_cost_savings: 0 };\n  }\n}\n\n// Cache for team performance data\nconst teamPerformanceCache = new Map<\n  string,\n  {\n    data: { skills: number; inventory: number; sterilization: number };\n    timestamp: number;\n  }\n>();\nconst TEAM_PERFORMANCE_CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nexport async function getTeamPerformanceAggregates() {\n  try {\n    const { FacilityService } = await import('./facilityService');\n    const facilityId = await FacilityService.getCurrentFacilityId();\n\n    if (!facilityId) {\n      return { skills: 0, inventory: 0, sterilization: 0 };\n    }\n\n    // Check cache first\n    const cacheKey = `team-performance-${facilityId}`;\n    const cached = teamPerformanceCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < TEAM_PERFORMANCE_CACHE_TTL) {\n      return cached.data;\n    }\n\n    // Skills performance (based on learning progress completion)\n    // First get all users in the facility, then get their learning progress\n    const { data: facilityUsers } = await supabase\n      .from('users')\n      .select('id')\n      .eq('facility_id', facilityId);\n\n    const userIds = facilityUsers?.map((user) => user.id) || [];\n\n    const { data: learningData, error: learningError } = await supabase\n      .from('user_learning_progress')\n      .select('progress, score')\n      .in('user_id', userIds);\n\n    const skills =\n      learningData && learningData.length > 0\n        ? Math.round(\n            learningData.reduce((sum, item) => sum + (item.progress || 0), 0) /\n              learningData.length\n          )\n        : 0;\n\n    // Inventory performance (based on inventory check accuracy)\n    const { data: inventoryData, error: inventoryError } = await supabase\n      .from('inventory_checks')\n      .select('accuracy')\n      .eq('facility_id', facilityId);\n\n    const inventory =\n      inventoryData && inventoryData.length > 0\n        ? Math.round(\n            inventoryData.reduce((sum, item) => sum + (item.accuracy || 0), 0) /\n              inventoryData.length\n          )\n        : 0;\n\n    // Sterilization performance (based on cycle success rate)\n    const { data: sterilizationData, error: sterilizationError } =\n      await supabase\n        .from('sterilization_cycles')\n        .select('status')\n        .eq('facility_id', facilityId);\n\n    const sterilization =\n      sterilizationData && sterilizationData.length > 0\n        ? Math.round(\n            (sterilizationData.filter((cycle) => cycle.status === 'completed')\n              .length /\n              sterilizationData.length) *\n              100\n          )\n        : 0;\n\n    const result = { skills, inventory, sterilization };\n\n    // Cache the result\n    teamPerformanceCache.set(cacheKey, { data: result, timestamp: Date.now() });\n\n    return result;\n  } catch (error) {\n    console.error('Error fetching team performance aggregates:', error);\n    return { skills: 0, inventory: 0, sterilization: 0 };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\AIMonitoringService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\AIRequestBatcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\AIRequestQueue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\AIResponseCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\OptimizedAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\__tests__\\aiTaskPerformanceService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\aiSettingsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\environmentalAI\\analytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\environmentalAI\\environmentalAIService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected keyword or identifier.",
        "line": 42,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../../lib/supabaseClient';\nimport { EnvironmentalAIProviderService } from './provider';\nimport { EnvironmentalAIAnalyticsService } from './analytics';\nimport type {\n  EnvironmentalAISettings,\n  EnvironmentalAIInsight,\n  PredictiveCleaningResult,\n  ContaminationPredictionResult,\n  ResourceOptimizationResult,\n  SmartSchedulingResult,\n  RiskAssessmentResult,\n  TrendAnalysisResult,\n  AnomalyDetectionResult,\n  QualityAssuranceResult,\n  RoomData,\n  CleaningSession,\n} from './types';\n\nexport class EnvironmentalAIService {\n  private facilityId: string;\n  private providerService: EnvironmentalAIProviderService;\n  private analyticsService: EnvironmentalAIAnalyticsService;\n\n  constructor(facilityId: string) {\n    this.facilityId = facilityId;\n    this.providerService = new EnvironmentalAIProviderService(facilityId);\n    this.analyticsService = new EnvironmentalAIAnalyticsService(facilityId);\n  }\n\n  // Initialize the service by loading settings\n  async initialize(): Promise<boolean> {\n    try {\n      const settings = await this.loadSettings();\n      return settings !== null;\n    } catch (err) { console.error(err); throw err; }\n      console.error('Failed to initialize EnvironmentalAIService');\n      return false;\n    }\n  }\n\n  // Load AI settings for the facility\n  async loadSettings(): Promise<EnvironmentalAISettings | null> {\n    try {\n      const { data, error } = await supabase\n        .from('environmental_ai_settings')\n        .select('*')\n        .eq('facility_id', this.facilityId)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // No settings found, return null\n          return null;\n        }\n        throw error;\n      }\n\n      return data as EnvironmentalAISettings;\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error loading environmental AI settings');\n      return null;\n    }\n  }\n\n  // Save AI settings to database\n  async saveSettings(\n    settings: Partial<EnvironmentalAISettings>\n  ): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('environmental_ai_settings')\n        .upsert({\n          facility_id: this.facilityId,\n          ...settings,\n          updated_at: new Date().toISOString(),\n        });\n\n      if (error) {\n        console.error('Error saving environmental AI settings:', error);\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Error saving environmental AI settings:', error);\n      return false;\n    }\n  }\n\n  // Initialize default AI settings for a facility\n  async initializeSettings(): Promise<boolean> {\n    try {\n      const defaultSettings: Partial<EnvironmentalAISettings> = {\n        ai_enabled: false,\n        ai_version: '1.0.0',\n        predictive_cleaning_enabled: false,\n        smart_scheduling: false,\n        contamination_prediction: false,\n        resource_optimization: false,\n        efficiency_analytics: false,\n        smart_room_management_enabled: false,\n        automatic_priority_assignment: false,\n        risk_assessment: false,\n        trend_analysis: false,\n        predictive_maintenance: false,\n        supply_optimization_enabled: false,\n        staff_scheduling: false,\n        cost_optimization: false,\n        inventory_prediction: false,\n        workload_balancing: false,\n        quality_assurance_enabled: false,\n        compliance_monitoring: false,\n        audit_trail_enhancement: false,\n        performance_tracking: false,\n        automated_reporting: false,\n        real_time_monitoring_enabled: false,\n        anomaly_detection: false,\n        smart_notifications: false,\n        status_updates: false,\n        emergency_alerts: false,\n        ai_confidence_threshold: 0.85,\n        ai_data_retention_days: 90,\n        real_time_processing_enabled: false,\n        batch_processing_enabled: false,\n        data_sharing_enabled: false,\n        local_ai_processing_enabled: false,\n        encrypted_data_transmission: true,\n        ai_model_training: false,\n      };\n\n      return await this.saveSettings(defaultSettings);\n    } catch (error) {\n      console.error('Error initializing environmental AI settings:', error);\n      return false;\n    }\n  }\n\n  // Predictive cleaning\n  async generatePredictiveCleaning(\n    roomId: string\n  ): Promise<PredictiveCleaningResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.predictive_cleaning_enabled) {\n        throw new Error('Predictive cleaning AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processPredictiveCleaningWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<PredictiveCleaningResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        predicted_cleaning_date: aiResult.predicted_cleaning_date,\n        confidence_score: aiResult.confidence_score,\n        urgency_level: aiResult.urgency_level,\n        cleaning_type: aiResult.cleaning_type,\n        estimated_duration: aiResult.estimated_duration,\n        required_resources: aiResult.required_resources,\n        risk_factors: aiResult.risk_factors,\n        optimization_suggestions: aiResult.optimization_suggestions,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_predictive_cleaning')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving predictive cleaning result:', error);\n        return null;\n      }\n\n      return data as unknown as PredictiveCleaningResult;\n    } catch (error) {\n      console.error('Error generating predictive cleaning:', error);\n      return null;\n    }\n  }\n\n  // Contamination prediction\n  async predictContamination(\n    roomId: string\n  ): Promise<ContaminationPredictionResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.contamination_prediction) {\n        throw new Error('Contamination prediction AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processContaminationPredictionWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<ContaminationPredictionResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        contamination_probability: aiResult.contamination_probability,\n        predicted_contamination_type: aiResult.predicted_contamination_type,\n        risk_factors: aiResult.risk_factors,\n        prevention_measures: aiResult.prevention_measures,\n        early_warning_signs: aiResult.early_warning_signs,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_contamination_prediction')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving contamination prediction result:', error);\n        return null;\n      }\n\n      return data as unknown as ContaminationPredictionResult;\n    } catch (error) {\n      console.error('Error predicting contamination:', error);\n      return null;\n    }\n  }\n\n  // Resource optimization\n  async optimizeResources(\n    optimizationType:\n      | 'staff_scheduling'\n      | 'supply_management'\n      | 'cost_reduction'\n      | 'efficiency'\n  ): Promise<ResourceOptimizationResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.resource_optimization) {\n        throw new Error('Resource optimization AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processResourceOptimizationWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<ResourceOptimizationResult> = {\n        facility_id: this.facilityId,\n        optimization_type: optimizationType,\n        current_usage: aiResult.current_usage,\n        optimized_usage: aiResult.optimized_usage,\n        savings_percentage: aiResult.savings_percentage,\n        cost_savings: aiResult.cost_savings,\n        efficiency_improvement: aiResult.efficiency_improvement,\n        recommended_actions: aiResult.recommended_actions,\n        implementation_timeline: aiResult.implementation_timeline,\n        risk_assessment: aiResult.risk_assessment,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_resource_optimization')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving resource optimization result:', error);\n        return null;\n      }\n\n      return data as unknown as ResourceOptimizationResult;\n    } catch (error) {\n      console.error('Error optimizing resources:', error);\n      return null;\n    }\n  }\n\n  // Smart scheduling\n  async generateSmartSchedule(\n    roomId: string\n  ): Promise<SmartSchedulingResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.smart_scheduling) {\n        throw new Error('Smart scheduling AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processSmartSchedulingWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<SmartSchedulingResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        optimal_cleaning_time: aiResult.optimal_cleaning_time,\n        staff_recommendations: aiResult.staff_recommendations,\n        resource_requirements: aiResult.resource_requirements,\n        conflict_avoidance: aiResult.conflict_avoidance,\n        efficiency_score: aiResult.efficiency_score,\n        cost_optimization: aiResult.cost_optimization,\n        quality_assurance: aiResult.quality_assurance,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_smart_scheduling')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving smart scheduling result:', error);\n        return null;\n      }\n\n      return data as unknown as SmartSchedulingResult;\n    } catch (error) {\n      console.error('Error generating smart schedule:', error);\n      return null;\n    }\n  }\n\n  // Risk assessment\n  async assessRisk(roomId: string): Promise<RiskAssessmentResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.risk_assessment) {\n        throw new Error('Risk assessment AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult = await this.providerService.processRiskAssessmentWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<RiskAssessmentResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        overall_risk_score: aiResult.overall_risk_score,\n        risk_categories: aiResult.risk_categories,\n        risk_factors: aiResult.risk_factors,\n        mitigation_strategies: aiResult.mitigation_strategies,\n        priority_actions: aiResult.priority_actions,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_risk_assessment')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving risk assessment result:', error);\n        return null;\n      }\n\n      return data as unknown as RiskAssessmentResult;\n    } catch (error) {\n      console.error('Error assessing risk:', error);\n      return null;\n    }\n  }\n\n  // Trend analysis\n  async analyzeTrends(\n    analysisType:\n      | 'cleaning_efficiency'\n      | 'resource_usage'\n      | 'quality_trends'\n      | 'cost_analysis'\n  ): Promise<TrendAnalysisResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.trend_analysis) {\n        throw new Error('Trend analysis AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult = await this.providerService.processTrendAnalysisWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<TrendAnalysisResult> = {\n        facility_id: this.facilityId,\n        analysis_type: analysisType,\n        trend_direction: aiResult.trend_direction,\n        trend_strength: aiResult.trend_strength,\n        key_insights: aiResult.key_insights,\n        contributing_factors: aiResult.contributing_factors,\n        recommendations: aiResult.recommendations,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_trend_analysis')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving trend analysis result:', error);\n        return null;\n      }\n\n      return data as unknown as TrendAnalysisResult;\n    } catch (error) {\n      console.error('Error analyzing trends:', error);\n      return null;\n    }\n  }\n\n  // Anomaly detection\n  async detectAnomalies(\n    roomId?: string\n  ): Promise<AnomalyDetectionResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.anomaly_detection) {\n        throw new Error('Anomaly detection AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processAnomalyDetectionWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<AnomalyDetectionResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        anomaly_type: aiResult.anomaly_type,\n        severity: aiResult.severity,\n        description: aiResult.description,\n        detected_at: aiResult.detected_at,\n        normal_range: aiResult.normal_range,\n        actual_value: aiResult.actual_value,\n        potential_causes: aiResult.potential_causes,\n        recommended_actions: aiResult.recommended_actions,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_anomaly_detection')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving anomaly detection result:', error);\n        return null;\n      }\n\n      return data as unknown as AnomalyDetectionResult;\n    } catch (error) {\n      console.error('Error detecting anomalies:', error);\n      return null;\n    }\n  }\n\n  // Quality assurance\n  async assessQuality(roomId: string): Promise<QualityAssuranceResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.quality_assurance_enabled) {\n        throw new Error('Quality assurance AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processQualityAssuranceWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<QualityAssuranceResult> = {\n        facility_id: this.facilityId,\n        room_id: roomId,\n        quality_score: aiResult.quality_score,\n        quality_metrics: aiResult.quality_metrics,\n        quality_trends: aiResult.quality_trends,\n        improvement_areas: aiResult.improvement_areas,\n        best_practices: aiResult.best_practices,\n        compliance_status: aiResult.compliance_status,\n        audit_recommendations: aiResult.audit_recommendations,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { data, error } = await supabase\n        .from('environmental_ai_quality_assurance')\n        .insert(result)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving quality assurance result:', error);\n        return null;\n      }\n\n      return data as unknown as QualityAssuranceResult;\n    } catch (error) {\n      console.error('Error assessing quality:', error);\n      return null;\n    }\n  }\n\n  // Get AI insights for environmental cleaning\n  async getEnvironmentalInsights(): Promise<EnvironmentalAIInsight[]> {\n    return this.analyticsService.getEnvironmentalInsights();\n  }\n\n  // Get historical cleaning data\n  async getHistoricalCleaningData(): Promise<CleaningSession[]> {\n    try {\n      const { data, error } = await supabase\n        .from('environmental_cleaning_sessions')\n        .select('*')\n        .eq('facility_id', this.facilityId)\n        .order('created_at', { ascending: false })\n        .limit(100);\n\n      if (error) {\n        console.error('Error getting historical cleaning data:', error);\n        return [];\n      }\n\n      return data as unknown as CleaningSession[];\n    } catch (error) {\n      console.error('Error getting historical cleaning data:', error);\n      return [];\n    }\n  }\n\n  // Get room data\n  async getRoomData(roomId: string): Promise<RoomData | null> {\n    try {\n      const { data, error } = await supabase\n        .from('environmental_cleans_enhanced')\n        .select('*')\n        .eq('id', roomId)\n        .eq('facility_id', this.facilityId)\n        .single();\n\n      if (error) {\n        console.error('Error getting room data:', error);\n        return null;\n      }\n\n      return {\n        id: data.id as string,\n        room_id: data.id as string,\n        room_name: (data.room_name as string) || 'Unknown Room',\n        room_type: (data.room_type as string) || 'unknown',\n        last_cleaned: (data.last_cleaned as string) || new Date().toISOString(),\n        cleaning_frequency: (data.cleaning_frequency as number) || 1,\n        priority_level:\n          (data.priority_level as 'medium' | 'high' | 'low' | 'critical') ||\n          'medium',\n        contamination_risk: (data.contamination_risk as number) || 0.5,\n        usage_pattern: (data.usage_pattern as Record<string, unknown>) || {},\n        maintenance_status: (data.maintenance_status as string) || 'good',\n      };\n    } catch (error) {\n      console.error('Error getting room data:', error);\n      return null;\n    }\n  }\n\n  // Check if a feature is enabled\n  isFeatureEnabled(\n    settings: EnvironmentalAISettings,\n    featurePath: string\n  ): boolean {\n    const featureValue = this.getNestedProperty(\n      settings as unknown as Record<string, unknown>,\n      featurePath\n    );\n    return featureValue === true;\n  }\n\n  // Helper method to get nested property\n  private getNestedProperty(\n    obj: Record<string, unknown>,\n    path: string\n  ): unknown {\n    return path\n      .split('.')\n      .reduce(\n        (current: unknown, key: string) =>\n          (current as Record<string, unknown>)?.[key],\n        obj\n      );\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\environmentalAI\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\environmentalAI\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\environmentalAI\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\dashboardProjectionUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\facilityContextUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\gamificationUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\metricsAggregationUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\supabaseWriteUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\helpers\\__tests__\\taskCompletionUtils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAI\\analytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAI\\forecasting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAI\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAI\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\inventoryAI\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningAI\\analytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningAI\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningAI\\learningAIService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected keyword or identifier.",
        "line": 140,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../../lib/supabaseClient';\nimport { LearningAIProviderService } from './provider';\nimport { LearningAIAnalyticsService } from './analytics';\nimport type {\n  LearningAISettings,\n  LearningAIInsight,\n  PersonalizedRecommendationResult,\n  SkillGapAnalysisResult,\n  LearningPathOptimizationResult,\n  PerformancePredictionResult,\n  LearningProgressData,\n  UserProfile,\n} from './types';\nimport type { Json } from '../../../types/supabase/common';\n\ntype SupabaseError = {\n  message: string;\n  details?: string;\n  hint?: string;\n  code?: string;\n};\n\n// Database row interfaces\ninterface LearningAISettingsRow {\n  id: string;\n  facility_id: string;\n  ai_enabled: boolean;\n  ai_version: string;\n  personalized_recommendations: boolean;\n  skill_gap_analysis: boolean;\n  learning_path_optimization: boolean;\n  performance_prediction: boolean;\n  adaptive_difficulty: boolean;\n  learning_analytics_enabled: boolean;\n  behavior_tracking: boolean;\n  progress_prediction: boolean;\n  engagement_metrics: boolean;\n  retention_analysis: boolean;\n  ai_confidence_threshold: number;\n  recommendation_limit: number;\n  data_retention_days: number;\n  model_version: string;\n  data_sharing_enabled: boolean;\n  local_ai_processing_enabled: boolean;\n  encrypted_data_transmission: boolean;\n  ai_model_training: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface PersonalizedRecommendationRow {\n  id: string;\n  facility_id: string;\n  user_id: string;\n  recommended_content: Json;\n  recommendation_reasoning: string;\n  confidence_scores: Json;\n  learning_path_suggestions: Json;\n  skill_development_areas: Json;\n  estimated_completion_time: number;\n  difficulty_progression: Json;\n  alternative_recommendations: Json;\n  confidence_score: number;\n  processing_time_ms: number;\n  created_at: string;\n}\n\ninterface SkillGapAnalysisRow {\n  id: string;\n  facility_id: string;\n  user_id: string;\n  current_skills: Json;\n  required_skills: Json;\n  skill_gaps: Json;\n  gap_priorities: Json;\n  learning_recommendations: Json;\n  skill_development_plan: Json;\n  estimated_learning_time: number;\n  confidence_score: number;\n  processing_time_ms: number;\n  created_at: string;\n}\n\ninterface LearningPathOptimizationRow {\n  id: string;\n  facility_id: string;\n  user_id: string;\n  optimized_learning_path: Json;\n  path_efficiency_score: number;\n  estimated_total_time: number;\n  difficulty_progression: Json;\n  prerequisite_mapping: Json;\n  alternative_paths: Json;\n  optimization_factors: Json;\n  confidence_score: number;\n  processing_time_ms: number;\n  created_at: string;\n}\n\ninterface PerformancePredictionRow {\n  id: string;\n  facility_id: string;\n  user_id: string;\n  content_id: string;\n  predicted_performance: number;\n  confidence_score: number;\n  performance_factors: Json;\n  improvement_suggestions: Json;\n  estimated_completion_time: number;\n  difficulty_assessment: Json;\n  prerequisite_requirements: Json;\n  alternative_approaches: Json;\n  processing_time_ms: number;\n  created_at: string;\n}\n\nexport class LearningAIService {\n  private facilityId: string;\n  private providerService: LearningAIProviderService;\n  private analyticsService: LearningAIAnalyticsService;\n\n  constructor(facilityId: string) {\n    this.facilityId = facilityId;\n    this.providerService = new LearningAIProviderService(facilityId);\n    this.analyticsService = new LearningAIAnalyticsService(facilityId);\n  }\n\n  // Initialize the service by loading settings\n  async initialize(): Promise<boolean> {\n    try {\n      const settings = await this.loadSettings();\n      return settings !== null;\n    } catch (err) { console.error(err); throw err; }\n      console.error('Failed to initialize LearningAIService');\n      return false;\n    }\n  }\n\n  // Load AI settings for the facility\n  async loadSettings(): Promise<LearningAISettings | null> {\n    try {\n      const { data, error } = await supabase\n        .from('learning_ai_settings')\n        .select('*')\n        .eq('facility_id', this.facilityId)\n        .single();\n\n      if (error) {\n        const errorData = error as SupabaseError;\n        if (errorData.code === 'PGRST116') {\n          // No settings found, return null\n          return null;\n        }\n        throw error;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const settingsData = data as unknown as LearningAISettingsRow;\n      return {\n        id: settingsData.id,\n        facility_id: settingsData.facility_id,\n        ai_enabled: settingsData.ai_enabled,\n        ai_version: settingsData.ai_version,\n        personalized_recommendations: settingsData.personalized_recommendations,\n        skill_gap_analysis: settingsData.skill_gap_analysis,\n        learning_path_optimization: settingsData.learning_path_optimization,\n        performance_prediction: settingsData.performance_prediction,\n        adaptive_difficulty: settingsData.adaptive_difficulty,\n        learning_analytics_enabled: settingsData.learning_analytics_enabled,\n        behavior_tracking: settingsData.behavior_tracking,\n        progress_prediction: settingsData.progress_prediction,\n        engagement_metrics: settingsData.engagement_metrics,\n        retention_analysis: settingsData.retention_analysis,\n        ai_confidence_threshold: settingsData.ai_confidence_threshold,\n        recommendation_limit: settingsData.recommendation_limit,\n        data_retention_days: settingsData.data_retention_days,\n        model_version: settingsData.model_version,\n        data_sharing_enabled: settingsData.data_sharing_enabled,\n        local_ai_processing_enabled: settingsData.local_ai_processing_enabled,\n        encrypted_data_transmission: settingsData.encrypted_data_transmission,\n        ai_model_training: settingsData.ai_model_training,\n        created_at: settingsData.created_at,\n        updated_at: settingsData.updated_at,\n      };\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error loading learning AI settings');\n      return null;\n    }\n  }\n\n  // Save AI settings to database\n  async saveSettings(settings: Partial<LearningAISettings>): Promise<boolean> {\n    try {\n      const upsertData: Partial<LearningAISettingsRow> = {\n        facility_id: this.facilityId,\n        ai_enabled: settings.ai_enabled,\n        ai_version: settings.ai_version,\n        personalized_recommendations: settings.personalized_recommendations,\n        skill_gap_analysis: settings.skill_gap_analysis,\n        learning_path_optimization: settings.learning_path_optimization,\n        performance_prediction: settings.performance_prediction,\n        adaptive_difficulty: settings.adaptive_difficulty,\n        learning_analytics_enabled: settings.learning_analytics_enabled,\n        behavior_tracking: settings.behavior_tracking,\n        progress_prediction: settings.progress_prediction,\n        engagement_metrics: settings.engagement_metrics,\n        retention_analysis: settings.retention_analysis,\n        ai_confidence_threshold: settings.ai_confidence_threshold,\n        recommendation_limit: settings.recommendation_limit,\n        data_retention_days: settings.data_retention_days,\n        model_version: settings.model_version,\n        data_sharing_enabled: settings.data_sharing_enabled,\n        local_ai_processing_enabled: settings.local_ai_processing_enabled,\n        encrypted_data_transmission: settings.encrypted_data_transmission,\n        ai_model_training: settings.ai_model_training,\n        updated_at: new Date().toISOString(),\n      };\n\n      const { error } = await supabase\n        .from('learning_ai_settings')\n        .upsert(upsertData);\n\n      if (error) {\n        console.error('Error saving learning AI settings:', error);\n        return false;\n      }\n\n      return true;\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error saving learning AI settings');\n      return false;\n    }\n  }\n\n  // Initialize default AI settings for a facility\n  async initializeSettings(): Promise<boolean> {\n    try {\n      const defaultSettings: Partial<LearningAISettings> = {\n        ai_enabled: false,\n        ai_version: '1.0.0',\n        personalized_recommendations: false,\n        skill_gap_analysis: false,\n        learning_path_optimization: false,\n        performance_prediction: false,\n        adaptive_difficulty: false,\n        learning_analytics_enabled: false,\n        behavior_tracking: false,\n        progress_prediction: false,\n        engagement_metrics: false,\n        retention_analysis: false,\n        ai_confidence_threshold: 0.8,\n        recommendation_limit: 5,\n        data_retention_days: 365,\n        model_version: 'v1.0',\n        data_sharing_enabled: false,\n        local_ai_processing_enabled: false,\n        encrypted_data_transmission: true,\n        ai_model_training: false,\n      };\n\n      return await this.saveSettings(defaultSettings);\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error initializing learning AI settings');\n      return false;\n    }\n  }\n\n  // Personalized recommendations\n  async generatePersonalizedRecommendations(\n    userId: string\n  ): Promise<PersonalizedRecommendationResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.personalized_recommendations) {\n        throw new Error('Personalized recommendations AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processPersonalizedRecommendationsWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<PersonalizedRecommendationResult> = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        recommended_content: aiResult.recommended_content,\n        recommendation_reasoning: aiResult.recommendation_reasoning,\n        confidence_scores: aiResult.confidence_scores,\n        learning_path_suggestions: aiResult.learning_path_suggestions,\n        skill_development_areas: aiResult.skill_development_areas,\n        estimated_completion_time: aiResult.estimated_completion_time,\n        difficulty_progression: aiResult.difficulty_progression,\n        alternative_recommendations: aiResult.alternative_recommendations,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData: Partial<PersonalizedRecommendationRow> = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        recommended_content: result.recommended_content as Json,\n        recommendation_reasoning: result.recommendation_reasoning as string,\n        confidence_scores: result.confidence_scores as Json,\n        learning_path_suggestions: result.learning_path_suggestions as Json,\n        skill_development_areas: result.skill_development_areas as Json,\n        estimated_completion_time: result.estimated_completion_time,\n        difficulty_progression: result.difficulty_progression as Json,\n        alternative_recommendations: result.alternative_recommendations as Json,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_personalized_recommendations')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error(\n          'Error saving personalized recommendation result:',\n          error\n        );\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as PersonalizedRecommendationRow;\n      return {\n        id: resultData.id,\n        facility_id: resultData.facility_id,\n        user_id: resultData.user_id,\n        recommended_content: resultData.recommended_content,\n        recommendation_reasoning: resultData.recommendation_reasoning,\n        confidence_scores: resultData.confidence_scores,\n        learning_path_suggestions: resultData.learning_path_suggestions,\n        skill_development_areas: resultData.skill_development_areas,\n        estimated_completion_time: resultData.estimated_completion_time,\n        difficulty_progression: resultData.difficulty_progression,\n        alternative_recommendations: resultData.alternative_recommendations,\n        confidence_score: resultData.confidence_score,\n        processing_time_ms: resultData.processing_time_ms,\n        created_at: resultData.created_at,\n      };\n    } catch (error) {\n      console.error('Error generating personalized recommendations:', error);\n      return null;\n    }\n  }\n\n  // Skill gap analysis\n  async analyzeSkillGaps(\n    userId: string\n  ): Promise<SkillGapAnalysisResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.skill_gap_analysis) {\n        throw new Error('Skill gap analysis AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processSkillGapAnalysisWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<SkillGapAnalysisResult> = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        current_skills: aiResult.current_skills,\n        required_skills: aiResult.required_skills,\n        skill_gaps: aiResult.skill_gaps,\n        gap_priorities: aiResult.gap_priorities,\n        learning_recommendations: aiResult.learning_recommendations,\n        skill_development_plan: aiResult.skill_development_plan,\n        estimated_learning_time: aiResult.estimated_learning_time,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData: Partial<SkillGapAnalysisRow> = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        current_skills: result.current_skills as Json,\n        required_skills: result.required_skills as Json,\n        skill_gaps: result.skill_gaps as Json,\n        gap_priorities: result.gap_priorities as Json,\n        learning_recommendations: result.learning_recommendations as Json,\n        skill_development_plan: result.skill_development_plan as Json,\n        estimated_learning_time: result.estimated_learning_time,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_skill_gap_analysis')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving skill gap analysis result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as SkillGapAnalysisRow;\n      return {\n        id: resultData.id,\n        facility_id: resultData.facility_id,\n        user_id: resultData.user_id,\n        current_skills: resultData.current_skills,\n        required_skills: resultData.required_skills,\n        skill_gaps: resultData.skill_gaps,\n        gap_priorities: resultData.gap_priorities,\n        learning_recommendations: resultData.learning_recommendations,\n        skill_development_plan: resultData.skill_development_plan,\n        estimated_learning_time: resultData.estimated_learning_time,\n        confidence_score: resultData.confidence_score,\n        processing_time_ms: resultData.processing_time_ms,\n        created_at: resultData.created_at,\n      };\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error analyzing skill gaps');\n      return null;\n    }\n  }\n\n  // Learning path optimization\n  async optimizeLearningPath(\n    userId: string\n  ): Promise<LearningPathOptimizationResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.learning_path_optimization) {\n        throw new Error('Learning path optimization AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processLearningPathOptimizationWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<LearningPathOptimizationResult> = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        optimized_learning_path: aiResult.optimized_learning_path,\n        path_efficiency_score: aiResult.path_efficiency_score,\n        estimated_total_time: aiResult.estimated_total_time,\n        difficulty_progression: aiResult.difficulty_progression,\n        prerequisite_mapping: aiResult.prerequisite_mapping,\n        alternative_paths: aiResult.alternative_paths,\n        optimization_factors: aiResult.optimization_factors,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData: Partial<LearningPathOptimizationRow> = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        optimized_learning_path: result.optimized_learning_path as Json,\n        path_efficiency_score: result.path_efficiency_score,\n        estimated_total_time: result.estimated_total_time,\n        difficulty_progression: result.difficulty_progression as Json,\n        prerequisite_mapping: result.prerequisite_mapping as Json,\n        alternative_paths: result.alternative_paths as Json,\n        optimization_factors: result.optimization_factors as Json,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_path_optimization')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving learning path optimization result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as LearningPathOptimizationRow;\n      return {\n        id: resultData.id,\n        facility_id: resultData.facility_id,\n        user_id: resultData.user_id,\n        optimized_learning_path: resultData.optimized_learning_path,\n        path_efficiency_score: resultData.path_efficiency_score,\n        estimated_total_time: resultData.estimated_total_time,\n        difficulty_progression: resultData.difficulty_progression,\n        prerequisite_mapping: resultData.prerequisite_mapping,\n        alternative_paths: resultData.alternative_paths,\n        optimization_factors: resultData.optimization_factors,\n        confidence_score: resultData.confidence_score,\n        processing_time_ms: resultData.processing_time_ms,\n        created_at: resultData.created_at,\n      };\n    } catch (error) {\n      console.error('Error optimizing learning path:', error);\n      return null;\n    }\n  }\n\n  // Performance prediction\n  async predictPerformance(\n    userId: string,\n    contentId: string\n  ): Promise<PerformancePredictionResult | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.performance_prediction) {\n        throw new Error('Performance prediction AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processPerformancePredictionWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result: Partial<PerformancePredictionResult> = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        content_id: contentId,\n        predicted_performance: aiResult.predicted_performance,\n        predicted_completion_time: aiResult.predicted_completion_time,\n        success_probability: aiResult.success_probability,\n        risk_factors: aiResult.risk_factors,\n        improvement_suggestions: aiResult.improvement_suggestions,\n        study_recommendations: aiResult.study_recommendations,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData: Partial<PerformancePredictionRow> = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        content_id: result.content_id,\n        predicted_performance: result.predicted_performance,\n        confidence_score: result.confidence_score,\n        performance_factors: result.risk_factors as Json,\n        improvement_suggestions: result.improvement_suggestions as Json,\n        estimated_completion_time: result.predicted_completion_time,\n        difficulty_assessment: result.study_recommendations as Json,\n        prerequisite_requirements: {} as Json, // Not available in this interface\n        alternative_approaches: {} as Json, // Not available in this interface\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_performance_prediction')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving performance prediction result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as PerformancePredictionRow;\n      return {\n        id: resultData.id,\n        facility_id: resultData.facility_id,\n        user_id: resultData.user_id,\n        content_id: resultData.content_id,\n        predicted_performance: resultData.predicted_performance,\n        confidence_score: resultData.confidence_score,\n        performance_factors: resultData.performance_factors,\n        improvement_suggestions: resultData.improvement_suggestions,\n        estimated_completion_time: resultData.estimated_completion_time,\n        difficulty_assessment: resultData.difficulty_assessment,\n        prerequisite_requirements: resultData.prerequisite_requirements,\n        alternative_approaches: resultData.alternative_approaches,\n        processing_time_ms: resultData.processing_time_ms,\n        created_at: resultData.created_at,\n      };\n    } catch (error) {\n      console.error('Error predicting performance:', error);\n      return null;\n    }\n  }\n\n  // Adaptive difficulty\n  async adjustDifficulty(\n    userId: string,\n    contentId: string\n  ): Promise<{\n    recommended_difficulty: 'beginner' | 'intermediate' | 'advanced';\n    difficulty_adjustment: number;\n    learning_curve_analysis: string;\n    adaptation_reasoning: string[];\n    performance_indicators: Record<string, number>;\n    next_difficulty_target: string;\n    confidence_score: number;\n  } | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.adaptive_difficulty) {\n        throw new Error('Adaptive difficulty AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processAdaptiveDifficultyWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        content_id: contentId,\n        recommended_difficulty: aiResult.recommended_difficulty,\n        difficulty_adjustment: aiResult.difficulty_adjustment,\n        learning_curve_analysis: aiResult.learning_curve_analysis,\n        adaptation_reasoning: aiResult.adaptation_reasoning,\n        performance_indicators: aiResult.performance_indicators,\n        next_difficulty_target: aiResult.next_difficulty_target,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        content_id: result.content_id,\n        recommended_difficulty: result.recommended_difficulty,\n        difficulty_adjustment: result.difficulty_adjustment,\n        learning_curve_analysis: result.learning_curve_analysis,\n        adaptation_reasoning: result.adaptation_reasoning as Json,\n        performance_indicators: result.performance_indicators as Json,\n        next_difficulty_target: result.next_difficulty_target,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_adaptive_difficulty')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving adaptive difficulty result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as {\n        recommended_difficulty: string;\n        difficulty_adjustment: number;\n        learning_curve_analysis: string;\n        adaptation_reasoning: Json;\n        performance_indicators: Json;\n        next_difficulty_target: string;\n        confidence_score: number;\n      };\n\n      return {\n        recommended_difficulty: resultData.recommended_difficulty as\n          | 'beginner'\n          | 'intermediate'\n          | 'advanced',\n        difficulty_adjustment: resultData.difficulty_adjustment,\n        learning_curve_analysis: resultData.learning_curve_analysis,\n        adaptation_reasoning: resultData.adaptation_reasoning as string[],\n        performance_indicators: resultData.performance_indicators as Record<\n          string,\n          number\n        >,\n        next_difficulty_target: resultData.next_difficulty_target,\n        confidence_score: resultData.confidence_score,\n      };\n    } catch (error) {\n      console.error('Error adjusting difficulty:', error);\n      return null;\n    }\n  }\n\n  // Engagement analysis\n  async analyzeEngagement(userId: string): Promise<{\n    engagement_score: number;\n    engagement_trends: Record<string, unknown>;\n    engagement_factors: string[];\n    disengagement_triggers: string[];\n    improvement_suggestions: string[];\n    optimal_learning_times: string[];\n    content_preferences: string[];\n    confidence_score: number;\n  } | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.engagement_metrics) {\n        throw new Error('Engagement analysis AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processEngagementAnalysisWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        engagement_score: aiResult.engagement_score,\n        engagement_trends: aiResult.engagement_trends,\n        engagement_factors: aiResult.engagement_factors,\n        disengagement_triggers: aiResult.disengagement_triggers,\n        improvement_suggestions: aiResult.improvement_suggestions,\n        optimal_learning_times: aiResult.optimal_learning_times,\n        content_preferences: aiResult.content_preferences,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        engagement_score: result.engagement_score,\n        engagement_trends: result.engagement_trends as Json,\n        engagement_factors: result.engagement_factors as Json,\n        disengagement_triggers: result.disengagement_triggers as Json,\n        improvement_suggestions: result.improvement_suggestions as Json,\n        optimal_learning_times: result.optimal_learning_times as Json,\n        content_preferences: result.content_preferences as Json,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_engagement_analysis')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving engagement analysis result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as {\n        engagement_score: number;\n        engagement_trends: Json;\n        engagement_factors: Json;\n        disengagement_triggers: Json;\n        improvement_suggestions: Json;\n        optimal_learning_times: Json;\n        content_preferences: Json;\n        confidence_score: number;\n      };\n\n      return {\n        engagement_score: resultData.engagement_score,\n        engagement_trends: resultData.engagement_trends as Record<\n          string,\n          unknown\n        >,\n        engagement_factors: resultData.engagement_factors as string[],\n        disengagement_triggers: resultData.disengagement_triggers as string[],\n        improvement_suggestions: resultData.improvement_suggestions as string[],\n        optimal_learning_times: resultData.optimal_learning_times as string[],\n        content_preferences: resultData.content_preferences as string[],\n        confidence_score: resultData.confidence_score,\n      };\n    } catch (error) {\n      console.error('Error analyzing engagement:', error);\n      return null;\n    }\n  }\n\n  // Retention prediction\n  async predictRetention(userId: string): Promise<{\n    retention_probability: number;\n    knowledge_decay_rate: number;\n    review_recommendations: string[];\n    reinforcement_schedule: string[];\n    retention_factors: string[];\n    forgetting_risk_areas: string[];\n    confidence_score: number;\n  } | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.retention_analysis) {\n        throw new Error('Retention prediction AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processRetentionPredictionWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        retention_probability: aiResult.retention_probability,\n        knowledge_decay_rate: aiResult.knowledge_decay_rate,\n        review_recommendations: aiResult.review_recommendations,\n        reinforcement_schedule: aiResult.reinforcement_schedule,\n        retention_factors: aiResult.retention_factors,\n        forgetting_risk_areas: aiResult.forgetting_risk_areas,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        retention_probability: result.retention_probability,\n        knowledge_decay_rate: result.knowledge_decay_rate,\n        review_recommendations: result.review_recommendations as Json,\n        reinforcement_schedule: result.reinforcement_schedule as Json,\n        retention_factors: result.retention_factors as Json,\n        forgetting_risk_areas: result.forgetting_risk_areas as Json,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_retention_prediction')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving retention prediction result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as {\n        retention_probability: number;\n        knowledge_decay_rate: number;\n        review_recommendations: Json;\n        reinforcement_schedule: Json;\n        retention_factors: Json;\n        forgetting_risk_areas: Json;\n        confidence_score: number;\n      };\n\n      return {\n        retention_probability: resultData.retention_probability,\n        knowledge_decay_rate: resultData.knowledge_decay_rate,\n        review_recommendations: resultData.review_recommendations as string[],\n        reinforcement_schedule: resultData.reinforcement_schedule as string[],\n        retention_factors: resultData.retention_factors as string[],\n        forgetting_risk_areas: resultData.forgetting_risk_areas as string[],\n        confidence_score: resultData.confidence_score,\n      };\n    } catch (error) {\n      console.error('Error predicting retention:', error);\n      return null;\n    }\n  }\n\n  // Learning analytics\n  async generateLearningAnalytics(userId: string): Promise<{\n    learning_efficiency_score: number;\n    preferred_content_categories: string[];\n    optimal_study_duration: number;\n    learning_patterns: Record<string, unknown>;\n    progress_trends: Record<string, unknown>;\n    performance_metrics: Record<string, number>;\n    insights: string[];\n    recommendations: string[];\n    confidence_score: number;\n  } | null> {\n    try {\n      const settings = await this.loadSettings();\n      if (!settings?.learning_analytics_enabled) {\n        throw new Error('Learning analytics AI is not enabled');\n      }\n\n      const startTime = Date.now();\n\n      // Process with AI using provider service\n      const aiResult =\n        await this.providerService.processLearningAnalyticsWithAI();\n\n      const processingTime = Date.now() - startTime;\n\n      // Create result object\n      const result = {\n        facility_id: this.facilityId,\n        user_id: userId,\n        learning_efficiency_score: aiResult.learning_efficiency_score,\n        preferred_content_categories: aiResult.preferred_content_categories,\n        optimal_study_duration: aiResult.optimal_study_duration,\n        learning_patterns: aiResult.learning_patterns,\n        progress_trends: aiResult.progress_trends,\n        performance_metrics: aiResult.performance_metrics,\n        insights: aiResult.insights,\n        recommendations: aiResult.recommendations,\n        confidence_score: aiResult.confidence_score,\n        processing_time_ms: processingTime,\n        created_at: new Date().toISOString(),\n      };\n\n      // Save to database\n      const insertData = {\n        facility_id: result.facility_id,\n        user_id: result.user_id,\n        learning_efficiency_score: result.learning_efficiency_score,\n        preferred_content_categories:\n          result.preferred_content_categories as Json,\n        optimal_study_duration: result.optimal_study_duration,\n        learning_patterns: result.learning_patterns as Json,\n        progress_trends: result.progress_trends as Json,\n        performance_metrics: result.performance_metrics as Json,\n        insights: result.insights as Json,\n        recommendations: result.recommendations as Json,\n        confidence_score: result.confidence_score,\n        processing_time_ms: result.processing_time_ms,\n        created_at: result.created_at,\n      };\n\n      const { data, error } = await supabase\n        .from('learning_ai_analytics')\n        .insert(insertData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error saving learning analytics result:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const resultData = data as unknown as {\n        learning_efficiency_score: number;\n        preferred_content_categories: Json;\n        optimal_study_duration: number;\n        learning_patterns: Json;\n        progress_trends: Json;\n        performance_metrics: Json;\n        insights: Json;\n        recommendations: Json;\n        confidence_score: number;\n      };\n\n      return {\n        learning_efficiency_score: resultData.learning_efficiency_score,\n        preferred_content_categories:\n          resultData.preferred_content_categories as string[],\n        optimal_study_duration: resultData.optimal_study_duration,\n        learning_patterns: resultData.learning_patterns as Record<\n          string,\n          unknown\n        >,\n        progress_trends: resultData.progress_trends as Record<string, unknown>,\n        performance_metrics: resultData.performance_metrics as Record<\n          string,\n          number\n        >,\n        insights: resultData.insights as string[],\n        recommendations: resultData.recommendations as string[],\n        confidence_score: resultData.confidence_score,\n      };\n    } catch (error) {\n      console.error('Error generating learning analytics:', error);\n      return null;\n    }\n  }\n\n  // Get AI insights for learning\n  async getLearningInsights(): Promise<LearningAIInsight[]> {\n    return this.analyticsService.getLearningInsights();\n  }\n\n  // Get learning progress data\n  async getLearningProgressData(\n    userId: string\n  ): Promise<LearningProgressData[]> {\n    try {\n      const { data, error } = await supabase\n        .from('learning_progress')\n        .select('*')\n        .eq('facility_id', this.facilityId)\n        .eq('user_id', userId)\n        .order('created_at', { ascending: false })\n        .limit(100);\n\n      if (error) {\n        console.error('Error getting learning progress data:', error);\n        return [];\n      }\n\n      if (!data) {\n        return [];\n      }\n\n      return data as unknown as LearningProgressData[];\n    } catch (error) {\n      console.error('Error getting learning progress data:', error);\n      return [];\n    }\n  }\n\n  // Get user profile\n  async getUserProfile(userId: string): Promise<UserProfile | null> {\n    try {\n      const { data, error } = await supabase\n        .from('user_profiles')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('facility_id', this.facilityId)\n        .single();\n\n      if (error) {\n        console.error('Error getting user profile:', error);\n        return null;\n      }\n\n      if (!data) {\n        return null;\n      }\n\n      const profileData = data as unknown as {\n        id: string;\n        user_id: string;\n        role: string;\n        department: string;\n        experience_level: string;\n        skill_areas: Json;\n        learning_goals: Json;\n        preferred_learning_style: string;\n        time_availability: number;\n        updated_at: string;\n        created_at: string;\n      };\n\n      return {\n        id: profileData.id,\n        user_id: profileData.user_id,\n        role: profileData.role || 'user',\n        department: profileData.department || 'general',\n        experience_level:\n          (profileData.experience_level as\n            | 'expert'\n            | 'senior'\n            | 'entry'\n            | 'mid') || 'entry',\n        skill_areas: (profileData.skill_areas as string[]) || [],\n        learning_goals: (profileData.learning_goals as string[]) || [],\n        preferred_learning_style:\n          profileData.preferred_learning_style || 'visual',\n        time_availability: profileData.time_availability || 30,\n        last_updated: profileData.updated_at || profileData.created_at,\n      };\n    } catch (error) {\n      console.error('Error getting user profile:', error);\n      return null;\n    }\n  }\n\n  // Check if a feature is enabled\n  isFeatureEnabled(settings: LearningAISettings, featurePath: string): boolean {\n    const featureValue = this.getNestedProperty(\n      settings as unknown as Record<string, unknown>,\n      featurePath\n    );\n    return featureValue === true;\n  }\n\n  // Helper method to get nested property\n  private getNestedProperty(\n    obj: Record<string, unknown>,\n    path: string\n  ): unknown {\n    return path\n      .split('.')\n      .reduce(\n        (current: unknown, key: string) =>\n          (current as Record<string, unknown>)?.[key],\n        obj\n      );\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningAI\\provider.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningAI\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\learningObjectivesService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaningService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaning\\features.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaning\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaning\\predictor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaning\\repository.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\predictiveCleaning\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\settings\\modules\\__tests__\\analyticsSettingsService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\settings\\modules\\__tests__\\assistantSettingsService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\settings\\modules\\__tests__\\evaluationSettingsService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\settings\\modules\\__tests__\\taskSettingsService.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\smartCategorizationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilizationAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilizationAIServiceMock.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\analysisServices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\analyticsServices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\complianceServices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\openaiService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\optimizationServices.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\performanceMetricsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\settingsManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\sterilizationAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\ai\\sterilization\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\analyticsDataService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\environmentalAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\forecastingAnalyticsService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SterilizationCycleRow' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'InventoryItemRow' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 27,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 27,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 264,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 264,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7264, 7267], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7264, 7267], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 267,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 267,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7420, 7423], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7420, 7423], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 372,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 372,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11111, 11114], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11111, 11114], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 372,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 372,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11126, 11129], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11126, 11129], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 381,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 381,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11410, 11413], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11410, 11413], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 389,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 389,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11669, 11672], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11669, 11672], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 392,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 392,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11786, 11789], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11786, 11789], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 406,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 406,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12366, 12369], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12366, 12369], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 518,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 518,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16040, 16043], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16040, 16043], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 518,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 518,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16054, 16057], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16054, 16057], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 527,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 527,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16344, 16347], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16344, 16347], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 536,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 536,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16570, 16573], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16570, 16573], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 613,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 613,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [19151, 19154], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [19151, 19154], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 687,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 687,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21634, 21637], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21634, 21637], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 785,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 785,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [24778, 24781], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [24778, 24781], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 797,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 797,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [25244, 25247], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [25244, 25247], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 798,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 798,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [25303, 25306], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [25303, 25306], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 880,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 880,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [27984, 27987], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [27984, 27987], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 973,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 973,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [31422, 31425], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [31422, 31425], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 973,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 973,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [31437, 31440], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [31437, 31440], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 983,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 983,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [31723, 31726], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [31723, 31726], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 994,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 994,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [32176, 32179], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [32176, 32179], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1030,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1030,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [33270, 33273], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [33270, 33273], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1033,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1033,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [33416, 33419], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [33416, 33419], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1108,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1108,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [36025, 36028], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [36025, 36028], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1126,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1126,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [36620, 36623], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [36620, 36623], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1231,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1231,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [39945, 39948], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [39945, 39948], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1236,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1236,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [40094, 40097], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [40094, 40097], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1270,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1270,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [41159, 41162], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [41159, 41162], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1281,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1281,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [41429, 41432], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [41429, 41432], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1434,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1434,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [46742, 46745], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [46742, 46745], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1535,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1535,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [50133, 50136], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [50133, 50136], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1544,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1544,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [50441, 50444], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [50441, 50444], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 33,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../lib/supabaseClient';\nimport { AnalyticsFilters } from './analyticsDataService';\nimport { InventoryActionService } from '../../pages/Inventory/services/inventoryActionService';\nimport type { Json } from '../../types/supabase/common';\n\n// Database row interfaces\ninterface SterilizationCycleRow {\n  id: string;\n  facility_id: string;\n  tool_batch_id: string | null;\n  autoclave_id?: string;\n  operator_id?: string;\n  user_id?: string;\n  cycle_date: string;\n  cycle_type: string;\n  temperature: number | null;\n  temperature_celsius?: number;\n  pressure: number | null;\n  pressure_psi?: number;\n  duration: number | null;\n  duration_minutes?: number;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface InventoryItemRow {\n  id: string;\n  facility_id: string;\n  name: string;\n  quantity: number | null;\n  data: Json;\n  created_at: string;\n  updated_at: string;\n}\n\n// Intelligence forecasting interfaces\nexport interface ToolReplacementForecast {\n  toolBatchId: string;\n  toolName: string;\n  currentLifecycle: number;\n  predictedEndOfLife: string;\n  confidence: number;\n  recommendedReorderDate: string;\n  supplierSuggestion: string;\n  estimatedCost: number;\n}\n\nexport interface AutoclaveCapacityForecast {\n  autoclaveId: string;\n  currentLoadPercentage: number;\n  queueLength: number;\n  predictedOverloadDate: string;\n  recommendedAction: 'add_autoclave' | 'extend_hours' | 'optimize_schedule';\n  timeline: string;\n  projectedPatientLoad: number;\n}\n\nexport interface InventoryInflationForecast {\n  category: string;\n  currentPrice: number;\n  priceIncrease: number;\n  inflationRate: number;\n  projectedYearEndPrice: number;\n  cheaperSupplierExists: boolean;\n  alternativeSupplier?: string;\n  costSavings?: number;\n}\n\nexport interface ClinicalStaffingForecast {\n  currentFTE: number;\n  recommendedFTE: number;\n  timeline: string;\n  workloadIncrease: number;\n  skillsetGaps: string[];\n  trainingRecommendations: string[];\n  estimatedCost: number;\n}\n\nexport interface AdminStaffingForecast {\n  currentWorkload: number;\n  projectedWorkload: number;\n  workloadExcess: number;\n  recommendedCoverage: string;\n  qualityIncidents: number;\n  resolutionLag: number;\n  priority: 'low' | 'medium' | 'high';\n}\n\nexport interface TheftLossEstimate {\n  estimatedLossPercentage: number;\n  estimatedLossValue: number;\n  flaggedItems: string[];\n  repeatOffenders: string[];\n  riskFactors: string[];\n  recommendedActions: string[];\n  confidence: number;\n}\n\nexport interface SupplyDepletionForecast {\n  itemName: string;\n  currentStock: number;\n  depletionDate: string;\n  reorderUrgency: 'low' | 'medium' | 'high' | 'critical';\n  recommendedReorderDate: string;\n  currentCost: number;\n  historicalCosts: number[];\n  costTrend: 'increasing' | 'decreasing' | 'stable';\n}\n\nexport interface ToolTurnoverUtilization {\n  toolBatchId: string;\n  toolName: string;\n  dailyCycleCount: number;\n  weeklyUtilization: number;\n  averageCyclesPerDay: number;\n  peakUsageHours: string[];\n  utilizationEfficiency: number;\n  turnoverRate: number; // How many times it's used per day\n  idleTimePercentage: number;\n  recommendedOptimization: string;\n  bottleneckIndicators: string[];\n  performanceScore: number;\n}\n\nexport interface AuditRiskScore {\n  overallRiskScore: number;\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  riskFactors: Array<{\n    factor: string;\n    severity: number;\n    description: string;\n  }>;\n  skippedIndicators: number;\n  incompleteCycles: number;\n  policyDrift: number;\n  recommendedActions: string[];\n}\n\nexport interface TrainingKnowledgeGaps {\n  usersWithGaps: Array<{\n    userId: string;\n    userName: string;\n    failedSteps: string[];\n    skippedContent: string[];\n    recommendedTraining: string[];\n    performanceMetrics: {\n      totalCycles: number;\n      successRate: number;\n      averageDuration: number;\n    };\n  }>;\n  overallGapScore: number;\n  criticalGaps: string[];\n  knowledgeHubRecommendations: string[];\n}\n\nexport interface EfficiencyROITracker {\n  timeSavedHours: number;\n  estimatedLaborSavings: number;\n  aiFeatureUsage: {\n    feature: string;\n    usageCount: number;\n    timeSaved: number;\n  }[];\n  automationEfficiency: number;\n  moduleContributions: Array<{\n    module: string;\n    timeSaved: number;\n    costSavings: number;\n    efficiency: number;\n  }>;\n  projectedAnnualSavings: number;\n}\n\nexport interface IntelligenceSummary {\n  toolReplacement: ToolReplacementForecast[];\n  autoclaveCapacity: AutoclaveCapacityForecast[];\n  inventoryInflation: InventoryInflationForecast[];\n  clinicalStaffing: ClinicalStaffingForecast;\n  adminStaffing: AdminStaffingForecast;\n  theftLoss: TheftLossEstimate;\n  supplyDepletion: SupplyDepletionForecast[];\n  toolTurnoverUtilization: ToolTurnoverUtilization[];\n  auditRisk: AuditRiskScore;\n  trainingGaps: TrainingKnowledgeGaps;\n  efficiencyROI: EfficiencyROITracker;\n  // Add missing metrics for optimization tips\n  sterilization: {\n    biPassRate: number;\n    cycleEfficiency: number;\n    qualityScore: number;\n  };\n  inventory: {\n    turnoverRate: number;\n    stockLevel: number;\n    reorderEfficiency: number;\n  };\n  lastUpdated: string;\n  confidence: number;\n}\n\nexport class ForecastingAnalyticsService {\n  private static instance: ForecastingAnalyticsService;\n  private cache: Map<\n    string,\n    { data: unknown; timestamp: number; ttl: number }\n  > = new Map();\n  private readonly DEFAULT_CACHE_TTL = 10 * 60 * 1000; // 10 minutes for forecasting\n\n  private constructor() {}\n\n  static getInstance(): ForecastingAnalyticsService {\n    if (!ForecastingAnalyticsService.instance) {\n      ForecastingAnalyticsService.instance = new ForecastingAnalyticsService();\n    }\n    return ForecastingAnalyticsService.instance;\n  }\n\n  /**\n   * üîß Tool Replacement Forecast\n   * Predict average lifecycle of tools based on cleaning cycles + BI/CI failure correlation\n   */\n  async getToolReplacementForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<ToolReplacementForecast[]> {\n    try {\n      const cacheKey = `tool_replacement_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<ToolReplacementForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      // Check if we have a valid facility ID before making Supabase calls\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for tool replacement forecast');\n        return [];\n      }\n\n      // Get sterilization data for tool lifecycle analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn(\n          'No sterilization data found for tool replacement forecast'\n        );\n        return [];\n      }\n\n      // Generate real forecasts based on actual data\n      const forecasts: ToolReplacementForecast[] = sterilizationData\n        .slice(0, 5)\n        .map((cycle: any, index: number) => {\n          // Calculate lifecycle based on actual cycle data\n          const cycleCount = sterilizationData.filter(\n            (c: any) => c.tool_batch_id === cycle.tool_batch_id\n          ).length;\n          const estimatedLifecycle = Math.min(\n            95,\n            Math.max(10, Math.floor(cycleCount * 2.5))\n          );\n\n          // Calculate realistic dates based on actual data\n          const avgCyclesPerDay = cycleCount / 90; // Over 90 days\n          const remainingCycles = Math.max(0, 100 - estimatedLifecycle);\n          const daysUntilEOL = remainingCycles / Math.max(0.1, avgCyclesPerDay);\n          const predictedEndOfLife = new Date(\n            Date.now() + daysUntilEOL * 24 * 60 * 60 * 1000\n          )\n            .toISOString()\n            .split('T')[0];\n\n          // Calculate confidence based on data quality\n          const confidence = Math.min(\n            0.95,\n            Math.max(0.6, 0.75 + cycleCount / 100)\n          );\n\n          // Calculate reorder date (30 days before EOL)\n          const reorderDate = new Date(\n            Date.now() + Math.max(7, daysUntilEOL - 30) * 24 * 60 * 60 * 1000\n          )\n            .toISOString()\n            .split('T')[0];\n\n          return {\n            toolBatchId:\n              cycle.tool_batch_id || `TB${String(index + 1).padStart(3, '0')}`,\n            toolName: `Tool Set ${String.fromCharCode(65 + index)}`,\n            currentLifecycle: estimatedLifecycle,\n            predictedEndOfLife,\n            confidence,\n            recommendedReorderDate: reorderDate,\n            supplierSuggestion: 'Contact procurement for supplier information',\n            estimatedCost: 0, // Will be populated from actual procurement data\n          };\n        });\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting tool replacement:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ‚è∞ Autoclave Capacity Planning\n   * Queue length trends, peak hours, overload predictions\n   */\n  async getAutoclaveCapacityForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<AutoclaveCapacityForecast[]> {\n    try {\n      const cacheKey = `autoclave_capacity_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<AutoclaveCapacityForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for autoclave capacity forecast');\n        return [];\n      }\n\n      // Get autoclave data from sterilization cycles\n      const { data: autoclaveData, error: autoclaveError } = await supabase\n        .from('sterilization_cycles')\n        .select('*')\n        .eq('facility_id', filters.facilityId as string)\n        .not('autoclave_id', 'is', null)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n        )\n        .order('created_at', { ascending: false });\n\n      if (autoclaveError || !autoclaveData || autoclaveData.length === 0) {\n        console.warn('No autoclave data found for capacity forecast');\n        return [];\n      }\n\n      // Get recent cycles for queue analysis\n      const { data: recentCycles, error: recentError } = await supabase\n        .from('sterilization_cycles')\n        .select('*')\n        .eq('facility_id', filters.facilityId as string)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n        )\n        .order('created_at', { ascending: false });\n\n      if (recentError) {\n        console.warn(\n          'Failed to fetch recent cycles for autoclave capacity forecast'\n        );\n        return [];\n      }\n\n      // Group by autoclave and analyze capacity\n      const autoclaveGroups = autoclaveData.reduce(\n        (acc: Record<string, any[]>, cycle: any) => {\n          const autoclaveId = cycle.autoclave_id;\n          if (!autoclaveId) return acc;\n          if (!acc[autoclaveId]) {\n            acc[autoclaveId] = [];\n          }\n          acc[autoclaveId].push(cycle);\n          return acc;\n        },\n        {} as Record<string, any[]>\n      );\n\n      const forecasts: AutoclaveCapacityForecast[] = Object.entries(\n        autoclaveGroups\n      ).map(([autoclaveId, cycles]) => {\n        const totalCycles = cycles.length;\n        const completedCycles = cycles.filter(\n          (cycle: any) => cycle.status === 'completed'\n        ).length;\n        const failedCycles = cycles.filter(\n          (cycle: any) => cycle.status === 'failed'\n        ).length;\n\n        // Calculate real load percentage based on actual cycle data\n        const avgCyclesPerDay = totalCycles / 30; // Over 30 days\n        const maxCapacityPerDay = 24; // Assuming 24 cycles per day max capacity\n        const currentLoadPercentage = Math.min(\n          100,\n          Math.max(10, Math.round((avgCyclesPerDay / maxCapacityPerDay) * 100))\n        );\n\n        // Calculate queue length from recent cycles (last 7 days)\n        const recentCyclesForQueue =\n          recentCycles?.filter(\n            (cycle: any) =>\n              (cycle.autoclave_id === autoclaveId &&\n                cycle.status === 'pending') ||\n              cycle.status === 'running'\n          ) || [];\n        const queueLength = recentCyclesForQueue.length;\n\n        // Calculate overload prediction based on actual usage trends\n        const usageTrend =\n          avgCyclesPerDay > 20\n            ? 'high'\n            : avgCyclesPerDay > 15\n              ? 'medium'\n              : 'low';\n        const daysUntilOverload =\n          usageTrend === 'high' ? 15 : usageTrend === 'medium' ? 45 : 90;\n        const predictedOverloadDate = new Date(\n          Date.now() + daysUntilOverload * 24 * 60 * 60 * 1000\n        )\n          .toISOString()\n          .split('T')[0];\n\n        // Determine recommended action based on actual metrics\n        let recommendedAction:\n          | 'add_autoclave'\n          | 'extend_hours'\n          | 'optimize_schedule';\n        let timeline: string;\n\n        if (currentLoadPercentage > 90 || failedCycles > totalCycles * 0.1) {\n          recommendedAction = 'add_autoclave';\n          timeline = 'Immediate';\n        } else if (currentLoadPercentage > 75 || queueLength > 5) {\n          recommendedAction = 'extend_hours';\n          timeline = 'Q1 2025';\n        } else if (currentLoadPercentage > 60) {\n          recommendedAction = 'optimize_schedule';\n          timeline = 'Q2 2025';\n        } else {\n          recommendedAction = 'optimize_schedule';\n          timeline = 'Q3 2025';\n        }\n\n        return {\n          autoclaveId,\n          currentLoadPercentage,\n          queueLength,\n          predictedOverloadDate,\n          recommendedAction,\n          timeline,\n          projectedPatientLoad: Math.round(completedCycles * 1.2), // Based on actual completed cycles\n        };\n      });\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting autoclave capacity:', error);\n      return [];\n    }\n  }\n\n  /**\n   * üí∏ Inventory Inflation Trend\n   * Price delta by category, supplier trends, regional inflation\n   */\n  async getInventoryInflationForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<InventoryInflationForecast[]> {\n    try {\n      const cacheKey = `inventory_inflation_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<InventoryInflationForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn(\n          'No facility ID provided for inventory inflation forecast'\n        );\n        return [];\n      }\n\n      // Get inventory data for price analysis using centralized service\n      const allItems = await InventoryActionService.getItems();\n\n      // Apply filters manually\n      let inventoryData = allItems;\n      if (filters.facilityId) {\n        inventoryData = allItems.filter(\n          (item) => item.facility_id === filters.facilityId\n        );\n      }\n\n      // Filter by date (last 365 days)\n      const oneYearAgo = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000);\n      inventoryData = inventoryData.filter(\n        (item) => item.created_at && new Date(item.created_at) >= oneYearAgo\n      );\n\n      // Sort by created_at descending\n      inventoryData.sort(\n        (a, b) =>\n          new Date(b.created_at || '').getTime() -\n          new Date(a.created_at || '').getTime()\n      );\n\n      if (!inventoryData || inventoryData.length === 0) {\n        console.warn('No inventory data found for inflation forecast');\n        return [];\n      }\n\n      // Group by category and analyze price trends\n      const categoryGroups = inventoryData.reduce(\n        (acc: Record<string, any[]>, item: any) => {\n          const category =\n            (item.data as { category?: string })?.category || 'Uncategorized';\n          if (!acc[category]) {\n            acc[category] = [];\n          }\n          acc[category].push(item);\n          return acc;\n        },\n        {} as Record<string, any[]>\n      );\n\n      const forecasts: InventoryInflationForecast[] = Object.entries(\n        categoryGroups\n      )\n        .map(([category, items]) => {\n          const prices = items\n            .map(\n              (item: any) =>\n                (item.data as { unit_cost?: number })?.unit_cost || 0\n            )\n            .filter((price: number) => price > 0);\n          if (prices.length === 0) return null;\n\n          const currentPrice = prices[prices.length - 1];\n          const historicalPrice = prices[0];\n          const priceIncrease = currentPrice - historicalPrice;\n          const inflationRate =\n            historicalPrice > 0 ? (priceIncrease / historicalPrice) * 100 : 0;\n\n          return {\n            category,\n            currentPrice,\n            priceIncrease,\n            inflationRate,\n            projectedYearEndPrice:\n              currentPrice * (1 + (inflationRate / 100) * 0.5), // Project 6 months\n            cheaperSupplierExists: false, // This should come from supplier comparison data\n            alternativeSupplier: undefined,\n            costSavings: 0,\n          };\n        })\n        .filter(Boolean) as InventoryInflationForecast[];\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting inventory inflation:', error);\n      return [];\n    }\n  }\n\n  /**\n   * üë©‚Äç‚öïÔ∏è Clinical Staffing Forecast\n   * Missed cleanings, time-to-task trends, tool backlog after hours\n   */\n  async getClinicalStaffingForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<ClinicalStaffingForecast[]> {\n    try {\n      const cacheKey = `clinical_staffing_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<ClinicalStaffingForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for clinical staffing forecast');\n        return [];\n      }\n\n      // Get sterilization data for staffing analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn(\n          'No sterilization data found for clinical staffing forecast'\n        );\n        return [];\n      }\n\n      // Analyze workload patterns\n      const totalCycles = sterilizationData.length;\n      const incompleteCycles = sterilizationData.filter(\n        (cycle: any) =>\n          cycle.status !== 'completed' && cycle.status !== 'failed'\n      ).length;\n\n      const currentFTE = 8.5; // This should come from actual staffing data\n      const workloadIncrease = Math.max(\n        0,\n        (incompleteCycles / totalCycles) * 100\n      );\n      const recommendedFTE =\n        workloadIncrease > 20 ? currentFTE + 0.5 : currentFTE;\n\n      const forecasts: ClinicalStaffingForecast[] = [\n        {\n          currentFTE,\n          recommendedFTE,\n          timeline:\n            workloadIncrease > 20 ? 'Next quarter' : 'Monitor for 3 months',\n          workloadIncrease,\n          skillsetGaps: [], // This should come from training/competency data\n          trainingRecommendations: [], // This should come from training gap analysis\n          estimatedCost: Math.round((recommendedFTE - currentFTE) * 50000), // Rough estimate\n        },\n      ];\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting clinical staffing:', error);\n      return [];\n    }\n  }\n\n  /**\n   * üìä Admin Staffing Forecast\n   * Audit log volume, expired tasks, user onboarding errors\n   */\n  async getAdminStaffingForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<AdminStaffingForecast[]> {\n    try {\n      const cacheKey = `admin_staffing_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<AdminStaffingForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for admin staffing forecast');\n        return [];\n      }\n\n      // Get sterilization data for admin workload analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn('No sterilization data found for admin staffing forecast');\n        return [];\n      }\n\n      // Calculate workload metrics based on actual data\n      const totalCycles = sterilizationData.length;\n      const incompleteCycles = sterilizationData.filter(\n        (cycle: any) =>\n          cycle.status !== 'completed' && cycle.status !== 'failed'\n      ).length;\n\n      const currentWorkload = totalCycles;\n      const projectedWorkload = Math.round(totalCycles * 1.1); // 10% growth projection\n      const workloadExcess = Math.max(0, projectedWorkload - currentWorkload);\n      const qualityIncidents = Math.floor(incompleteCycles * 0.3); // Estimate based on incomplete cycles\n      const resolutionLag =\n        incompleteCycles > 0\n          ? Math.max(1, Math.floor(incompleteCycles / 2))\n          : 0;\n\n      let priority: 'low' | 'medium' | 'high';\n      if (workloadExcess > 20) priority = 'high';\n      else if (workloadExcess > 10) priority = 'medium';\n      else priority = 'low';\n\n      const forecasts: AdminStaffingForecast[] = [\n        {\n          currentWorkload,\n          projectedWorkload,\n          workloadExcess,\n          recommendedCoverage:\n            workloadExcess > 15\n              ? 'Additional 0.5 FTE admin support'\n              : 'Current staffing adequate',\n          qualityIncidents,\n          resolutionLag,\n          priority,\n        },\n      ];\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting admin staffing:', error);\n      return [];\n    }\n  }\n\n  /**\n   * üïµÔ∏è Theft / Loss Estimation\n   * Scanned tool mismatch, rapid depletion without log match, non-standard hours usage\n   */\n  async getTheftLossEstimate(\n    filters: AnalyticsFilters = {}\n  ): Promise<TheftLossEstimate> {\n    try {\n      const cacheKey = `theft_loss_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<TheftLossEstimate>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for theft/loss estimation');\n        return {\n          estimatedLossPercentage: 0,\n          estimatedLossValue: 0,\n          flaggedItems: [],\n          repeatOffenders: [],\n          riskFactors: [],\n          recommendedActions: [],\n          confidence: 0,\n        };\n      }\n\n      // Get sterilization data for loss analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn('No sterilization data found for theft/loss estimation');\n        return {\n          estimatedLossPercentage: 0,\n          estimatedLossValue: 0,\n          flaggedItems: [],\n          repeatOffenders: [],\n          riskFactors: [],\n          recommendedActions: [],\n          confidence: 0,\n        };\n      }\n\n      // Analyze potential loss indicators\n      const totalCycles = sterilizationData.length;\n      const incompleteCycles = sterilizationData.filter(\n        (cycle: any) =>\n          cycle.status !== 'completed' && cycle.status !== 'failed'\n      ).length;\n\n      const estimatedLossPercentage = Math.min(\n        10,\n        Math.max(0, (incompleteCycles / totalCycles) * 100)\n      );\n      const estimatedLossValue = Math.round(estimatedLossPercentage * 1000); // Rough estimate based on percentage\n\n      // Identify flagged items based on incomplete cycles\n      const flaggedItems = sterilizationData\n        .filter((cycle: any) => cycle.status !== 'completed')\n        .map((cycle: any) => `Tool ${cycle.id}`)\n        .slice(0, 3);\n\n      const estimate: TheftLossEstimate = {\n        estimatedLossPercentage: Math.round(estimatedLossPercentage * 10) / 10,\n        estimatedLossValue,\n        flaggedItems:\n          flaggedItems.length > 0\n            ? flaggedItems\n            : ['No specific items flagged'],\n        repeatOffenders: [], // This should come from actual user tracking data\n        riskFactors:\n          incompleteCycles > 0\n            ? [\n                'Incomplete sterilization cycles',\n                'Missing cycle documentation',\n                'Protocol non-compliance',\n              ]\n            : ['Minimal risk factors detected'],\n        recommendedActions: [\n          'Complete incomplete sterilization cycles',\n          'Review cycle documentation procedures',\n          'Monitor compliance metrics',\n        ],\n        confidence: Math.max(0.5, 1 - estimatedLossPercentage / 100),\n      };\n\n      this.setCachedData(cacheKey, estimate);\n      return estimate;\n    } catch (error) {\n      console.error('Error estimating theft/loss:', error);\n      return {\n        estimatedLossPercentage: 0,\n        estimatedLossValue: 0,\n        flaggedItems: [],\n        repeatOffenders: [],\n        riskFactors: [],\n        recommendedActions: [],\n        confidence: 0,\n      };\n    }\n  }\n\n  /**\n   * üîÆ Supply Depletion Forecast\n   * Usage trend vs. stock, reorder window, supplier delay\n   */\n  async getSupplyDepletionForecast(\n    filters: AnalyticsFilters = {}\n  ): Promise<SupplyDepletionForecast[]> {\n    try {\n      const cacheKey = `supply_depletion_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<SupplyDepletionForecast[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for supply depletion forecast');\n        return [];\n      }\n\n      // Get real inventory data using centralized service\n      const allItems = await InventoryActionService.getItems();\n\n      // Apply filters manually\n      let inventoryData = allItems;\n      if (filters.facilityId) {\n        inventoryData = allItems.filter(\n          (item) => item.facility_id === filters.facilityId\n        );\n      }\n\n      // Sort by quantity ascending\n      inventoryData.sort((a, b) => (a.quantity || 0) - (b.quantity || 0));\n\n      if (!inventoryData || inventoryData.length === 0) {\n        console.warn('No inventory data found for supply depletion forecast');\n        return [];\n      }\n\n      // Generate real forecasts based on actual inventory data\n      const forecasts: SupplyDepletionForecast[] = inventoryData\n        .slice(0, 8)\n        .map((item: any, index: number) => {\n          const currentStock = item.quantity || 0;\n          const reorderPoint =\n            (item.data as { reorder_point?: number })?.reorder_point || 100;\n          const unitCost =\n            (item.data as { unit_cost?: number })?.unit_cost || 50;\n\n          // Calculate depletion urgency based on stock vs reorder point\n          let reorderUrgency: 'low' | 'medium' | 'high' | 'critical';\n          if (currentStock <= reorderPoint * 0.5) reorderUrgency = 'critical';\n          else if (currentStock <= reorderPoint * 0.8) reorderUrgency = 'high';\n          else if (currentStock <= reorderPoint * 1.2)\n            reorderUrgency = 'medium';\n          else reorderUrgency = 'low';\n\n          // Calculate depletion date based on usage patterns\n          const daysUntilDepletion = Math.ceil(\n            currentStock / (reorderPoint / 30)\n          ); // Assume monthly usage\n          const depletionDate = new Date(\n            Date.now() + daysUntilDepletion * 24 * 60 * 60 * 1000\n          );\n          const reorderDate = new Date(\n            depletionDate.getTime() - 7 * 24 * 60 * 60 * 1000\n          ); // Reorder 7 days before depletion\n\n          return {\n            itemName: item.name || `Item ${index + 1}`,\n            currentStock,\n            depletionDate: depletionDate.toISOString().split('T')[0],\n            reorderUrgency,\n            recommendedReorderDate: reorderDate.toISOString().split('T')[0],\n            currentCost: unitCost,\n            historicalCosts: [unitCost * 0.95, unitCost * 0.98, unitCost],\n            costTrend:\n              unitCost >\n              (((item.data as Record<string, unknown>)\n                ?.last_restocked_cost as number) || unitCost)\n                ? 'increasing'\n                : 'stable',\n          };\n        });\n\n      this.setCachedData(cacheKey, forecasts);\n      return forecasts;\n    } catch (error) {\n      console.error('Error forecasting supply depletion:', error);\n      return [];\n    }\n  }\n\n  /**\n   * üîÑ Tool Turnover & Utilization Analysis\n   * Track tool usage frequency, daily cycle counts, and utilization patterns\n   */\n  async getToolTurnoverUtilization(\n    filters: AnalyticsFilters = {}\n  ): Promise<ToolTurnoverUtilization[]> {\n    try {\n      const cacheKey = `tool_turnover_utilization_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<ToolTurnoverUtilization[]>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for tool turnover utilization');\n        return [];\n      }\n\n      // Get sterilization data for tool utilization analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn(\n          'No sterilization data found for tool turnover utilization'\n        );\n        return [];\n      }\n\n      // Group by tool batch and analyze utilization\n      const toolGroups = sterilizationData.reduce(\n        (acc: Record<string, any[]>, cycle: any) => {\n          const toolBatchId = cycle.tool_batch_id;\n          if (!toolBatchId) return acc;\n\n          if (!acc[toolBatchId]) {\n            acc[toolBatchId] = [];\n          }\n          acc[toolBatchId].push(cycle);\n          return acc;\n        },\n        {} as Record<string, any[]>\n      );\n\n      const utilization: ToolTurnoverUtilization[] = Object.entries(\n        toolGroups\n      ).map(([toolBatchId, cycles]) => {\n        const dailyCycleCount = cycles.length;\n        const weeklyUtilization = Math.min(100, (dailyCycleCount / 7) * 100);\n        const averageCyclesPerDay = dailyCycleCount / 7;\n\n        // Calculate peak usage hours based on cycle timestamps\n        const peakHours = this.calculatePeakHours(cycles as any[]);\n        const utilizationEfficiency = Math.min(\n          100,\n          Math.max(50, weeklyUtilization)\n        );\n        const turnoverRate = averageCyclesPerDay;\n        const idleTimePercentage = Math.max(0, 100 - utilizationEfficiency);\n\n        return {\n          toolBatchId,\n          toolName: `Tool ${toolBatchId}`,\n          dailyCycleCount,\n          weeklyUtilization,\n          averageCyclesPerDay,\n          peakUsageHours: peakHours,\n          utilizationEfficiency,\n          turnoverRate,\n          idleTimePercentage,\n          recommendedOptimization: this.getOptimizationRecommendation(\n            utilizationEfficiency\n          ),\n          bottleneckIndicators: this.getBottleneckIndicators(\n            utilizationEfficiency\n          ),\n          performanceScore: Math.round(utilizationEfficiency),\n        };\n      });\n\n      this.setCachedData(cacheKey, utilization);\n      return utilization;\n    } catch (error) {\n      console.error('Error analyzing tool turnover utilization:', error);\n      return [];\n    }\n  }\n\n  private calculatePeakHours(cycles: any[]): string[] {\n    // Group cycles by hour and find peak usage times\n    const hourCounts = new Array(24).fill(0);\n    cycles.forEach((cycle: any) => {\n      if (cycle.created_at) {\n        const hour = new Date(cycle.created_at).getHours();\n        hourCounts[hour]++;\n      }\n    });\n\n    const maxCount = Math.max(...hourCounts);\n    const peakHours = hourCounts\n      .map((count, hour) => ({ count, hour }))\n      .filter(({ count }) => count >= maxCount * 0.8)\n      .map(({ hour }) => `${hour.toString().padStart(2, '0')}:00`)\n      .slice(0, 4); // Limit to 4 peak hours\n\n    return peakHours.length > 0 ? peakHours : ['09:00', '12:00', '15:00'];\n  }\n\n  private getOptimizationRecommendation(efficiency: number): string {\n    if (efficiency >= 90)\n      return 'Excellent utilization - maintain current practices';\n    if (efficiency >= 80)\n      return 'Good utilization - minor optimizations possible';\n    if (efficiency >= 70)\n      return 'Moderate utilization - consider schedule optimization';\n    return 'Low utilization - review tool allocation and scheduling';\n  }\n\n  private getBottleneckIndicators(efficiency: number): string[] {\n    const indicators = [];\n    if (efficiency < 80) indicators.push('Low utilization efficiency');\n    if (efficiency < 70) indicators.push('Significant idle time detected');\n    return indicators.length > 0\n      ? indicators\n      : ['Minimal bottlenecks detected'];\n  }\n\n  /**\n   * üö® Audit Risk Score\n   * Missed indicators, skipped steps, no tool logs, policy drift\n   */\n  async getAuditRiskScore(\n    filters: AnalyticsFilters = {}\n  ): Promise<AuditRiskScore | null> {\n    try {\n      const cacheKey = `audit_risk_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<AuditRiskScore>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for audit risk score');\n        return null;\n      }\n\n      // Get sterilization data for risk assessment\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (sterilizationError || !sterilizationData) {\n        console.warn(\n          'Failed to fetch sterilization data for audit risk assessment'\n        );\n        return null;\n      }\n\n      // Calculate risk factors based on actual data\n      const totalCycles = sterilizationData.length;\n      const incompleteCycles = sterilizationData.filter(\n        (cycle: any) =>\n          cycle.status !== 'completed' && cycle.status !== 'failed'\n      ).length;\n\n      // Get actual BI/CI test data from biological_indicators table\n      const { data: biTestData, error: biError } = await supabase\n        .from('biological_indicators')\n        .select('*')\n        .eq('facility_id', filters.facilityId as string)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      const skippedIndicators =\n        biError || !biTestData\n          ? 0\n          : biTestData.filter(\n              (test: any) =>\n                test.status === 'skipped' || test.status === 'pending'\n            ).length;\n      const policyDrift = Math.max(0, (incompleteCycles / totalCycles) * 100);\n\n      // Calculate overall risk score\n      const overallRiskScore = Math.min(\n        100,\n        Math.max(\n          0,\n          (incompleteCycles / totalCycles) * 40 +\n            skippedIndicators * 15 +\n            policyDrift * 0.4\n        )\n      );\n\n      let riskLevel: 'low' | 'medium' | 'high' | 'critical';\n      if (overallRiskScore >= 80) riskLevel = 'critical';\n      else if (overallRiskScore >= 60) riskLevel = 'high';\n      else if (overallRiskScore >= 40) riskLevel = 'medium';\n      else riskLevel = 'low';\n\n      const riskScore: AuditRiskScore = {\n        overallRiskScore: Math.round(overallRiskScore),\n        riskLevel,\n        riskFactors: [\n          {\n            factor: 'Incomplete cycles',\n            severity: Math.min(\n              10,\n              Math.max(1, Math.round((incompleteCycles / totalCycles) * 10))\n            ),\n            description: `${incompleteCycles} sterilization cycles incomplete this week`,\n          },\n          {\n            factor: 'Policy adherence',\n            severity: Math.min(\n              10,\n              Math.max(1, Math.round((100 - policyDrift) / 10))\n            ),\n            description: `Protocol adherence at ${Math.round(100 - policyDrift)}%`,\n          },\n        ],\n        skippedIndicators,\n        incompleteCycles,\n        policyDrift,\n        recommendedActions: [\n          'Complete incomplete sterilization cycles',\n          'Review and reinforce protocol training',\n          'Monitor BI/CI test completion rates',\n        ],\n      };\n\n      this.setCachedData(cacheKey, riskScore);\n      return riskScore;\n    } catch (error) {\n      console.error('Error assessing audit risk:', error);\n      return null;\n    }\n  }\n\n  /**\n   * üìö Training & Knowledge Gaps\n   * Course engagement vs. errors, unread policies, failed quiz attempts\n   */\n  async getTrainingKnowledgeGaps(\n    filters: AnalyticsFilters = {}\n  ): Promise<TrainingKnowledgeGaps | null> {\n    try {\n      const cacheKey = `training_gaps_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<TrainingKnowledgeGaps>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for training knowledge gaps');\n        return null;\n      }\n\n      // Get sterilization data for training gap analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn('No sterilization data found for training gap analysis');\n        return null;\n      }\n\n      // Analyze user performance patterns\n      const userGroups = sterilizationData.reduce(\n        (\n          acc: Record<\n            string,\n            {\n              cycles: any[];\n              failedSteps: string[];\n              performanceMetrics: Record<string, unknown>[];\n            }\n          >,\n          cycle: any\n        ) => {\n          const userId = cycle.operator_id || cycle.user_id;\n          if (!userId) return acc;\n\n          if (!acc[userId]) {\n            acc[userId] = {\n              cycles: [],\n              failedSteps: [],\n              performanceMetrics: [],\n            };\n          }\n          acc[userId].cycles.push(cycle);\n\n          // Track failed or incomplete cycles as failed steps\n          if (cycle.status !== 'completed') {\n            acc[userId].failedSteps.push(`Cycle ${cycle.id} - ${cycle.status}`);\n          }\n\n          // Track performance metrics for all users\n          if (cycle.status === 'completed') {\n            acc[userId].performanceMetrics.push({\n              cycleId: cycle.id as string,\n              duration: (cycle.duration_minutes as number) || 0,\n              temperature: (cycle.temperature_celsius as number) || 0,\n              pressure: (cycle.pressure_psi as number) || 0,\n            });\n          }\n\n          return acc;\n        },\n        {} as Record<\n          string,\n          {\n            cycles: any[];\n            failedSteps: string[];\n            performanceMetrics: Record<string, unknown>[];\n          }\n        >\n      );\n\n      const usersWithGaps = Object.entries(userGroups).map(\n        ([userId, data]: [\n          string,\n          {\n            cycles: any[];\n            failedSteps: string[];\n            performanceMetrics: Record<string, unknown>[];\n          },\n        ]) => {\n          const hasFailures = data.failedSteps.length > 0;\n          const avgDuration =\n            data.performanceMetrics.length > 0\n              ? data.performanceMetrics.reduce(\n                  (sum: number, m: Record<string, unknown>) =>\n                    sum + (m.duration as number),\n                  0\n                ) / data.performanceMetrics.length\n              : 0;\n\n          // Generate training recommendations based on performance\n          let recommendedTraining: string[] = [];\n          if (hasFailures) {\n            recommendedTraining = [\n              'Review sterilization protocols',\n              'Complete cycle documentation training',\n              'Practice emergency shutdown procedures',\n            ];\n          } else if (avgDuration > 60) {\n            recommendedTraining = [\n              'Optimize cycle timing procedures',\n              'Review load preparation best practices',\n              'Efficiency improvement training',\n            ];\n          } else {\n            recommendedTraining = [\n              'Maintain current training standards',\n              'Advanced sterilization techniques',\n              'Quality assurance best practices',\n            ];\n          }\n\n          return {\n            userId,\n            userName: `User ${userId}`, // This should come from actual user data\n            failedSteps: data.failedSteps.slice(0, 3), // Limit to 3 failed steps\n            skippedContent: [], // This should come from actual training completion data\n            recommendedTraining,\n            performanceMetrics: {\n              totalCycles: data.cycles.length,\n              successRate:\n                data.cycles.length > 0\n                  ? ((data.cycles.length - data.failedSteps.length) /\n                      data.cycles.length) *\n                    100\n                  : 100,\n              averageDuration: Math.round(avgDuration),\n            },\n          };\n        }\n      );\n\n      // Calculate overall gap score based on multiple factors\n      const totalUsers = usersWithGaps.length;\n      const usersWithFailures = usersWithGaps.filter(\n        (user) => user.failedSteps.length > 0\n      ).length;\n      const averageSuccessRate =\n        totalUsers > 0\n          ? usersWithGaps.reduce(\n              (sum, user) => sum + user.performanceMetrics.successRate,\n              0\n            ) / totalUsers\n          : 100;\n\n      const overallGapScore = Math.min(\n        100,\n        Math.max(\n          0,\n          (usersWithFailures / totalUsers) * 40 + // 40% weight for failures\n            ((100 - averageSuccessRate) / 100) * 30 + // 30% weight for success rate\n            (totalUsers < 3 ? 20 : 0) + // 20% weight for low user count\n            (usersWithGaps.some(\n              (user) => user.performanceMetrics.averageDuration > 60\n            )\n              ? 10\n              : 0) // 10% weight for efficiency\n        )\n      );\n\n      const gaps: TrainingKnowledgeGaps = {\n        usersWithGaps,\n        overallGapScore: Math.round(overallGapScore),\n        criticalGaps: usersWithGaps\n          .filter(\n            (user) =>\n              user.failedSteps.length > 2 ||\n              user.performanceMetrics.successRate < 80\n          )\n          .map(() => 'Sterilization protocol adherence'),\n        knowledgeHubRecommendations: [\n          'Review sterilization SOPs',\n          'Complete cycle documentation training',\n          'Monitor user performance metrics',\n          'Efficiency optimization training',\n          'Quality assurance procedures',\n        ],\n      };\n\n      this.setCachedData(cacheKey, gaps);\n      return gaps;\n    } catch (error) {\n      console.error('Error analyzing training gaps:', error);\n      return null;\n    }\n  }\n\n  /**\n   * üí∞ Efficiency & ROI Tracker\n   * Time saved per module, AI feature usage, automation vs. manual\n   */\n  async getEfficiencyROITracker(\n    filters: AnalyticsFilters = {}\n  ): Promise<EfficiencyROITracker | null> {\n    try {\n      const cacheKey = `efficiency_roi_${JSON.stringify(filters)}`;\n      const cached = this.getCachedData<EfficiencyROITracker>(cacheKey);\n      if (cached) return cached;\n\n      if (!filters.facilityId) {\n        console.warn('No facility ID provided for efficiency ROI tracking');\n        return null;\n      }\n\n      // Get sterilization data for efficiency analysis\n      const { data: sterilizationData, error: sterilizationError } =\n        await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('facility_id', filters.facilityId as string)\n          .gte(\n            'created_at',\n            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n          )\n          .order('created_at', { ascending: false });\n\n      if (\n        sterilizationError ||\n        !sterilizationData ||\n        sterilizationData.length === 0\n      ) {\n        console.warn('No sterilization data found for efficiency ROI tracking');\n        return null;\n      }\n\n      // Calculate efficiency metrics based on actual data\n      const totalCycles = sterilizationData.length;\n      const completedCycles = sterilizationData.filter(\n        (cycle: any) => cycle.status === 'completed'\n      ).length;\n      const efficiencyRate =\n        totalCycles > 0 ? (completedCycles / totalCycles) * 100 : 0;\n\n      // Estimate time savings based on efficiency improvements\n      const timeSavedHours = Math.round((efficiencyRate / 100) * 40); // Base 40 hours\n      const estimatedLaborSavings = timeSavedHours * 42; // $42/hour average rate\n      const projectedAnnualSavings = estimatedLaborSavings * 12;\n\n      const roi: EfficiencyROITracker = {\n        timeSavedHours,\n        estimatedLaborSavings,\n        aiFeatureUsage: [\n          {\n            feature: 'Automated scheduling',\n            usageCount: Math.floor(totalCycles * 0.8),\n            timeSaved: Math.round(timeSavedHours * 0.3),\n          },\n          {\n            feature: 'Smart inventory alerts',\n            usageCount: Math.floor(totalCycles * 0.6),\n            timeSaved: Math.round(timeSavedHours * 0.2),\n          },\n          {\n            feature: 'Predictive maintenance',\n            usageCount: Math.floor(totalCycles * 0.4),\n            timeSaved: Math.round(timeSavedHours * 0.1),\n          },\n        ],\n        automationEfficiency: Math.round(efficiencyRate),\n        moduleContributions: [\n          {\n            module: 'Sterilization',\n            timeSaved: Math.round(timeSavedHours * 0.5),\n            costSavings: Math.round(estimatedLaborSavings * 0.5),\n            efficiency: Math.round(efficiencyRate),\n          },\n          {\n            module: 'Inventory',\n            timeSaved: Math.round(timeSavedHours * 0.3),\n            costSavings: Math.round(estimatedLaborSavings * 0.3),\n            efficiency: Math.round(efficiencyRate * 0.9),\n          },\n          {\n            module: 'Environmental',\n            timeSaved: Math.round(timeSavedHours * 0.2),\n            costSavings: Math.round(estimatedLaborSavings * 0.2),\n            efficiency: Math.round(efficiencyRate * 0.8),\n          },\n        ],\n        projectedAnnualSavings,\n      };\n\n      this.setCachedData(cacheKey, roi);\n      return roi;\n    } catch (error) {\n      console.error('Error tracking efficiency ROI:', error);\n      return null;\n    }\n  }\n\n  /**\n   * üî¨ Get sterilization metrics for optimization tips\n   */\n  private async getSterilizationMetrics(\n    filters: AnalyticsFilters = {}\n  ): Promise<{\n    biPassRate: number;\n    cycleEfficiency: number;\n    qualityScore: number;\n  }> {\n    try {\n      if (!filters.facilityId) {\n        return { biPassRate: 0, cycleEfficiency: 0, qualityScore: 0 };\n      }\n\n      // Get BI test results for pass rate calculation\n      const { data: biResults } = await supabase\n        .from('bi_test_results')\n        .select('*')\n        .eq('facility_id', filters.facilityId as string)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      // Get sterilization cycles for efficiency calculation\n      const { data: cycles } = await supabase\n        .from('sterilization_cycles')\n        .select('*')\n        .eq('facility_id', filters.facilityId as string)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      // Calculate BI pass rate\n      let biPassRate = 100;\n      if (biResults && biResults.length > 0) {\n        const passedTests = biResults.filter(\n          (result: any) => result.result === 'pass'\n        ).length;\n        biPassRate = Math.round((passedTests / biResults.length) * 100);\n      }\n\n      // Calculate cycle efficiency\n      let cycleEfficiency = 100;\n      if (cycles && cycles.length > 0) {\n        const completedCycles = cycles.filter(\n          (cycle: any) => cycle.status === 'completed'\n        ).length;\n        cycleEfficiency = Math.round((completedCycles / cycles.length) * 100);\n      }\n\n      // Calculate quality score (average of pass rate and efficiency)\n      const qualityScore = Math.round((biPassRate + cycleEfficiency) / 2);\n\n      return { biPassRate, cycleEfficiency, qualityScore };\n    } catch (error) {\n      console.error('Error getting sterilization metrics:', error);\n      return { biPassRate: 0, cycleEfficiency: 0, qualityScore: 0 };\n    }\n  }\n\n  /**\n   * üì¶ Get inventory metrics for optimization tips\n   */\n  private async getInventoryMetrics(filters: AnalyticsFilters = {}): Promise<{\n    turnoverRate: number;\n    stockLevel: number;\n    reorderEfficiency: number;\n  }> {\n    try {\n      if (!filters.facilityId) {\n        return { turnoverRate: 0, stockLevel: 0, reorderEfficiency: 0 };\n      }\n\n      // Get inventory items for turnover calculation using centralized service\n      const allItems = await InventoryActionService.getItems();\n\n      // Apply facility filter manually\n      let inventoryItems = allItems;\n      if (filters.facilityId) {\n        inventoryItems = allItems.filter(\n          (item) => item.facility_id === filters.facilityId\n        );\n      }\n\n      // Calculate turnover rate (simplified - items used in last 30 days)\n      let turnoverRate = 80; // Default to good rate\n      if (inventoryItems && inventoryItems.length > 0) {\n        const activeItems = inventoryItems.filter(\n          (item) => item.status === 'active'\n        ).length;\n        const totalItems = inventoryItems.length;\n        if (totalItems > 0) {\n          // Simulate turnover based on active vs total items\n          turnoverRate = Math.round((activeItems / totalItems) * 100);\n        }\n      }\n\n      // Calculate stock level (percentage of items above reorder point)\n      let stockLevel = 100;\n      if (inventoryItems && inventoryItems.length > 0) {\n        const wellStockedItems = inventoryItems.filter(\n          (item) => (item.quantity as number) > (item.reorder_point as number)\n        ).length;\n        stockLevel = Math.round(\n          (wellStockedItems / inventoryItems.length) * 100\n        );\n      }\n\n      // Calculate reorder efficiency (simplified)\n      const reorderEfficiency = Math.round((turnoverRate + stockLevel) / 2);\n\n      return { turnoverRate, stockLevel, reorderEfficiency };\n    } catch (error) {\n      console.error('Error getting inventory metrics:', error);\n      return { turnoverRate: 0, stockLevel: 0, reorderEfficiency: 0 };\n    }\n  }\n\n  /**\n   * üß† Get comprehensive intelligence summary\n   * All forecasting metrics in one call\n   */\n  async getIntelligenceSummary(\n    filters: AnalyticsFilters = {},\n    forceRefresh = false\n  ): Promise<IntelligenceSummary> {\n    try {\n      const cacheKey = `intelligence_summary_${JSON.stringify(filters)}`;\n\n      // Clear cache if force refresh is requested\n      if (forceRefresh) {\n        this.clearCache('intelligence_summary');\n      }\n\n      const cached = this.getCachedData<IntelligenceSummary>(cacheKey);\n      if (cached && !forceRefresh) return cached;\n\n      const [\n        toolReplacement,\n        autoclaveCapacity,\n        inventoryInflation,\n        clinicalStaffingArray,\n        adminStaffingArray,\n        theftLoss,\n        supplyDepletion,\n        toolTurnoverUtilization,\n        auditRisk,\n        trainingGaps,\n        efficiencyROI,\n        sterilizationMetrics,\n        inventoryMetrics,\n      ] = await Promise.all([\n        this.getToolReplacementForecast(filters),\n        this.getAutoclaveCapacityForecast(filters),\n        this.getInventoryInflationForecast(filters),\n        this.getClinicalStaffingForecast(filters),\n        this.getAdminStaffingForecast(filters),\n        this.getTheftLossEstimate(filters),\n        this.getSupplyDepletionForecast(filters),\n        this.getToolTurnoverUtilization(filters),\n        this.getAuditRiskScore(filters),\n        this.getTrainingKnowledgeGaps(filters),\n        this.getEfficiencyROITracker(filters),\n        this.getSterilizationMetrics(filters),\n        this.getInventoryMetrics(filters),\n      ]);\n\n      // Extract first item from arrays for single object fields\n      const clinicalStaffing = clinicalStaffingArray[0] || null;\n      const adminStaffing = adminStaffingArray[0] || null;\n\n      const summary: IntelligenceSummary = {\n        toolReplacement,\n        autoclaveCapacity,\n        inventoryInflation,\n        clinicalStaffing,\n        adminStaffing,\n        theftLoss,\n        supplyDepletion,\n        toolTurnoverUtilization,\n        auditRisk: auditRisk || {\n          overallRiskScore: 0,\n          riskLevel: 'low' as const,\n          riskFactors: [],\n          skippedIndicators: 0,\n          incompleteCycles: 0,\n          policyDrift: 0,\n          recommendedActions: [],\n        },\n        trainingGaps: trainingGaps || {\n          usersWithGaps: [],\n          overallGapScore: 0,\n          criticalGaps: [],\n          knowledgeHubRecommendations: [],\n        },\n        efficiencyROI: efficiencyROI || {\n          timeSavedHours: 0,\n          estimatedLaborSavings: 0,\n          aiFeatureUsage: [],\n          automationEfficiency: 0,\n          moduleContributions: [],\n          projectedAnnualSavings: 0,\n        },\n        sterilization: sterilizationMetrics,\n        inventory: inventoryMetrics,\n        lastUpdated: new Date().toISOString(),\n        confidence: 0.89,\n      };\n\n      this.setCachedData(cacheKey, summary);\n      return summary;\n    } catch (error) {\n      console.error('Error generating intelligence summary:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear cache for specific intelligence module or all modules\n   */\n  clearCache(module?: string): void {\n    if (module) {\n      const keysToDelete = Array.from(this.cache.keys()).filter((key) =>\n        key.startsWith(module)\n      );\n      keysToDelete.forEach((key) => this.cache.delete(key));\n    } else {\n      this.cache.clear();\n    }\n  }\n\n  private getCachedData<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      return cached.data as T;\n    }\n    this.cache.delete(key);\n    return null;\n  }\n\n  private setCachedData(\n    key: string,\n    data: unknown,\n    ttl: number = this.DEFAULT_CACHE_TTL\n  ): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl,\n    });\n  }\n}\n\nexport default ForecastingAnalyticsService;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\intelligenceIntegrationService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 436,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { KnowledgeHubService } from '../../pages/KnowledgeHub/services/knowledgeHubService';\nimport { supabase } from '../../lib/supabaseClient';\n\nexport interface KnowledgeHubIntegration {\n  contentId: string;\n  title: string;\n  category: string;\n  relevance: number;\n  lastUpdated: string;\n  url: string;\n}\n\nexport interface SupplierIntegration {\n  supplierId: string;\n  name: string;\n  category: string;\n  rating: number;\n  deliveryTime: number;\n  costCompetitiveness: number;\n  reliability: number;\n  contactInfo: {\n    email: string;\n    phone: string;\n    website?: string;\n  };\n}\n\nexport interface AuditTrailIntegration {\n  actionId: string;\n  timestamp: string;\n  userId: string;\n  userName: string;\n  action: string;\n  details: string;\n  impact: 'low' | 'medium' | 'high';\n  status: 'pending' | 'completed' | 'failed';\n}\n\nexport interface IntegrationMetrics {\n  knowledgeHubArticles: number;\n  activeSuppliers: number;\n  recentAuditActions: number;\n  integrationHealth: number;\n  lastSync: string;\n}\n\n// Row types for Supabase\ninterface SupplierPerformanceRow {\n  id: string;\n  name: string;\n  category: string;\n  rating?: number | null;\n  delivery_time?: number | null;\n  reliability_score?: number | null;\n  email?: string | null;\n  phone?: string | null;\n  website?: string | null;\n}\n\ninterface AuditLogRow {\n  id: string;\n  timestamp: string;\n  user_id: string;\n  user_name?: string | null;\n  action: string;\n  details: string;\n  status?: 'pending' | 'completed' | 'failed';\n  module?: string | null;\n  created_at?: string;\n}\n\ninterface InventorySupplierRow {\n  id: string;\n  name: string;\n  status: string;\n}\n\nexport class IntelligenceIntegrationService {\n  static async getKnowledgeHubContent(\n    categories: string[],\n    keywords: string[],\n    limit: number = 10\n  ): Promise<KnowledgeHubIntegration[]> {\n    try {\n      const contentItems = await KnowledgeHubService.getKnowledgeArticles();\n\n      const filteredContent = contentItems.filter(\n        (content) =>\n          categories.includes(content.category.toLowerCase()) &&\n          keywords.some(\n            (keyword) =>\n              content.title.toLowerCase().includes(keyword.toLowerCase()) ||\n              content.category.toLowerCase().includes(keyword.toLowerCase())\n          )\n      );\n\n      const integrationContent: KnowledgeHubIntegration[] = filteredContent.map(\n        (content) => ({\n          contentId: content.id,\n          title: content.title,\n          category: content.category.toLowerCase(),\n          relevance: this.calculateRelevance(\n            content as unknown as Record<string, unknown>,\n            keywords\n          ),\n          lastUpdated: content.lastUpdated || new Date().toISOString(),\n          url: `/knowledge-hub/${content.category.toLowerCase()}/${content.id}`,\n        })\n      );\n\n      return integrationContent\n        .sort((a, b) => b.relevance - a.relevance)\n        .slice(0, limit);\n    } catch (error) {\n      console.error('Error fetching Knowledge Hub content:', error);\n      return [];\n    }\n  }\n\n  static async getSupplierRecommendations(\n    category: string,\n    budget: number,\n    deliveryUrgency: 'low' | 'medium' | 'high' | 'critical'\n  ): Promise<SupplierIntegration[]> {\n    try {\n      const { data: suppliers, error } = await supabase\n        .from('supplier_performance')\n        .select('*')\n        .eq('category', category);\n\n      if (error) {\n        console.error('Error fetching suppliers:', error);\n        return this.getFallbackSuppliers(category, 10);\n      }\n\n      if (!suppliers || suppliers.length === 0) {\n        return [];\n      }\n\n      const integrationSuppliers: SupplierIntegration[] = suppliers.map(\n        (supplier: any) => ({\n          supplierId: String(supplier.id),\n          name: supplier.name ?? '',\n          category: supplier.category ?? category,\n          rating: supplier.rating ?? 4.0,\n          deliveryTime: supplier.delivery_time ?? 5,\n          costCompetitiveness: this.calculateCostCompetitiveness(\n            supplier as SupplierPerformanceRow,\n            budget\n          ),\n          reliability: supplier.reliability_score ?? 8.5,\n          contactInfo: {\n            email: supplier.email ?? '',\n            phone: supplier.phone ?? '',\n            website: supplier.website ?? undefined,\n          },\n        })\n      );\n\n      const urgencyMultiplier = { low: 1, medium: 1.2, high: 1.5, critical: 2 };\n      return integrationSuppliers\n        .filter((supplier) => supplier.costCompetitiveness * 10 <= budget)\n        .sort((a, b) => {\n          const aScore =\n            a.rating * urgencyMultiplier[deliveryUrgency] +\n            (10 - a.deliveryTime);\n          const bScore =\n            b.rating * urgencyMultiplier[deliveryUrgency] +\n            (10 - b.deliveryTime);\n          return bScore - aScore;\n        });\n    } catch (error) {\n      console.error('Error fetching supplier recommendations:', error);\n      return [];\n    }\n  }\n\n  static async getAuditTrail(\n    userId?: string,\n    actionType?: string,\n    timeframe?: { startDate: string; endDate: string },\n    limit: number = 50\n  ): Promise<AuditTrailIntegration[]> {\n    try {\n      // Get current user's facility ID\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get user's facility ID from users table\n      const { data: userProfile } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      const facilityId =\n        userProfile?.facility_id || '550e8400-e29b-41d4-a716-446655440000';\n\n      let query = supabase\n        .from('audit_logs')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .order('timestamp', { ascending: false })\n        .limit(limit);\n\n      if (userId) query = query.eq('user_id', userId);\n      if (actionType) query = query.ilike('action', `%${actionType}%`);\n      if (timeframe) {\n        query = query\n          .gte('timestamp', timeframe.startDate)\n          .lte('timestamp', timeframe.endDate);\n      }\n\n      const { data: auditLogs, error } = await query;\n\n      if (error) {\n        console.error('Error fetching audit trail:', error);\n        return [];\n      }\n\n      if (!auditLogs || auditLogs.length === 0) {\n        return [];\n      }\n\n      const integrationAuditTrail: AuditTrailIntegration[] = auditLogs.map(\n        (log: any) => ({\n          actionId: String(log.id),\n          timestamp: log.timestamp,\n          userId: log.user_id,\n          userName: log.user_name ?? 'Unknown User',\n          action: log.action,\n          details: log.details,\n          impact: this.determineImpact(log.action),\n          status: log.status ?? 'completed',\n        })\n      );\n\n      return integrationAuditTrail;\n    } catch (error) {\n      console.error('Error fetching audit trail:', error);\n      return [];\n    }\n  }\n\n  static async pushKnowledgeHubNotification(\n    userId: string,\n    contentId: string,\n    message: string\n  ): Promise<boolean> {\n    try {\n      // Get user's facility ID\n      const { data: userProfile } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', userId)\n        .single();\n\n      const facilityId =\n        userProfile?.facility_id || '550e8400-e29b-41d4-a716-446655440000';\n\n      const { error } = await supabase.from('audit_logs').insert({\n        user_id: userId,\n        facility_id: facilityId,\n        action: 'Knowledge Hub Notification',\n        details: `Notification for content ${contentId}: ${message}`,\n        timestamp: new Date().toISOString(),\n        module: 'knowledge_hub',\n      });\n\n      if (error) {\n        console.error('Error logging notification:', error);\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error pushing Knowledge Hub notification:', error);\n      return false;\n    }\n  }\n\n  static async scheduleSupplierContact(\n    supplierId: string,\n    contactType: 'email' | 'phone' | 'meeting',\n    priority: 'low' | 'medium' | 'high' | 'urgent'\n  ): Promise<boolean> {\n    try {\n      // Get current user's facility ID\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get user's facility ID from users table\n      const { data: userProfile } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      const facilityId =\n        userProfile?.facility_id || '550e8400-e29b-41d4-a716-446655440000';\n\n      const { error } = await supabase.from('audit_logs').insert({\n        user_id: user.id,\n        facility_id: facilityId,\n        action: `Supplier Contact Scheduled`,\n        details: `${contactType} contact with supplier ${supplierId}, priority: ${priority}`,\n        timestamp: new Date().toISOString(),\n        module: 'supplier_management',\n      });\n\n      if (error) {\n        console.error('Error logging supplier contact:', error);\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Error scheduling supplier contact:', error);\n      return false;\n    }\n  }\n\n  static async getIntegrationMetrics(): Promise<IntegrationMetrics> {\n    try {\n      const [knowledgeHubCount, supplierCount, auditCount] = await Promise.all([\n        this.getKnowledgeHubCount(),\n        this.getActiveSupplierCount(),\n        this.getRecentAuditCount(),\n      ]);\n\n      return {\n        knowledgeHubArticles: knowledgeHubCount,\n        activeSuppliers: supplierCount,\n        recentAuditActions: auditCount,\n        integrationHealth: this.calculateIntegrationHealth(\n          knowledgeHubCount,\n          supplierCount,\n          auditCount\n        ),\n        lastSync: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('Error fetching integration metrics:', error);\n      return {\n        knowledgeHubArticles: 0,\n        activeSuppliers: 0,\n        recentAuditActions: 0,\n        integrationHealth: 0,\n        lastSync: new Date().toISOString(),\n      };\n    }\n  }\n\n  static async syncAllIntegrations(): Promise<boolean> {\n    try {\n      await Promise.all([\n        this.syncKnowledgeHub(),\n        this.syncSupplierDatabase(),\n        this.syncAuditTrail(),\n      ]);\n      return true;\n    } catch (error) {\n      console.error('Error during integration sync:', error);\n      return false;\n    }\n  }\n\n  private static calculateRelevance(\n    content: Record<string, unknown>,\n    keywords: string[]\n  ): number {\n    let relevance = 50;\n    keywords.forEach((keyword) => {\n      if (\n        (content.title as string)?.toLowerCase().includes(keyword.toLowerCase())\n      )\n        relevance += 20;\n      if (\n        (content.category as string)\n          ?.toLowerCase()\n          .includes(keyword.toLowerCase())\n      )\n        relevance += 15;\n      if (\n        content.tags &&\n        (content.tags as string[])?.some((tag) =>\n          tag.toLowerCase().includes(keyword.toLowerCase())\n        )\n      ) {\n        relevance += 10;\n      }\n    });\n    return Math.min(relevance, 100);\n  }\n\n  private static calculateCostCompetitiveness(\n    supplier: SupplierPerformanceRow,\n    budget: number\n  ): number {\n    const baseScore = 7.0;\n    const budgetMultiplier = Math.min(budget / 1000, 2);\n    return Math.min(baseScore * budgetMultiplier, 10);\n  }\n\n  private static determineImpact(action: string): 'low' | 'medium' | 'high' {\n    const highImpactActions = [\n      'sterilization',\n      'bi test',\n      'critical',\n      'emergency',\n    ];\n    const mediumImpactActions = ['inventory', 'training', 'maintenance'];\n    const actionLower = action.toLowerCase();\n    if (highImpactActions.some((term) => actionLower.includes(term)))\n      return 'high';\n    if (mediumImpactActions.some((term) => actionLower.includes(term)))\n      return 'medium';\n    return 'low';\n  }\n\n  private static async getKnowledgeHubCount(): Promise<number> {\n    try {\n      const contentItems = await KnowledgeHubService.getKnowledgeArticles();\n      return contentItems.length;\n    } catch (err) { console.error(err); throw err; }\n      return 0;\n    }\n  }\n\n  private static async getActiveSupplierCount(): Promise<number> {\n    try {\n      // Check if inventory_suppliers table exists first\n      const { data: tableExists, error: tableError } = await supabase\n        .from('information_schema.tables')\n        .select('table_name')\n        .eq('table_name', 'inventory_suppliers')\n        .single();\n\n      if (tableError || !tableExists) {\n        console.log(\n          'üìä inventory_suppliers table not found, using default count'\n        );\n        return 5;\n      }\n\n      return 5;\n    } catch (error) {\n      console.log('üìä Exception fetching supplier count:', error);\n      return 5;\n    }\n  }\n\n  private static async getRecentAuditCount(): Promise<number> {\n    try {\n      // Get current user's facility ID\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        return 0;\n      }\n\n      // Get user's facility ID from users table\n      const { data: userProfile } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      const facilityId =\n        userProfile?.facility_id || '550e8400-e29b-41d4-a716-446655440000';\n\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n      const { count, error } = await supabase\n        .from('audit_logs')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .gte('created_at', thirtyDaysAgo.toISOString());\n      if (error) return 0;\n      return count ?? 0;\n    } catch (err) { console.error(err); throw err; }\n      return 0;\n    }\n  }\n\n  private static calculateIntegrationHealth(\n    knowledgeHubCount: number,\n    supplierCount: number,\n    auditCount: number\n  ): number {\n    const knowledgeHubScore = Math.min(knowledgeHubCount / 10, 1) * 30;\n    const supplierScore = Math.min(supplierCount / 20, 1) * 30;\n    const auditScore = Math.min(auditCount / 50, 1) * 40;\n    return Math.round(knowledgeHubScore + supplierScore + auditScore);\n  }\n\n  private static async syncKnowledgeHub(): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n\n  private static async syncSupplierDatabase(): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n\n  private static async syncAuditTrail(): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n\n  private static getFallbackSuppliers(\n    category: string,\n    limit: number\n  ): SupplierIntegration[] {\n    const fallbackSuppliers: SupplierIntegration[] = [\n      {\n        supplierId: 'fallback-1',\n        name: 'Medical Supply Co.',\n        category,\n        rating: 4.5,\n        deliveryTime: 3,\n        costCompetitiveness: 8.0,\n        reliability: 9.0,\n        contactInfo: {\n          email: 'contact@medsupply.com',\n          phone: '+1-555-0123',\n          website: 'https://medsupply.com',\n        },\n      },\n      {\n        supplierId: 'fallback-2',\n        name: 'Clinical Equipment Ltd.',\n        category,\n        rating: 4.2,\n        deliveryTime: 5,\n        costCompetitiveness: 7.5,\n        reliability: 8.5,\n        contactInfo: {\n          email: 'sales@clinicalequip.com',\n          phone: '+1-555-0456',\n          website: 'https://clinicalequip.com',\n        },\n      },\n    ];\n    return fallbackSuppliers.slice(0, limit);\n  }\n}\n\nexport default IntelligenceIntegrationService;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\intelligenceRecommendationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\inventoryAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\providers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\sterilizationAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\tracking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\analytics\\userEngagementAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\api.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\auditLogService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\auditService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 62,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Basic audit service for logging security events\n\ninterface AuditEvent {\n  event: string;\n  user?: string;\n  reason?: string;\n  timestamp: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport const logAuditEvent = (event: AuditEvent): void => {\n  try {\n    // Only log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('[AUDIT]', event);\n    }\n\n    // In production, log to Supabase monitoring_events table\n    if (process.env.NODE_ENV === 'production') {\n      // Note: This would require the monitoring service to be properly configured\n      // For now, just log to console to avoid errors\n      console.log('[AUDIT]', event);\n    } else {\n      // Development fallback to localStorage\n      const auditLog = JSON.parse(localStorage.getItem('audit_log') || '[]');\n      auditLog.push({\n        ...event,\n        id: Date.now().toString(),\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n      });\n\n      // Keep only last 100 events\n      if (auditLog.length > 100) {\n        auditLog.splice(0, auditLog.length - 100);\n      }\n\n      localStorage.setItem('audit_log', JSON.stringify(auditLog));\n    }\n  } catch (error) {\n    // Only log errors in development\n    if (process.env.NODE_ENV === 'development') {\n      console.warn('Failed to log audit event:', error);\n    }\n  }\n};\n\nexport const logAudit = (email: string, success: boolean) => {\n  // Log to console for now - can be enhanced later with proper Supabase logging\n  console.log('[AUDIT]', { email, success, timestamp: new Date() });\n};\n\n// Log every login attempt\nexport const handleLogin = async (email: string) => {\n  try {\n    // Mock implementation - replace with actual login\n    console.log('Login attempt for:', email);\n    logAudit(email, true);\n  } catch (err) { console.error(err); throw err; }\n    logAudit(email, false);\n  }\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\authService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\autoclaveReceiptService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\availablePointsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\barcodeCountService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\biFailureService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 73,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\nimport { getEnvVar } from '../lib/getEnv';\nimport {\n  BIFailureError,\n  BIFailureErrorCodes,\n} from './bi/failure/BIFailureError';\nimport { BIFailureErrorHandler } from './bi/failure/BIFailureErrorHandler';\nimport { FacilityService } from './facilityService';\nimport { RealtimeManager } from '@/services/_core/realtimeManager';\n\n// Re-export BIFailureError for use in tests and components\nexport {\n  BIFailureError,\n  BIFailureErrorCodes,\n} from './bi/failure/BIFailureError';\n\ninterface CreateBIFailureParams {\n  facility_id: string;\n  affected_tools_count: number;\n  affected_batch_ids: string[];\n  lastSuccessfulBIDate?: Date;\n}\n\ninterface BIFailureIncident {\n  id: string;\n  incident_number: string;\n  status: 'active' | 'resolved' | 'investigating';\n  facility_id: string;\n  failure_date: string;\n  affected_tools_count: number;\n  affected_batch_ids: string[];\n  failure_reason?: string;\n  severity_level: 'low' | 'medium' | 'high' | 'critical';\n  detected_by_operator_id: string;\n  resolved_by_operator_id?: string;\n  resolution_notes?: string;\n  regulatory_notification_sent: boolean;\n  regulatory_notification_date?: string;\n}\n\ninterface PatientExposureReport {\n  incidentNumber: string;\n  totalPatientsExposed: number;\n  exposureSummary: {\n    totalPatientsExposed: number;\n    exposureWindowPatients: number;\n    quarantineBreachPatients: number;\n  };\n  riskBreakdown: {\n    high: number;\n    medium: number;\n    low: number;\n  };\n  patientDetails?: Array<{\n    patientId: string;\n    patientName: string;\n    riskLevel: 'high' | 'medium' | 'low';\n    exposureType: 'exposure_window' | 'quarantine_breach';\n    lastProcedureDate: string;\n    affectedTools: string[];\n  }>;\n}\n\n// Check if Supabase is configured for real-time\nconst isSupabaseConfigured = () => {\n  try {\n    return !!(\n      getEnvVar('VITE_SUPABASE_URL') && getEnvVar('VITE_SUPABASE_ANON_KEY')\n    );\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n\nexport class BIFailureService {\n  /**\n   * Creates a new BI failure incident\n   */\n  static async createIncident(\n    params: CreateBIFailureParams\n  ): Promise<BIFailureIncident> {\n    try {\n      // Validate input parameters\n      if (!params.facility_id) {\n        throw new BIFailureError(\n          'Facility ID is required',\n          BIFailureErrorCodes.MISSING_FACILITY_ID,\n          'high',\n          false\n        );\n      }\n\n      if (params.affected_tools_count <= 0) {\n        throw new BIFailureError(\n          'Affected tools count must be greater than 0',\n          BIFailureErrorCodes.INVALID_TOOLS_COUNT,\n          'medium',\n          false\n        );\n      }\n\n      if (\n        !params.affected_batch_ids ||\n        params.affected_batch_ids.length === 0\n      ) {\n        throw new BIFailureError(\n          'At least one affected batch ID is required',\n          BIFailureErrorCodes.MISSING_BATCH_IDS,\n          'medium',\n          false\n        );\n      }\n\n      // Generate incident number\n      const incidentNumber = await this.generateIncidentNumber(\n        params.facility_id\n      );\n\n      const incidentData = {\n        incident_number: incidentNumber,\n        facility_id: params.facility_id,\n        failure_date: new Date().toISOString(),\n        affected_tools_count: params.affected_tools_count,\n        affected_batch_ids: params.affected_batch_ids,\n        severity_level: 'high' as const,\n        status: 'active' as const,\n        detected_by_operator_id: await FacilityService.getCurrentUserId(),\n        regulatory_notification_sent: false,\n      };\n\n      const { data, error } = await supabase\n        .from('bi_failure_incidents')\n        .insert(incidentData)\n        .select()\n        .single();\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(error, 'create incident', {\n          params,\n        });\n      }\n\n      if (!data) {\n        throw new BIFailureError(\n          'No data returned from incident creation',\n          BIFailureErrorCodes.NO_DATA_RETURNED,\n          'critical',\n          false\n        );\n      }\n\n      return data as unknown as BIFailureIncident;\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(error, 'create incident');\n    }\n  }\n\n  /**\n   * Resolves a BI failure incident\n   */\n  static async resolveIncident(\n    incidentId: string,\n    facilityId: string,\n    resolvedByOperatorId: string,\n    resolutionNotes: string\n  ): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('bi_failure_incidents')\n        .update({\n          status: 'resolved',\n          resolved_by_operator_id: resolvedByOperatorId,\n          resolution_notes: resolutionNotes,\n        })\n        .eq('id', incidentId)\n        .eq('facility_id', facilityId);\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(error, 'resolve incident', {\n          incidentId,\n        });\n      }\n\n      return true;\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(error, 'resolve incident');\n    }\n  }\n\n  /**\n   * Gets active BI failure incidents for a facility\n   */\n  static async getActiveIncidents(\n    facilityId: string\n  ): Promise<BIFailureIncident[]> {\n    try {\n      const { data, error } = await supabase\n        .from('bi_failure_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .eq('status', 'active');\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'get active incidents',\n          { facilityId }\n        );\n      }\n\n      return (data || []).map((item: Record<string, unknown>) => ({\n        id: item.id as string,\n        incident_number: item.incident_number as string,\n        status: item.status as string,\n        facility_id: item.facility_id as string,\n        failure_date: item.failure_date as string,\n        detected_by_operator_id: item.detected_by_operator_id as string,\n        affected_tools_count: item.affected_tools_count as number,\n        affected_batch_ids: (item.affected_batch_ids as string[]) || [],\n        failure_reason: item.failure_reason as string,\n        severity_level: item.severity_level as string,\n        resolution_deadline: item.resolution_deadline as string,\n        estimated_impact: item.estimated_impact as string,\n        regulatory_notification_required:\n          item.regulatory_notification_required as boolean,\n        regulatory_notification_sent:\n          item.regulatory_notification_sent as boolean,\n        regulatory_notification_date:\n          item.regulatory_notification_date as string,\n        created_at: item.created_at as string,\n        updated_at: item.updated_at as string,\n      })) as BIFailureIncident[];\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'get active incidents'\n      );\n    }\n  }\n\n  /**\n   * Validates if a tool can be used (no active BI failures)\n   */\n  static async validateToolForUse(\n    toolId: string,\n    facilityId: string\n  ): Promise<boolean> {\n    try {\n      const activeIncidents = await this.getActiveIncidents(facilityId);\n      return activeIncidents.length === 0;\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'validate tool for use'\n      );\n    }\n  }\n\n  /**\n   * Validates tool use with detailed validation result\n   */\n  static async validateToolUse(toolId: string): Promise<{\n    canUse: boolean;\n    requiresImmediateAction: boolean;\n    validationResult:\n      | 'approved'\n      | 'quarantine_breach'\n      | 'exposure_window'\n      | 'pending_review';\n  }> {\n    try {\n      // For now, use a simple implementation that checks for active incidents\n      // In a real implementation, this would check the specific tool against BI failure data\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      const activeIncidents = await this.getActiveIncidents(facilityId);\n\n      if (activeIncidents.length === 0) {\n        return {\n          canUse: true,\n          requiresImmediateAction: false,\n          validationResult: 'approved',\n        };\n      }\n\n      // Check if tool is in affected batch IDs\n      const isAffected = activeIncidents.some((incident) =>\n        incident.affected_batch_ids.some(\n          (batchId) => toolId.includes(batchId) || batchId.includes(toolId)\n        )\n      );\n\n      if (isAffected) {\n        return {\n          canUse: false,\n          requiresImmediateAction: true,\n          validationResult: 'quarantine_breach',\n        };\n      }\n\n      // Tool is not directly affected but there's an active incident\n      return {\n        canUse: false,\n        requiresImmediateAction: false,\n        validationResult: 'exposure_window',\n      };\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(error, 'validate tool use');\n\n      // Return a safe default\n      return {\n        canUse: false,\n        requiresImmediateAction: true,\n        validationResult: 'pending_review',\n      };\n    }\n  }\n\n  /**\n   * Generates a patient exposure report for an incident\n   */\n  static async generatePatientExposureReport(\n    incidentId: string\n  ): Promise<PatientExposureReport> {\n    try {\n      // Mock implementation - replace with actual database query\n      const mockReport: PatientExposureReport = {\n        incidentNumber: `BI-FAIL-${incidentId}`,\n        totalPatientsExposed: 0,\n        exposureSummary: {\n          totalPatientsExposed: 0,\n          exposureWindowPatients: 0,\n          quarantineBreachPatients: 0,\n        },\n        riskBreakdown: {\n          high: 0,\n          medium: 0,\n          low: 0,\n        },\n      };\n\n      return mockReport;\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'generate patient exposure report'\n      );\n    }\n  }\n\n  /**\n   * Subscribes to real-time BI failure updates\n   */\n  static async subscribeToBIFailureUpdates(facilityId: string): Promise<void> {\n    try {\n      // Check if Supabase is configured\n      if (!isSupabaseConfigured()) {\n        console.warn(\n          '‚ö†Ô∏è Supabase not configured, skipping BI failure subscription'\n        );\n        return;\n      }\n\n      try {\n        // Use centralized realtime manager\n        RealtimeManager.subscribe(\n          'bi_failure_incidents',\n          (payload: unknown) => {\n            console.log('BI failure update:', payload);\n\n            // Handle different types of real-time updates\n            const eventPayload = payload as {\n              eventType?: string;\n              new?: unknown;\n              old?: unknown;\n            };\n            switch (eventPayload.eventType) {\n              case 'INSERT':\n                // New incident created\n                this.handleNewIncident(eventPayload.new);\n                break;\n              case 'UPDATE':\n                // Incident updated\n                this.handleIncidentUpdate(eventPayload.old, eventPayload.new);\n                break;\n              case 'DELETE':\n                // Incident deleted\n                this.handleIncidentDeletion(eventPayload.old);\n                break;\n              default:\n                console.log('Unknown event type:', eventPayload.eventType);\n            }\n          },\n          {\n            event: '*',\n            filter: `facility_id=eq.${facilityId}`,\n          } as Record<string, unknown>\n        );\n      } catch (error) {\n        console.error('‚ùå Failed to subscribe to BI failure updates:', error);\n        throw error;\n      }\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'subscribe to BI failure updates'\n      );\n    }\n  }\n\n  /**\n   * Handle new incident creation\n   */\n  private static handleNewIncident(incident: unknown): void {\n    try {\n      const newIncident = incident as BIFailureIncident;\n      console.log(\n        'New BI failure incident detected:',\n        newIncident.incident_number\n      );\n\n      // Trigger notifications\n      this.triggerIncidentNotifications(newIncident);\n\n      // Update UI if needed (could emit custom event)\n      window.dispatchEvent(\n        new CustomEvent('bi-failure-incident-created', {\n          detail: { incident: newIncident },\n        })\n      );\n    } catch (error) {\n      console.error('Error handling new incident:', error);\n    }\n  }\n\n  /**\n   * Handle incident updates\n   */\n  private static handleIncidentUpdate(\n    oldIncident: unknown,\n    newIncident: unknown\n  ): void {\n    try {\n      const old = oldIncident as BIFailureIncident;\n      const updated = newIncident as BIFailureIncident;\n\n      console.log('BI failure incident updated:', updated.incident_number);\n\n      // Check if status changed\n      if (old.status !== updated.status) {\n        console.log(\n          `Incident status changed from ${old.status} to ${updated.status}`\n        );\n\n        // Trigger status change notifications\n        this.triggerStatusChangeNotifications(old, updated);\n      }\n\n      // Update UI\n      window.dispatchEvent(\n        new CustomEvent('bi-failure-incident-updated', {\n          detail: { oldIncident: old, newIncident: updated },\n        })\n      );\n    } catch (error) {\n      console.error('Error handling incident update:', error);\n    }\n  }\n\n  /**\n   * Handle incident deletion\n   */\n  private static handleIncidentDeletion(incident: unknown): void {\n    try {\n      const deletedIncident = incident as BIFailureIncident;\n      console.log(\n        'BI failure incident deleted:',\n        deletedIncident.incident_number\n      );\n\n      // Update UI\n      window.dispatchEvent(\n        new CustomEvent('bi-failure-incident-deleted', {\n          detail: { incident: deletedIncident },\n        })\n      );\n    } catch (error) {\n      console.error('Error handling incident deletion:', error);\n    }\n  }\n\n  /**\n   * Trigger notifications for new incident\n   */\n  private static async triggerIncidentNotifications(\n    incident: BIFailureIncident\n  ): Promise<void> {\n    try {\n      // Import notification service dynamically to avoid circular dependencies\n      const { BIFailureNotificationService } = await import(\n        './bi/failure/BIFailureNotificationService'\n      );\n\n      await BIFailureNotificationService.sendRegulatoryNotification(\n        incident.id,\n        incident.facility_id,\n        incident.severity_level,\n        {\n          incidentNumber: incident.incident_number,\n          failureDate: incident.failure_date,\n          affectedToolsCount: incident.affected_tools_count,\n          failureReason: incident.failure_reason,\n        }\n      );\n    } catch (error) {\n      console.error('Error triggering incident notifications:', error);\n    }\n  }\n\n  /**\n   * Trigger notifications for status changes\n   */\n  private static async triggerStatusChangeNotifications(\n    oldIncident: BIFailureIncident,\n    newIncident: BIFailureIncident\n  ): Promise<void> {\n    try {\n      // Import notification service dynamically to avoid circular dependencies\n      const { BIFailureNotificationService } = await import(\n        './bi/failure/BIFailureNotificationService'\n      );\n\n      if (newIncident.status === 'resolved') {\n        await BIFailureNotificationService.sendInternalNotification(\n          newIncident.id,\n          newIncident.facility_id,\n          'medium',\n          ['admin@facility.com', 'supervisor@facility.com'],\n          `BI Failure incident ${newIncident.incident_number} has been resolved.`\n        );\n      }\n    } catch (error) {\n      console.error('Error triggering status change notifications:', error);\n    }\n  }\n\n  /**\n   * Generates a unique incident number\n   */\n  private static async generateIncidentNumber(\n    facilityId: string\n  ): Promise<string> {\n    try {\n      const date = new Date();\n      const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');\n\n      // Get count of incidents for today\n      const { count, error } = await supabase\n        .from('bi_failure_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .gte('failure_date', date.toISOString().split('T')[0]);\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'generate incident number',\n          {\n            facilityId,\n          }\n        );\n      }\n\n      const incidentNumber = `BI-FAIL-${dateStr}-${String((count || 0) + 1).padStart(3, '0')}`;\n      return incidentNumber;\n    } catch (error) {\n      if (error instanceof BIFailureError) {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'generate incident number'\n      );\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\biWorkflowService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\biWorkflowStateService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 222,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { BIFailureService } from './bi/failure';\nimport { BITestService } from './bi/BITestService';\nimport { BIFailureIncidentService } from './bi/BIFailureIncidentService';\nimport { supabase } from '../lib/supabaseClient';\nimport { FacilityService } from './facilityService';\n\n/**\n * State persistence configuration\n */\nexport interface StatePersistenceConfig {\n  autoSave: boolean;\n  autoSaveInterval: number; // milliseconds\n  maxBackupCount: number;\n  syncOnConnect: boolean;\n  retryAttempts: number;\n  retryDelay: number; // milliseconds\n}\n\n/**\n * State backup interface\n */\nexport interface StateBackup {\n  id: string;\n  timestamp: Date;\n  data: unknown;\n  version: string;\n  checksum: string;\n}\n\n/**\n * Sync status interface\n */\nexport interface SyncStatus {\n  lastSyncTime: Date | null;\n  isSyncing: boolean;\n  pendingChanges: number;\n  failedChanges: number;\n  syncErrors: string[];\n}\n\n/**\n * BI Workflow State interface\n */\nexport interface BIWorkflowState {\n  biTestResults?: unknown[];\n  biFailureHistory?: unknown[];\n  enforceBI?: boolean;\n  enforceCI?: boolean;\n  allowOverrides?: boolean;\n}\n\n/**\n * BI Workflow State Service\n * Handles state persistence, synchronization, and recovery\n */\nexport class BIWorkflowStateService {\n  private static readonly STORAGE_KEY = 'biWorkflowState';\n  private static readonly BACKUP_KEY = 'biWorkflowBackups';\n  private static readonly VERSION = '1.0.0';\n  private static readonly DEFAULT_CONFIG: StatePersistenceConfig = {\n    autoSave: true,\n    autoSaveInterval: 30000, // 30 seconds\n    maxBackupCount: 10,\n    syncOnConnect: true,\n    retryAttempts: 3,\n    retryDelay: 1000,\n  };\n\n  private config: StatePersistenceConfig;\n  private syncStatus: SyncStatus;\n  private autoSaveTimer: NodeJS.Timeout | null = null;\n\n  constructor(config: Partial<StatePersistenceConfig> = {}) {\n    this.config = { ...BIWorkflowStateService.DEFAULT_CONFIG, ...config };\n    this.syncStatus = {\n      lastSyncTime: null,\n      isSyncing: false,\n      pendingChanges: 0,\n      failedChanges: 0,\n      syncErrors: [],\n    };\n  }\n\n  /**\n   * Save state to localStorage with backup\n   */\n  static saveState(state: unknown): void {\n    try {\n      const stateData = {\n        data: state,\n        version: this.VERSION,\n        timestamp: new Date().toISOString(),\n        checksum: this.generateChecksum(state),\n      };\n\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(stateData));\n      this.createBackup(stateData);\n    } catch (error) {\n      console.error('Failed to save state:', error);\n      throw new Error(\n        `State save failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Load state from localStorage with recovery\n   */\n  static loadState(): unknown {\n    try {\n      const savedState = localStorage.getItem(this.STORAGE_KEY);\n      if (!savedState) {\n        return null;\n      }\n\n      const parsedState = JSON.parse(savedState);\n\n      // Validate state integrity\n      if (!this.validateState(parsedState)) {\n        console.warn('State validation failed, attempting recovery...');\n        return this.recoverState();\n      }\n\n      return parsedState.data;\n    } catch (error) {\n      console.error('Failed to load state:', error);\n      return this.recoverState();\n    }\n  }\n\n  /**\n   * Create a backup of the current state\n   */\n  private static createBackup(stateData: unknown): void {\n    try {\n      const backups = this.getBackups();\n      const newBackup: StateBackup = {\n        id: `backup-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        timestamp: new Date(),\n        data: stateData,\n        version: this.VERSION,\n        checksum: this.generateChecksum(stateData),\n      };\n\n      backups.unshift(newBackup);\n\n      // Keep only the most recent backups\n      const maxBackups = this.DEFAULT_CONFIG.maxBackupCount;\n      if (backups.length > maxBackups) {\n        backups.splice(maxBackups);\n      }\n\n      localStorage.setItem(this.BACKUP_KEY, JSON.stringify(backups));\n    } catch (error) {\n      console.error('Failed to create backup:', error);\n    }\n  }\n\n  /**\n   * Get all available backups\n   */\n  private static getBackups(): StateBackup[] {\n    try {\n      const backupsData = localStorage.getItem(this.BACKUP_KEY);\n      return backupsData ? JSON.parse(backupsData) : [];\n    } catch (error) {\n      console.error('Failed to get backups:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Recover state from the most recent valid backup\n   */\n  private static recoverState(): unknown {\n    try {\n      const backups = this.getBackups();\n\n      for (const backup of backups) {\n        if (this.validateState(backup.data)) {\n          console.log('State recovered from backup:', backup.timestamp);\n          return (backup.data as { data: unknown })?.data;\n        }\n      }\n\n      console.warn('No valid backup found, returning null');\n      return null;\n    } catch (error) {\n      console.error('Failed to recover state:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate state integrity\n   */\n  private static validateState(state: unknown): boolean {\n    try {\n      if (!state || typeof state !== 'object') {\n        return false;\n      }\n\n      const stateObj = state as {\n        version: string;\n        timestamp: string;\n        checksum: string;\n      };\n      if (!stateObj.version || !stateObj.timestamp || !stateObj.checksum) {\n        return false;\n      }\n\n      const expectedChecksum = this.generateChecksum(state);\n      return stateObj.checksum === expectedChecksum;\n    } catch (err) { console.error(err); throw err; }\n      return false;\n    }\n  }\n\n  /**\n   * Generate checksum for state validation\n   */\n  private static generateChecksum(data: unknown): string {\n    const dataString = JSON.stringify(data);\n    let hash = 0;\n\n    for (let i = 0; i < dataString.length; i++) {\n      const char = dataString.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    return hash.toString(16);\n  }\n\n  /**\n   * Clear all stored state and backups\n   */\n  static clearAllState(): void {\n    try {\n      localStorage.removeItem(this.STORAGE_KEY);\n      localStorage.removeItem(this.BACKUP_KEY);\n    } catch (err) { console.error(err); throw err; }\n      console.error('Failed to clear state');\n    }\n  }\n\n  /**\n   * Start auto-save functionality\n   */\n  startAutoSave(saveFunction: () => void): void {\n    if (!this.config.autoSave) {\n      return;\n    }\n\n    this.stopAutoSave();\n    this.autoSaveTimer = setInterval(() => {\n      try {\n        saveFunction();\n      } catch (err) { console.error(err); throw err; }\n        console.error('Auto-save failed');\n      }\n    }, this.config.autoSaveInterval);\n  }\n\n  /**\n   * Stop auto-save functionality\n   */\n  stopAutoSave(): void {\n    if (this.autoSaveTimer) {\n      clearInterval(this.autoSaveTimer);\n      this.autoSaveTimer = null;\n    }\n  }\n\n  /**\n   * Sync state with Supabase\n   */\n  async syncWithSupabase(state: BIWorkflowState): Promise<void> {\n    if (this.syncStatus.isSyncing) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.syncStatus.isSyncing = true;\n    this.syncStatus.syncErrors = [];\n\n    try {\n      // Sync BI test results\n      if (state.biTestResults) {\n        await this.syncBITestResults(state.biTestResults);\n      }\n\n      // Sync BI failure incidents\n      if (state.biFailureHistory) {\n        await this.syncBIFailureIncidents(state.biFailureHistory);\n      }\n\n      // Sync compliance settings\n      await this.syncComplianceSettings({\n        enforceBI: state.enforceBI,\n        enforceCI: state.enforceCI,\n        allowOverrides: state.allowOverrides,\n      });\n\n      this.syncStatus.lastSyncTime = new Date();\n      this.syncStatus.pendingChanges = 0;\n      this.syncStatus.failedChanges = 0;\n    } catch (error) {\n      this.syncStatus.syncErrors.push(\n        error instanceof Error ? error.message : 'Unknown sync error'\n      );\n      this.syncStatus.failedChanges++;\n      throw error;\n    } finally {\n      this.syncStatus.isSyncing = false;\n    }\n  }\n\n  /**\n   * Sync BI test results with Supabase\n   */\n  private async syncBITestResults(results: unknown[]): Promise<void> {\n    for (const result of results) {\n      try {\n        const testResult = result as {\n          facility_id: string;\n          operator_id?: string;\n          cycle_id?: string;\n          result: 'pass' | 'fail' | 'skip';\n          bi_lot_number?: string;\n          bi_expiry_date?: string;\n          incubation_time_minutes?: number;\n          incubation_temperature_celsius?: number;\n          test_conditions?: Record<string, unknown>;\n          failure_reason?: string;\n          skip_reason?: string;\n          compliance_notes?: string;\n        };\n\n        // Create or update BI test result in Supabase\n        await BITestService.createBITestResult(testResult);\n\n        console.log('Successfully synced BI test result:', testResult);\n      } catch (error) {\n        console.error('Failed to sync BI test result:', error);\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Sync BI failure incidents with Supabase\n   */\n  private async syncBIFailureIncidents(incidents: unknown[]): Promise<void> {\n    for (const incident of incidents) {\n      try {\n        const failureIncident = incident as {\n          facility_id: string;\n          bi_test_result_id?: string;\n          detected_by_operator_id?: string;\n          affected_tools_count: number;\n          affected_batch_ids: string[];\n          failure_reason?: string;\n          severity_level?: 'low' | 'medium' | 'high' | 'critical';\n        };\n\n        // Create BI failure incident in Supabase\n        await BIFailureIncidentService.createIncident(failureIncident);\n\n        console.log(\n          'Successfully synced BI failure incident:',\n          failureIncident\n        );\n      } catch (error) {\n        console.error('Failed to sync BI failure incident:', error);\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Sync compliance settings with Supabase\n   */\n  private async syncComplianceSettings(settings: unknown): Promise<void> {\n    try {\n      const complianceSettings = settings as {\n        facility_id: string;\n        enforce_bi: boolean;\n        enforce_ci: boolean;\n        allow_overrides: boolean;\n        ci_required: boolean;\n        bi_required: boolean;\n        autoclave_receipt_settings?: Record<string, unknown>;\n        cycle_settings?: Record<string, unknown>;\n        default_cycle_type?: string;\n        allow_custom_cycles?: boolean;\n      };\n\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        throw new Error(\n          'No facility ID available for compliance settings sync'\n        );\n      }\n\n      // Upsert compliance settings in Supabase\n      const { error } = await supabase\n        .from('facility_compliance_settings')\n        .upsert(\n          {\n            facility_id: facilityId,\n            enforce_bi: complianceSettings.enforce_bi,\n            enforce_ci: complianceSettings.enforce_ci,\n            allow_overrides: complianceSettings.allow_overrides,\n            ci_required: complianceSettings.ci_required,\n            bi_required: complianceSettings.bi_required,\n            autoclave_receipt_settings:\n              complianceSettings.autoclave_receipt_settings || {},\n            cycle_settings: complianceSettings.cycle_settings || {},\n            default_cycle_type:\n              complianceSettings.default_cycle_type || 'pouches',\n            allow_custom_cycles: complianceSettings.allow_custom_cycles || true,\n            updated_at: new Date().toISOString(),\n          },\n          {\n            onConflict: 'facility_id',\n          }\n        );\n\n      if (error) {\n        throw error;\n      }\n\n      console.log(\n        'Successfully synced compliance settings:',\n        complianceSettings\n      );\n    } catch (error) {\n      console.error('Failed to sync compliance settings:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load state from Supabase\n   */\n  async loadFromSupabase(): Promise<unknown> {\n    try {\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        throw new Error('No facility ID available for loading from Supabase');\n      }\n\n      // Load BI failure incidents\n      const incidents = await BIFailureService.getIncidentHistory(facilityId);\n\n      // Load compliance settings from Supabase\n      const { data: complianceSettings, error: settingsError } = await supabase\n        .from('facility_compliance_settings')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (settingsError && settingsError.code !== 'PGRST116') {\n        // PGRST116 = no rows returned\n        console.error('Error loading compliance settings:', settingsError);\n      }\n\n      // Load activity log from Supabase\n      const { data: activityLog, error: activityError } = await supabase\n        .from('bi_activity_log')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .order('created_at', { ascending: false })\n        .limit(100);\n\n      if (activityError) {\n        console.error('Error loading activity log:', activityError);\n      }\n\n      // Load recent BI test results\n      const { data: biTestResults, error: testError } = await supabase\n        .from('bi_test_results')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .order('test_date', { ascending: false })\n        .limit(50);\n\n      if (testError) {\n        console.error('Error loading BI test results:', testError);\n      }\n\n      return {\n        biFailureHistory: incidents,\n        complianceSettings: complianceSettings || {\n          enforce_bi: true,\n          enforce_ci: true,\n          allow_overrides: false,\n          ci_required: true,\n          bi_required: true,\n        },\n        activityLog: activityLog || [],\n        biTestResults: biTestResults || [],\n      };\n    } catch (error) {\n      console.error('Failed to load from Supabase:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get sync status\n   */\n  getSyncStatus(): SyncStatus {\n    return { ...this.syncStatus };\n  }\n\n  /**\n   * Reset sync status\n   */\n  resetSyncStatus(): void {\n    this.syncStatus = {\n      lastSyncTime: null,\n      isSyncing: false,\n      pendingChanges: 0,\n      failedChanges: 0,\n      syncErrors: [],\n    };\n  }\n\n  /**\n   * Check if state needs synchronization\n   */\n  needsSync(lastLocalChange: Date): boolean {\n    if (!this.syncStatus.lastSyncTime) {\n      return true;\n    }\n\n    return lastLocalChange > this.syncStatus.lastSyncTime;\n  }\n\n  /**\n   * Get state statistics\n   */\n  static getStateStats(): {\n    hasState: boolean;\n    stateSize: number;\n    backupCount: number;\n    lastBackup: Date | null;\n  } {\n    try {\n      const stateData = localStorage.getItem(this.STORAGE_KEY);\n      const backups = this.getBackups();\n\n      return {\n        hasState: !!stateData,\n        stateSize: stateData ? stateData.length : 0,\n        backupCount: backups.length,\n        lastBackup: backups.length > 0 ? new Date(backups[0].timestamp) : null,\n      };\n    } catch (error) {\n      console.error('Failed to get state stats:', error);\n      return {\n        hasState: false,\n        stateSize: 0,\n        backupCount: 0,\n        lastBackup: null,\n      };\n    }\n  }\n\n  /**\n   * Export state for backup\n   */\n  static exportState(): string {\n    try {\n      const stateData = localStorage.getItem(this.STORAGE_KEY);\n      const backups = this.getBackups();\n\n      const exportData = {\n        state: stateData ? JSON.parse(stateData) : null,\n        backups,\n        exportDate: new Date().toISOString(),\n        version: this.VERSION,\n      };\n\n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error('Failed to export state:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import state from backup\n   */\n  static importState(exportData: string): void {\n    try {\n      const parsedData = JSON.parse(exportData);\n\n      if (parsedData.state) {\n        localStorage.setItem(\n          this.STORAGE_KEY,\n          JSON.stringify(parsedData.state)\n        );\n      }\n\n      if (parsedData.backups && Array.isArray(parsedData.backups)) {\n        localStorage.setItem(\n          this.BACKUP_KEY,\n          JSON.stringify(parsedData.backups)\n        );\n      }\n\n      console.log('State imported successfully');\n    } catch (error) {\n      console.error('Failed to import state:', error);\n      throw error;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFacilityCycleService.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 236,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 236,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6924, 6927], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6924, 6927], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFacilityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFailureIncidentService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFailureNotificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFailureValidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIFailureWorkflowService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BIRealtimeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BISubscriptionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BITestCRUDService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BITestKitService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 337,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../__mocks__/supabase/supabaseMockClient';\n\n// Type definitions based on actual database schema\ninterface BITestKitRow {\n  id: string;\n  facility_id: string;\n  name: string;\n  manufacturer: string;\n  lot_number: string;\n  serial_number?: string;\n  barcode?: string;\n  expiry_date: string;\n  incubation_time_minutes: number;\n  incubation_temperature_celsius: number;\n  quantity: number;\n  min_quantity: number;\n  max_quantity: number;\n  location?: string;\n  status: string;\n  supplier?: string;\n  cost?: number;\n  notes?: string;\n  created_at: string;\n  updated_at: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface BITestKit {\n  id: string;\n  facility_id: string;\n  name: string;\n  manufacturer: string;\n  lot_number: string;\n  serial_number?: string;\n  barcode?: string;\n  expiry_date: string;\n  incubation_time_minutes: number;\n  incubation_temperature_celsius: number;\n  quantity: number;\n  min_quantity: number;\n  max_quantity: number;\n  location?: string;\n  status: 'active' | 'inactive' | 'expired' | 'quarantine';\n  supplier?: string;\n  cost?: number;\n  notes?: string;\n  created_at: string;\n  updated_at: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface TestConditions {\n  room_temperature_celsius: number;\n  humidity_percent: number;\n  equipment_used: string;\n  operator_id: string;\n  facility_id: string;\n  test_date: string;\n  environmental_notes?: string;\n  [key: string]: unknown;\n}\n\nexport interface BITestResult {\n  toolId: string;\n  passed: boolean;\n  date: Date;\n  status?: 'pass' | 'fail' | 'skip';\n}\n\n/**\n * BI Test Kit Service\n * Handles all operations related to BI test kit management\n */\nexport class BITestKitService {\n  /**\n   * Get available BI test kits for a facility\n   */\n  static async getAvailableKits(facilityId: string): Promise<BITestKit[]> {\n    const { data, error } = await supabase\n      .from('bi_test_kits')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', 'active')\n      .gt('quantity', 0)\n      .gt('expiry_date', new Date().toISOString().split('T')[0])\n      .order('expiry_date', { ascending: true });\n\n    if (error) {\n      throw new Error(`Failed to get available BI test kits: ${error.message}`);\n    }\n\n    return ((data as BITestKitRow[]) || []).map((item) => ({\n      id: item.id,\n      facility_id: item.facility_id,\n      name: item.name,\n      manufacturer: item.manufacturer,\n      lot_number: item.lot_number,\n      serial_number: item.serial_number || undefined,\n      barcode: item.barcode || undefined,\n      expiry_date: item.expiry_date,\n      incubation_time_minutes: item.incubation_time_minutes,\n      incubation_temperature_celsius: item.incubation_temperature_celsius,\n      quantity: item.quantity,\n      min_quantity: item.min_quantity,\n      max_quantity: item.max_quantity,\n      location: item.location || undefined,\n      status: item.status as 'active' | 'inactive' | 'expired' | 'quarantine',\n      supplier: item.supplier || undefined,\n      cost: item.cost || undefined,\n      notes: item.notes || undefined,\n      created_at: item.created_at,\n      updated_at: item.updated_at,\n      created_by: item.created_by || undefined,\n      updated_by: item.updated_by || undefined,\n    }));\n  }\n\n  /**\n   * Get a specific BI test kit by ID\n   */\n  static async getKitById(kitId: string): Promise<BITestKit> {\n    const { data, error } = await supabase\n      .from('bi_test_kits')\n      .select('*')\n      .eq('id', kitId)\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to get BI test kit: ${error.message}`);\n    }\n\n    if (!data) {\n      throw new Error('BI test kit not found');\n    }\n\n    const kit = data as BITestKitRow;\n    return {\n      id: kit.id,\n      facility_id: kit.facility_id,\n      name: kit.name,\n      manufacturer: kit.manufacturer,\n      lot_number: kit.lot_number,\n      serial_number: kit.serial_number || undefined,\n      barcode: kit.barcode || undefined,\n      expiry_date: kit.expiry_date,\n      incubation_time_minutes: kit.incubation_time_minutes,\n      incubation_temperature_celsius: kit.incubation_temperature_celsius,\n      quantity: kit.quantity,\n      min_quantity: kit.min_quantity,\n      max_quantity: kit.max_quantity,\n      location: kit.location || undefined,\n      status: kit.status as 'active' | 'inactive' | 'expired' | 'quarantine',\n      supplier: kit.supplier || undefined,\n      cost: kit.cost || undefined,\n      notes: kit.notes || undefined,\n      created_at: kit.created_at,\n      updated_at: kit.updated_at,\n      created_by: kit.created_by || undefined,\n      updated_by: kit.updated_by || undefined,\n    };\n  }\n\n  /**\n   * Create a new BI test kit\n   */\n  static async createKit(\n    kitData: Omit<BITestKit, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<BITestKit> {\n    const insertData: Partial<BITestKitRow> = {\n      facility_id: kitData.facility_id,\n      name: kitData.name,\n      manufacturer: kitData.manufacturer,\n      lot_number: kitData.lot_number,\n      serial_number: kitData.serial_number,\n      barcode: kitData.barcode,\n      expiry_date: kitData.expiry_date,\n      incubation_time_minutes: kitData.incubation_time_minutes,\n      incubation_temperature_celsius: kitData.incubation_temperature_celsius,\n      quantity: kitData.quantity,\n      min_quantity: kitData.min_quantity,\n      max_quantity: kitData.max_quantity,\n      location: kitData.location,\n      status: kitData.status,\n      supplier: kitData.supplier,\n      cost: kitData.cost,\n      notes: kitData.notes,\n      created_by: kitData.created_by,\n      updated_by: kitData.updated_by,\n    };\n\n    const { data, error } = await supabase\n      .from('bi_test_kits')\n      .insert(insertData)\n      .select()\n      .single();\n\n    if (error) {\n      throw new Error(`Failed to create BI test kit: ${error.message}`);\n    }\n\n    if (!data) {\n      throw new Error('No data returned from BI test kit creation');\n    }\n\n    const kit = data as BITestKitRow;\n    return {\n      id: kit.id,\n      facility_id: kit.facility_id,\n      name: kit.name,\n      manufacturer: kit.manufacturer,\n      lot_number: kit.lot_number,\n      serial_number: kit.serial_number || undefined,\n      barcode: kit.barcode || undefined,\n      expiry_date: kit.expiry_date,\n      incubation_time_minutes: kit.incubation_time_minutes,\n      incubation_temperature_celsius: kit.incubation_temperature_celsius,\n      quantity: kit.quantity,\n      min_quantity: kit.min_quantity,\n      max_quantity: kit.max_quantity,\n      location: kit.location || undefined,\n      status: kit.status as 'active' | 'inactive' | 'expired' | 'quarantine',\n      supplier: kit.supplier || undefined,\n      cost: kit.cost || undefined,\n      notes: kit.notes || undefined,\n      created_at: kit.created_at,\n      updated_at: kit.updated_at,\n      created_by: kit.created_by || undefined,\n      updated_by: kit.updated_by || undefined,\n    };\n  }\n\n  /**\n   * Update BI test kit quantity (decrease by 1 when used)\n   */\n  static async useKit(kitId: string): Promise<void> {\n    // First get current quantity\n    const { data: currentKit, error: fetchError } = await supabase\n      .from('bi_test_kits')\n      .select('quantity')\n      .eq('id', kitId)\n      .single();\n\n    if (fetchError || !currentKit) {\n      throw new Error(\n        `Failed to fetch BI test kit: ${fetchError?.message || 'Kit not found'}`\n      );\n    }\n\n    const kit = currentKit as { quantity: number };\n    if (kit.quantity <= 0) {\n      throw new Error('BI test kit quantity is already 0');\n    }\n\n    const { error } = await supabase\n      .from('bi_test_kits')\n      .update({\n        quantity: kit.quantity - 1,\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', kitId);\n\n    if (error) {\n      throw new Error(\n        `Failed to update BI test kit quantity: ${error.message}`\n      );\n    }\n  }\n\n  /**\n   * Decrement BI test kit quantity (alias for useKit to avoid React Hook naming confusion)\n   */\n  static async decrementKitQuantity(kitId: string): Promise<void> {\n    return this.useKit(kitId);\n  }\n\n  /**\n   * Get current environmental test conditions\n   */\n  static async getCurrentTestConditions(): Promise<TestConditions> {\n    // Get current user and facility\n    const {\n      data: { user },\n      error: authError,\n    } = await supabase.auth.getUser();\n    if (authError || !user) {\n      throw new Error('User not authenticated');\n    }\n\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('facility_id')\n      .eq('id', user.id)\n      .single();\n\n    if (userError || !userData) {\n      throw new Error('User facility not found');\n    }\n\n    const userFacility = userData as { facility_id: string };\n    // In a real implementation, this would get data from environmental sensors\n    // For now, we'll use reasonable defaults and allow manual entry\n    const testConditions: TestConditions = {\n      room_temperature_celsius: 22.0, // Default room temperature\n      humidity_percent: 45.0, // Default humidity\n      equipment_used: 'Standard Incubator', // Default equipment\n      operator_id: user.id,\n      facility_id: userFacility.facility_id,\n      test_date: new Date().toISOString(),\n      environmental_notes: 'Standard laboratory conditions',\n    };\n\n    return testConditions;\n  }\n\n  /**\n   * Generate appropriate failure reason based on test result\n   */\n  static async getFailureReason(): Promise<string> {\n    // In a real implementation, this would analyze the test conditions\n    // and provide specific failure reasons based on the test parameters\n    const baseReason = 'Positive growth detected during incubation period';\n\n    // Add additional context based on test conditions if available\n    try {\n      const conditions = await this.getCurrentTestConditions();\n      return `${baseReason}. Test conducted at ${conditions.room_temperature_celsius}¬∞C for standard incubation period.`;\n    } catch (err) { console.error(err); throw err; }\n      return baseReason;\n    }\n  }\n\n  /**\n   * Generate appropriate skip reason based on test result\n   */\n  static async getSkipReason(): Promise<string> {\n    // In a real implementation, this would be based on operator input\n    // or system conditions that prevented the test\n    return 'Test skipped by operator - reason documented in compliance notes';\n  }\n\n  /**\n   * Generate appropriate compliance notes for passed tests\n   */\n  static async getComplianceNotes(): Promise<string> {\n    // In a real implementation, this would include compliance verification\n    // and any relevant regulatory information\n    const baseNote =\n      'BI test passed successfully - sterilization process validated';\n\n    try {\n      const conditions = await this.getCurrentTestConditions();\n      return `${baseNote}. Test conditions: ${conditions.room_temperature_celsius}¬∞C, standard incubation period.`;\n    } catch (err) { console.error(err); throw err; }\n      return baseNote;\n    }\n  }\n\n  /**\n   * Check if facility has sufficient BI test kits\n   */\n  static async checkKitInventory(facilityId: string): Promise<{\n    available: number;\n    low_stock: boolean;\n    expired_count: number;\n    recommendations: string[];\n  }> {\n    const { data, error } = await supabase\n      .from('bi_test_kits')\n      .select('quantity, expiry_date, status')\n      .eq('facility_id', facilityId);\n\n    if (error) {\n      throw new Error(`Failed to check kit inventory: ${error.message}`);\n    }\n\n    const kits =\n      (data as { quantity: number; expiry_date: string; status: string }[]) ||\n      [];\n\n    const available = kits\n      .filter(\n        (kit) =>\n          kit.status === 'active' &&\n          kit.quantity > 0 &&\n          new Date(kit.expiry_date) > new Date()\n      )\n      .reduce((sum, kit) => sum + kit.quantity, 0);\n\n    const expired_count = kits.filter(\n      (kit) => new Date(kit.expiry_date) <= new Date()\n    ).length;\n\n    const low_stock = available < 5; // Consider low stock if less than 5 kits available\n\n    const recommendations: string[] = [];\n    if (low_stock) {\n      recommendations.push(\n        'Order additional BI test kits to maintain adequate inventory'\n      );\n    }\n    if (expired_count > 0) {\n      recommendations.push(\n        `Dispose of ${expired_count} expired BI test kit(s)`\n      );\n    }\n\n    return {\n      available,\n      low_stock,\n      expired_count,\n      recommendations,\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\BITestService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureError.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureErrorHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureIncidentService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 69,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 69,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2205, 2208], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2205, 2208], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 93,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 93,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3078, 3081], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3078, 3081], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 98,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 98,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3248, 3251], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3248, 3251], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 114,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 114,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3651, 3654], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3651, 3654], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 115,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 115,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3696, 3699], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3696, 3699], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 152,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 152,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4736, 4739], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4736, 4739], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 195,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 195,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5897, 5900], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5897, 5900], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 196,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 196,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5944, 5947], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5944, 5947], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 216,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 216,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6546, 6549], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6546, 6549], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 369,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 369,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10720, 10723], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10720, 10723], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 390,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 390,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11322, 11325], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11322, 11325], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 11,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport { BIFailureErrorHandler } from './BIFailureErrorHandler';\nimport {\n  BIFailureValidationService,\n  CreateBIFailureParams,\n  ResolveBIFailureParams,\n} from './BIFailureValidationService';\n\n/**\n * BI Failure Incident interface\n */\nexport interface BIFailureIncident {\n  id: string;\n  facility_id: string;\n  bi_test_result_id?: string;\n  incident_number: string;\n  failure_date: string;\n  detected_by_operator_id?: string;\n  affected_tools_count: number;\n  affected_batch_ids: string[];\n  failure_reason?: string;\n  severity_level: 'low' | 'medium' | 'high' | 'critical';\n  status: 'active' | 'in_resolution' | 'resolved' | 'closed';\n  resolution_deadline?: string;\n  estimated_impact?: string;\n  regulatory_notification_required: boolean;\n  regulatory_notification_sent: boolean;\n  regulatory_notification_date?: string;\n  created_at: string;\n  updated_at: string;\n}\n\n// Row type for Supabase mapping\ntype BIFailureIncidentRow = {\n  id: string;\n  facility_id: string;\n  bi_test_result_id?: string | null;\n  incident_number: string;\n  failure_date: string;\n  detected_by_operator_id?: string | null;\n  affected_tools_count: number;\n  affected_batch_ids?: string[] | null;\n  failure_reason?: string | null;\n  severity_level: 'low' | 'medium' | 'high' | 'critical';\n  status: 'active' | 'in_resolution' | 'resolved' | 'closed';\n  resolution_deadline?: string | null;\n  estimated_impact?: string | null;\n  regulatory_notification_required: boolean;\n  regulatory_notification_sent: boolean;\n  regulatory_notification_date?: string | null;\n  created_at: string;\n  updated_at: string;\n  updated_by_operator_id?: string | null;\n  deleted_by_operator_id?: string | null;\n};\n\n/**\n * Incident service for BI failure operations\n */\nexport class BIFailureIncidentService {\n  static async createIncident(\n    params: CreateBIFailureParams\n  ): Promise<BIFailureIncident> {\n    try {\n      BIFailureValidationService.validateCreateIncidentParams(params);\n      BIFailureValidationService.validateBusinessRules(params);\n\n      const result = await BIFailureErrorHandler.withRetry(async () => {\n        const { data, error } = await supabase.rpc<BIFailureIncidentRow, any>(\n          'create_bi_failure_incident',\n          {\n            p_facility_id: params.facility_id,\n            p_bi_test_result_id: params.bi_test_result_id,\n            p_detected_by_operator_id: params.detected_by_operator_id,\n            p_affected_tools_count: params.affected_tools_count,\n            p_affected_batch_ids: params.affected_batch_ids,\n            p_failure_reason: params.failure_reason,\n          }\n        );\n        if (error) {\n          BIFailureErrorHandler.handleDatabaseError(\n            error,\n            'create BI failure incident'\n          );\n        }\n        if (!data) throw new Error('No data returned from incident creation');\n        return data;\n      }, 'create BI failure incident');\n\n      if (result && params.lastSuccessfulBIDate) {\n        try {\n          await this.identifyExposureWindowTools(\n            (result as any).id,\n            params.lastSuccessfulBIDate\n          );\n          console.log(\n            'Exposure window tools identified for incident:',\n            (result as any).incident_number\n          );\n        } catch (exposureError) {\n          if (\n            !(global as { __TESTING__?: boolean }).__TESTING__ &&\n            process.env.NODE_ENV !== 'test'\n          ) {\n            console.error(\n              'Error identifying exposure window tools:',\n              exposureError\n            );\n          }\n        }\n      }\n\n      return {\n        ...(result as any),\n        affected_batch_ids: (result as any).affected_batch_ids ?? [],\n      };\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'create BI failure incident'\n      );\n    }\n  }\n\n  static async getActiveIncidents(\n    facilityId: string\n  ): Promise<BIFailureIncident[]> {\n    BIFailureValidationService.validateFacilityId(facilityId);\n\n    try {\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => {\n          return await supabase\n            .from('bi_failure_incidents')\n            .select('*')\n            .eq('facility_id', facilityId)\n            .in('status', ['active', 'in_resolution'])\n            .order('failure_date', { ascending: false });\n        },\n        'get active BI failure incidents'\n      );\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'get active BI failure incidents'\n        );\n      }\n\n      return (data ?? []).map((item: any) => ({\n        ...item,\n        affected_batch_ids: item.affected_batch_ids ?? [],\n      }));\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'get active BI failure incidents'\n      );\n    }\n  }\n\n  static async getIncidentById(\n    incidentId: string,\n    facilityId: string\n  ): Promise<BIFailureIncident | null> {\n    BIFailureValidationService.validateIncidentId(incidentId);\n\n    try {\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => {\n          return await supabase\n            .from('bi_failure_incidents')\n            .select('*')\n            .eq('id', incidentId)\n            .eq('facility_id', facilityId)\n            .single();\n        },\n        'get BI failure incident by ID'\n      );\n\n      if (error) {\n        if ((error as { code?: string }).code === 'PGRST116') return null;\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'get BI failure incident by ID'\n        );\n      }\n\n      return data\n        ? {\n            ...(data as any),\n            affected_batch_ids: (data as any).affected_batch_ids ?? [],\n          }\n        : null;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'get BI failure incident by ID'\n      );\n    }\n  }\n\n  static async resolveIncident(\n    params: ResolveBIFailureParams\n  ): Promise<boolean> {\n    BIFailureValidationService.validateResolveIncidentParams(params);\n\n    try {\n      const result = await BIFailureErrorHandler.withRetry(async () => {\n        const { data, error } = await supabase.rpc<boolean, any>(\n          'resolve_bi_failure_incident',\n          {\n            p_incident_id: params.incidentId,\n            p_resolved_by_operator_id: params.resolvedByOperatorId,\n            p_resolution_notes: params.resolutionNotes || '',\n          }\n        );\n        if (error) {\n          BIFailureErrorHandler.handleDatabaseError(\n            error,\n            'resolve BI failure incident'\n          );\n        }\n        return data;\n      }, 'resolve BI failure incident');\n\n      return result === true;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'resolve BI failure incident'\n      );\n    }\n  }\n\n  static async updateIncidentStatus(\n    incidentId: string,\n    facilityId: string,\n    status: BIFailureIncident['status'],\n    updatedByOperatorId?: string\n  ): Promise<boolean> {\n    BIFailureValidationService.validateIncidentId(incidentId);\n\n    try {\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => {\n          return await supabase\n            .from('bi_failure_incidents')\n            .update({\n              status,\n              updated_at: new Date().toISOString(),\n              ...(updatedByOperatorId && {\n                updated_by_operator_id: updatedByOperatorId,\n              }),\n            })\n            .eq('id', incidentId)\n            .eq('facility_id', facilityId)\n            .select('id')\n            .single();\n        },\n        'update incident status'\n      );\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'update incident status'\n        );\n      }\n\n      return !!data;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'update incident status'\n      );\n    }\n  }\n\n  static async deleteIncident(\n    incidentId: string,\n    facilityId: string,\n    deletedByOperatorId?: string\n  ): Promise<boolean> {\n    BIFailureValidationService.validateIncidentId(incidentId);\n\n    try {\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => {\n          return await supabase\n            .from('bi_failure_incidents')\n            .update({\n              status: 'closed',\n              updated_at: new Date().toISOString(),\n              ...(deletedByOperatorId && {\n                deleted_by_operator_id: deletedByOperatorId,\n              }),\n            })\n            .eq('id', incidentId)\n            .eq('facility_id', facilityId)\n            .select('id')\n            .single();\n        },\n        'delete BI failure incident'\n      );\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'delete BI failure incident'\n        );\n      }\n\n      return !!data;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'delete BI failure incident'\n      );\n    }\n  }\n\n  static async getIncidentHistory(\n    facilityId: string,\n    startDate?: string,\n    endDate?: string,\n    limit: number = 100\n  ): Promise<BIFailureIncident[]> {\n    BIFailureValidationService.validateFacilityId(facilityId);\n    if (startDate && endDate) {\n      BIFailureValidationService.validateDateRange(startDate, endDate);\n    }\n\n    try {\n      let query = supabase\n        .from('bi_failure_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .order('failure_date', { ascending: false })\n        .limit(limit);\n\n      if (startDate) query = query.gte('failure_date', startDate);\n      if (endDate) query = query.lte('failure_date', endDate);\n\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => query,\n        'get incident history'\n      );\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'get incident history'\n        );\n      }\n\n      return (data ?? []).map((item: any) => ({\n        ...item,\n        affected_batch_ids: item.affected_batch_ids ?? [],\n      }));\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'get incident history'\n      );\n    }\n  }\n\n  private static async identifyExposureWindowTools(\n    incidentId: string,\n    lastSuccessfulBIDate: Date\n  ): Promise<number> {\n    try {\n      const { data, error } = await BIFailureErrorHandler.withRetry(\n        async () => {\n          return await supabase.rpc<number, any>(\n            'identify_exposure_window_tools',\n            {\n              p_incident_id: incidentId,\n              p_last_successful_bi_date: lastSuccessfulBIDate.toISOString(),\n            }\n          );\n        },\n        'identify exposure window tools'\n      );\n\n      if (error) {\n        BIFailureErrorHandler.handleDatabaseError(\n          error,\n          'identify exposure window tools'\n        );\n      }\n\n      return data ?? 0;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError')\n        throw error;\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'identify exposure window tools'\n      );\n    }\n  }\n\n  static async getCurrentFacilityId(): Promise<string> {\n    try {\n      const { FacilityService } = await import('@/services/facilityService');\n      return await FacilityService.getCurrentFacilityId();\n    } catch (error) {\n      console.error('Failed to get current facility ID:', error);\n      if (process.env.NODE_ENV === 'development') {\n        return '550e8400-e29b-41d4-a716-446655440000';\n      }\n      throw new Error('Failed to get current facility ID');\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureNotificationService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 387,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 387,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 422,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 422,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 471,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 471,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 531,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 531,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { BIFailureErrorHandler } from './BIFailureErrorHandler';\nimport { BIFailureValidationService } from './BIFailureValidationService';\nimport { supabase } from '../../../__mocks__/supabase/supabaseMockClient';\nimport { BIFailureNotificationDataProvider } from '../notification/data/BIFailureNotificationDataProvider';\nimport { FacilityService } from '../../facilityService';\nimport {\n  NotificationMessage,\n  NotificationScheduler,\n  NotificationMessenger,\n  NotificationFormatters,\n} from './notification';\nimport type { Json } from '../../../types/supabase/common';\n\n// Define proper types for Supabase operations\ntype SupabaseError = {\n  message: string;\n  details?: string;\n  hint?: string;\n  code?: string;\n};\n\n// Database row interfaces\ninterface NotificationRow {\n  id: string;\n  incident_id: string;\n  facility_id: string;\n  severity: string;\n  message_type: string;\n  recipients: Json;\n  subject: string;\n  body: string;\n  sent_at: string | null;\n  status: string;\n  retry_count: number;\n  max_retries: number;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface BIFailureIncidentRow {\n  id: string;\n  incident_number: string;\n  failure_date: string;\n  affected_tools_count: number;\n  failure_reason: string | null;\n  facility_id: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface IncidentDetails {\n  incidentNumber: string;\n  failureDate: string;\n  affectedToolsCount: number;\n  failureReason?: string;\n}\n\n/**\n * Notification service for BI failure operations\n * Handles regulatory notifications and alerts\n */\nexport class BIFailureNotificationService {\n  private static readonly DEFAULT_NOTIFICATION_DELAY = 30; // minutes\n  private static readonly MAX_RETRY_COUNT = 3;\n\n  /**\n   * Send regulatory notification for BI failure incident\n   */\n  static async sendRegulatoryNotification(\n    incidentId: string,\n    facilityId: string,\n    severity: 'low' | 'medium' | 'high' | 'critical',\n    incidentDetails: {\n      incidentNumber: string;\n      failureDate: string;\n      affectedToolsCount: number;\n      failureReason?: string;\n    }\n  ): Promise<boolean> {\n    try {\n      BIFailureValidationService.validateIncidentId(incidentId);\n      BIFailureValidationService.validateFacilityId(facilityId);\n\n      const config =\n        await NotificationMessenger.getNotificationConfig(facilityId);\n\n      if (!config.autoNotificationEnabled) {\n        return false;\n      }\n\n      const notification = NotificationFormatters.createNotificationMessage(\n        incidentId,\n        facilityId,\n        severity,\n        'regulatory',\n        incidentDetails,\n        await this.getDefaultRecipients()\n      );\n\n      // Check if regulatory notification is required based on severity\n      if (\n        NotificationScheduler.isRegulatoryNotificationRequired(severity, config)\n      ) {\n        await NotificationMessenger.sendNotification(notification);\n        await this.updateIncidentNotificationStatus(\n          incidentId,\n          facilityId,\n          true\n        );\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'send regulatory notification'\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Send internal notification to facility staff\n   */\n  static async sendInternalNotification(\n    incidentId: string,\n    facilityId: string,\n    severity: 'low' | 'medium' | 'high' | 'critical',\n    recipients: string[],\n    customMessage?: string\n  ): Promise<boolean> {\n    try {\n      BIFailureValidationService.validateIncidentId(incidentId);\n      BIFailureValidationService.validateFacilityId(facilityId);\n\n      const incidentDetails = await this.getIncidentDetails(\n        incidentId,\n        facilityId\n      );\n\n      const notification = NotificationFormatters.createNotificationMessage(\n        incidentId,\n        facilityId,\n        severity,\n        'internal',\n        incidentDetails,\n        recipients,\n        customMessage\n      );\n\n      await NotificationMessenger.sendNotification(notification);\n      return true;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'send internal notification'\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Send escalation notification\n   */\n  static async sendEscalationNotification(\n    incidentId: string,\n    facilityId: string,\n    escalationLevel: 'supervisor' | 'manager' | 'director' | 'executive'\n  ): Promise<boolean> {\n    try {\n      BIFailureValidationService.validateIncidentId(incidentId);\n      BIFailureValidationService.validateFacilityId(facilityId);\n\n      const config =\n        await NotificationMessenger.getNotificationConfig(facilityId);\n      const escalationRecipients =\n        NotificationScheduler.getEscalationRecipients(escalationLevel, config);\n\n      if (escalationRecipients.length === 0) {\n        return false;\n      }\n\n      const incidentDetails = await this.getIncidentDetails(\n        incidentId,\n        facilityId\n      );\n\n      const notification = NotificationFormatters.createNotificationMessage(\n        incidentId,\n        facilityId,\n        'high', // Escalations are typically high priority\n        'escalation',\n        incidentDetails,\n        escalationRecipients,\n        `BI Failure incident ${incidentDetails.incidentNumber} requires ${escalationLevel} attention.`\n      );\n\n      await NotificationMessenger.sendNotification(notification);\n      return true;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'send escalation notification'\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Schedule delayed notification\n   */\n  static async scheduleDelayedNotification(\n    incidentId: string,\n    facilityId: string,\n    delayMinutes: number = this.DEFAULT_NOTIFICATION_DELAY\n  ): Promise<string> {\n    try {\n      return await NotificationScheduler.scheduleDelayedNotification(\n        incidentId,\n        facilityId,\n        delayMinutes\n      );\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'schedule delayed notification'\n      );\n      return '';\n    }\n  }\n\n  /**\n   * Get notification history for an incident\n   */\n  static async getNotificationHistory(\n    incidentId: string\n  ): Promise<NotificationMessage[]> {\n    try {\n      BIFailureValidationService.validateIncidentId(incidentId);\n\n      const { data, error } = await supabase\n        .from('notifications')\n        .select('*')\n        .eq('incident_id', incidentId)\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        const errorData = error as SupabaseError;\n        throw new Error(\n          `Failed to get notification history: ${errorData.message}`\n        );\n      }\n\n      if (!data) return [];\n\n      return ((data as NotificationRow[]) || []).map(\n        (item): NotificationMessage => ({\n          id: item.id,\n          incidentId: item.incident_id,\n          facilityId: item.facility_id,\n          severity:\n            (item.severity as 'low' | 'medium' | 'high' | 'critical') || 'low',\n          messageType:\n            (item.message_type as 'regulatory' | 'internal' | 'escalation') ||\n            'internal',\n          recipients: (item.recipients as string[]) || [],\n          subject: item.subject,\n          body: item.body,\n          sentAt: item.sent_at || undefined,\n          status:\n            (item.status as 'pending' | 'sent' | 'failed' | 'delivered') ||\n            'pending',\n          retryCount: item.retry_count,\n          maxRetries: item.max_retries,\n        })\n      );\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'get notification history'\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Retry failed notifications\n   */\n  static async retryFailedNotifications(incidentId: string): Promise<number> {\n    try {\n      BIFailureValidationService.validateIncidentId(incidentId);\n\n      const failedNotifications = await this.getFailedNotifications(incidentId);\n      let retryCount = 0;\n\n      for (const notification of failedNotifications) {\n        if (notification.retryCount < notification.maxRetries) {\n          try {\n            await NotificationMessenger.sendNotification(notification);\n            retryCount++;\n\n            // Log retry attempt\n            await BIFailureNotificationDataProvider.logNotificationAuditEvent(\n              notification.id,\n              'retried',\n              `Retry attempt ${notification.retryCount + 1}/${notification.maxRetries}`,\n              await this.getCurrentUserId()\n            );\n          } catch (error) {\n            // Log retry failure\n            await BIFailureNotificationDataProvider.logNotificationAuditEvent(\n              notification.id,\n              'retry_failed',\n              `Retry attempt ${notification.retryCount + 1} failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              await this.getCurrentUserId()\n            );\n          }\n        }\n      }\n\n      return retryCount;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'BIFailureError') {\n        throw error;\n      }\n\n      BIFailureErrorHandler.handleUnexpectedError(\n        error,\n        'retry failed notifications'\n      );\n      return 0;\n    }\n  }\n\n  /**\n   * Get incident details\n   */\n  private static async getIncidentDetails(\n    incidentId: string,\n    facilityId: string\n  ): Promise<IncidentDetails> {\n    try {\n      const { data, error } = await supabase\n        .from('bi_failure_incidents')\n        .select('*')\n        .eq('id', incidentId)\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (error) {\n        const errorData = error as SupabaseError;\n        throw new Error(`Failed to get incident details: ${errorData.message}`);\n      }\n\n      if (!data) {\n        throw new Error('Incident not found');\n      }\n\n      const incidentData = data as BIFailureIncidentRow;\n      return {\n        incidentNumber: incidentData.incident_number,\n        failureDate: incidentData.failure_date,\n        affectedToolsCount: incidentData.affected_tools_count,\n        failureReason: incidentData.failure_reason || undefined,\n      };\n    } catch (error) {\n      // Return fallback data\n      return {\n        incidentNumber: `BI-FAIL-${incidentId.substring(0, 8)}`,\n        failureDate: new Date().toISOString(),\n        affectedToolsCount: 0,\n        failureReason: 'Unknown',\n      };\n    }\n  }\n\n  /**\n   * Get default recipients for notification\n   */\n  private static async getDefaultRecipients(): Promise<string[]> {\n    try {\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        return ['admin@facility.com', 'supervisor@facility.com'];\n      }\n\n      const { data, error } = await supabase\n        .from('facility_staff')\n        .select('email')\n        .eq('facility_id', facilityId)\n        .eq('is_active', true)\n        .in('role', ['admin', 'supervisor', 'manager']);\n\n      if (error) {\n        return ['admin@facility.com', 'supervisor@facility.com'];\n      }\n\n      if (!data) return ['admin@facility.com', 'supervisor@facility.com'];\n\n      return ((data as { email: string }[]) || []).map((item) => item.email);\n    } catch (error) {\n      return ['admin@facility.com', 'supervisor@facility.com'];\n    }\n  }\n\n  /**\n   * Get failed notifications\n   */\n  private static async getFailedNotifications(\n    incidentId: string\n  ): Promise<NotificationMessage[]> {\n    try {\n      const { data, error } = await supabase\n        .from('notifications')\n        .select('*')\n        .eq('incident_id', incidentId)\n        .eq('status', 'failed')\n        .lt('retry_count', 'max_retries');\n\n      if (error) {\n        const errorData = error as SupabaseError;\n        throw new Error(\n          `Failed to get failed notifications: ${errorData.message}`\n        );\n      }\n\n      if (!data) return [];\n\n      return ((data as NotificationRow[]) || []).map(\n        (item): NotificationMessage => ({\n          id: item.id,\n          incidentId: item.incident_id,\n          facilityId: item.facility_id,\n          severity:\n            (item.severity as 'low' | 'medium' | 'high' | 'critical') || 'low',\n          messageType:\n            (item.message_type as 'regulatory' | 'internal' | 'escalation') ||\n            'internal',\n          recipients: (item.recipients as string[]) || [],\n          subject: item.subject,\n          body: item.body,\n          sentAt: item.sent_at || undefined,\n          status:\n            (item.status as 'pending' | 'sent' | 'failed' | 'delivered') ||\n            'pending',\n          retryCount: item.retry_count,\n          maxRetries: item.max_retries,\n        })\n      );\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Update incident notification status\n   */\n  private static async updateIncidentNotificationStatus(\n    incidentId: string,\n    facilityId: string,\n    notificationSent: boolean\n  ): Promise<void> {\n    try {\n      const updateData = {\n        regulatory_notification_sent: notificationSent,\n        regulatory_notification_date: notificationSent\n          ? new Date().toISOString()\n          : null,\n        updated_at: new Date().toISOString(),\n      };\n\n      const { error } = await supabase\n        .from('bi_failure_incidents')\n        .update(updateData)\n        .eq('id', incidentId)\n        .eq('facility_id', facilityId);\n\n      if (error) {\n        // Only log errors in non-test environments\n        if (\n          !(global as { __TESTING__?: boolean }).__TESTING__ &&\n          process.env.NODE_ENV !== 'test'\n        ) {\n          console.error(\n            'Failed to update incident notification status:',\n            error\n          );\n        }\n      }\n    } catch (error) {\n      // Only log errors in non-test environments\n      if (\n        !(global as { __TESTING__?: boolean }).__TESTING__ &&\n        process.env.NODE_ENV !== 'test'\n      ) {\n        console.error('Error updating incident notification status:', error);\n      }\n    }\n  }\n\n  /**\n   * Get current user ID\n   */\n  private static async getCurrentUserId(): Promise<string | undefined> {\n    try {\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      return user?.id;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureValidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\BIFailureWorkflowService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\BIFailureAnalyticsSummaryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\BIFailureComplianceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\BIFailurePredictiveService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\BIFailureRealTimeService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 53,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 53,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1385, 1388], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1385, 1388], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../../../lib/supabaseClient';\nimport { logger } from '../../../../utils/_core/logger';\n\nexport interface RealTimeDashboardData {\n  facilityId: string;\n  activeIncidents: number;\n  pendingActions: number;\n  lastUpdated: string;\n  alerts: Array<{\n    id: string;\n    type: 'warning' | 'critical' | 'info';\n    message: string;\n    severity: 'low' | 'medium' | 'high' | 'critical';\n    timestamp: string;\n    actionRequired: boolean;\n  }>;\n  incidentSummary: {\n    totalToday: number;\n    totalThisWeek: number;\n    totalThisMonth: number;\n    resolvedToday: number;\n    escalatedToday: number;\n  };\n  performanceMetrics: {\n    averageResponseTime: number;\n    averageResolutionTime: number;\n    complianceScore: number;\n    riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  };\n  recentActivity: Array<{\n    id: string;\n    action: string;\n    description: string;\n    timestamp: string;\n    user: string;\n    severity: 'low' | 'medium' | 'high' | 'critical';\n  }>;\n}\n\ninterface BIIncident {\n  id?: string | null;\n  facility_id?: string | null;\n  incident_type?: string | null;\n  description?: string | null;\n  severity?: string | null;\n  status?: string | null;\n  created_at?: string | null;\n  updated_at?: string | null;\n  resolved_at?: string | null;\n  reported_by?: string | null;\n  user_id?: string | null;\n  cost_impact?: number | null;\n  metadata?: any;\n  [key: string]: unknown;\n}\n\ninterface AuditLog {\n  action: string;\n  module: string;\n  [key: string]: unknown;\n}\n\nexport class BIFailureRealTimeService {\n  /**\n   * Get real-time dashboard data for a facility\n   */\n  static async getRealTimeDashboardData(\n    facilityId: string\n  ): Promise<RealTimeDashboardData> {\n    try {\n      const [\n        activeIncidents,\n        pendingActions,\n        alerts,\n        incidentSummary,\n        performanceMetrics,\n        recentActivity,\n      ] = await Promise.all([\n        this.getActiveIncidents(facilityId),\n        this.getPendingActions(facilityId),\n        this.generateAlerts(facilityId),\n        this.getIncidentSummary(facilityId),\n        this.getPerformanceMetrics(facilityId),\n        this.getRecentActivity(facilityId),\n      ]);\n\n      return {\n        facilityId,\n        activeIncidents,\n        pendingActions,\n        lastUpdated: new Date().toISOString(),\n        alerts,\n        incidentSummary,\n        performanceMetrics,\n        recentActivity,\n      };\n    } catch (error) {\n      logger.error('Error getting real-time dashboard data:', error);\n      throw new Error('Failed to get real-time dashboard data');\n    }\n  }\n\n  /**\n   * Get count of active incidents\n   */\n  private static async getActiveIncidents(facilityId: string): Promise<number> {\n    try {\n      const { count, error } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .in('status', ['open', 'in_progress', 'escalated']);\n\n      if (error) throw error;\n      return count || 0;\n    } catch (error) {\n      logger.error('Error getting active incidents count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get count of pending actions\n   */\n  private static async getPendingActions(facilityId: string): Promise<number> {\n    try {\n      // Count incidents that need attention\n      const { count: urgentCount, error: urgentError } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .eq('status', 'open')\n        .gte('severity', 'high');\n\n      if (urgentError) throw urgentError;\n\n      // Count overdue incidents\n      const { count: overdueCount, error: overdueError } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .eq('status', 'open')\n        .lt(\n          'created_at',\n          new Date(Date.now() - 48 * 60 * 60 * 1000).toISOString()\n        ); // > 48 hours\n\n      if (overdueError) throw overdueError;\n\n      return (urgentCount || 0) + (overdueCount || 0);\n    } catch (error) {\n      logger.error('Error getting pending actions count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Generate real-time alerts\n   */\n  private static async generateAlerts(facilityId: string) {\n    try {\n      const alerts = [];\n\n      // Check for critical incidents\n      const { data: criticalIncidents, error: criticalError } = await supabase\n        .from('quality_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .eq('severity', 'critical')\n        .eq('status', 'open');\n\n      if (criticalError) throw criticalError;\n\n      if (criticalIncidents && criticalIncidents.length > 0) {\n        alerts.push({\n          id: 'critical-incidents',\n          type: 'critical' as const,\n          message: `${criticalIncidents.length} critical incident(s) require immediate attention`,\n          severity: 'critical' as const,\n          timestamp: new Date().toISOString(),\n          actionRequired: true,\n        });\n      }\n\n      // Check for overdue incidents\n      const { data: overdueIncidents, error: overdueError } = await supabase\n        .from('quality_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .eq('status', 'open')\n        .lt(\n          'created_at',\n          new Date(Date.now() - 72 * 60 * 60 * 1000).toISOString()\n        ); // > 72 hours\n\n      if (overdueError) throw overdueError;\n\n      if (overdueIncidents && overdueIncidents.length > 0) {\n        alerts.push({\n          id: 'overdue-incidents',\n          type: 'warning' as const,\n          message: `${overdueIncidents.length} incident(s) are overdue for resolution`,\n          severity: 'high' as const,\n          timestamp: new Date().toISOString(),\n          actionRequired: true,\n        });\n      }\n\n      // Check for compliance issues\n      const complianceScore = await this.getComplianceScore(facilityId);\n      if (complianceScore < 70) {\n        alerts.push({\n          id: 'compliance-warning',\n          type: 'warning' as const,\n          message: `Compliance score is ${complianceScore}% - below recommended threshold`,\n          severity: 'medium' as const,\n          timestamp: new Date().toISOString(),\n          actionRequired: true,\n        });\n      }\n\n      // Check for high incident volume\n      const { data: recentIncidents, error: recentError } = await supabase\n        .from('quality_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n        ); // Last 24 hours\n\n      if (recentError) throw recentError;\n\n      if (recentIncidents && recentIncidents.length > 10) {\n        alerts.push({\n          id: 'high-incident-volume',\n          type: 'warning' as const,\n          message: `High incident volume: ${recentIncidents.length} incidents in the last 24 hours`,\n          severity: 'medium' as const,\n          timestamp: new Date().toISOString(),\n          actionRequired: false,\n        });\n      }\n\n      return alerts;\n    } catch (error) {\n      logger.error('Error generating alerts:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get incident summary statistics\n   */\n  private static async getIncidentSummary(facilityId: string) {\n    try {\n      const now = new Date();\n      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n      const monthAgo = new Date(\n        now.getFullYear(),\n        now.getMonth() - 1,\n        now.getDate()\n      );\n\n      const [\n        totalToday,\n        totalThisWeek,\n        totalThisMonth,\n        resolvedToday,\n        escalatedToday,\n      ] = await Promise.all([\n        this.getIncidentCount(\n          facilityId,\n          today.toISOString(),\n          now.toISOString()\n        ),\n        this.getIncidentCount(\n          facilityId,\n          weekAgo.toISOString(),\n          now.toISOString()\n        ),\n        this.getIncidentCount(\n          facilityId,\n          monthAgo.toISOString(),\n          now.toISOString()\n        ),\n        this.getResolvedCount(\n          facilityId,\n          today.toISOString(),\n          now.toISOString()\n        ),\n        this.getEscalatedCount(\n          facilityId,\n          today.toISOString(),\n          now.toISOString()\n        ),\n      ]);\n\n      return {\n        totalToday,\n        totalThisWeek,\n        totalThisMonth,\n        resolvedToday,\n        escalatedToday,\n      };\n    } catch (error) {\n      logger.error('Error getting incident summary:', error);\n      return {\n        totalToday: 0,\n        totalThisWeek: 0,\n        totalThisMonth: 0,\n        resolvedToday: 0,\n        escalatedToday: 0,\n      };\n    }\n  }\n\n  /**\n   * Get performance metrics\n   */\n  private static async getPerformanceMetrics(facilityId: string) {\n    try {\n      const { data: incidents, error } = await supabase\n        .from('quality_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n        ); // Last 30 days\n\n      if (error) throw error;\n\n      if (!incidents || incidents.length === 0) {\n        return {\n          averageResponseTime: 0,\n          averageResolutionTime: 0,\n          complianceScore: 100,\n          riskLevel: 'low' as const,\n        };\n      }\n\n      // Calculate average response time (using updated_at as proxy for response time)\n      const responseTimes = incidents\n        .filter((i) => i.updated_at && i.created_at)\n        .map(\n          (i) =>\n            new Date(i.updated_at as string).getTime() -\n            new Date(i.created_at as string).getTime()\n        );\n\n      const averageResponseTime =\n        responseTimes.length > 0\n          ? responseTimes.reduce((sum, time) => sum + time, 0) /\n            responseTimes.length /\n            (1000 * 60 * 60) // Convert to hours\n          : 0;\n\n      // Calculate average resolution time\n      const resolutionTimes = incidents\n        .filter((i) => i.resolved_at && i.created_at)\n        .map(\n          (i) =>\n            new Date(i.resolved_at as string).getTime() -\n            new Date(i.created_at as string).getTime()\n        );\n\n      const averageResolutionTime =\n        resolutionTimes.length > 0\n          ? resolutionTimes.reduce((sum, time) => sum + time, 0) /\n            resolutionTimes.length /\n            (1000 * 60 * 60) // Convert to hours\n          : 0;\n\n      // Calculate compliance score\n      const complianceScore = await this.getComplianceScore(facilityId);\n\n      // Determine risk level\n      const riskLevel = this.calculateRiskLevel(incidents, complianceScore);\n\n      return {\n        averageResponseTime: Math.round(averageResponseTime * 100) / 100,\n        averageResolutionTime: Math.round(averageResolutionTime * 100) / 100,\n        complianceScore,\n        riskLevel,\n      };\n    } catch (error) {\n      logger.error('Error getting performance metrics:', error);\n      return {\n        averageResponseTime: 0,\n        averageResolutionTime: 0,\n        complianceScore: 0,\n        riskLevel: 'high' as const,\n      };\n    }\n  }\n\n  /**\n   * Get recent activity\n   */\n  private static async getRecentActivity(facilityId: string) {\n    try {\n      const { data: auditLogs, error } = await supabase\n        .from('audit_logs')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .eq('module', 'bi_failure')\n        .gte(\n          'created_at',\n          new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n        ) // Last 24 hours\n        .order('created_at', { ascending: false })\n        .limit(20);\n\n      if (error) throw error;\n\n      return (auditLogs || []).map((log) => ({\n        id: (log as Record<string, unknown>).id as string,\n        action: (log as Record<string, unknown>).action as string,\n        description: this.formatAuditDescription(\n          log as Record<string, unknown> & { action: string; module: string }\n        ),\n        timestamp: (log as Record<string, unknown>).created_at as string,\n        user: ((log as Record<string, unknown>).user_id as string) || 'System',\n        severity: this.determineActivitySeverity(\n          log as Record<string, unknown> & { action: string; module: string }\n        ),\n      }));\n    } catch (error) {\n      logger.error('Error getting recent activity:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get incident count for a date range\n   */\n  private static async getIncidentCount(\n    facilityId: string,\n    startDate: string,\n    endDate: string\n  ): Promise<number> {\n    try {\n      const { count, error } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .gte('created_at', startDate)\n        .lte('created_at', endDate);\n\n      if (error) throw error;\n      return count || 0;\n    } catch (error) {\n      logger.error('Error getting incident count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get resolved count for a date range\n   */\n  private static async getResolvedCount(\n    facilityId: string,\n    startDate: string,\n    endDate: string\n  ): Promise<number> {\n    try {\n      const { count, error } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .eq('status', 'resolved')\n        .gte('resolved_at', startDate)\n        .lte('resolved_at', endDate);\n\n      if (error) throw error;\n      return count || 0;\n    } catch (error) {\n      logger.error('Error getting resolved count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get escalated count for a date range\n   */\n  private static async getEscalatedCount(\n    facilityId: string,\n    startDate: string,\n    endDate: string\n  ): Promise<number> {\n    try {\n      const { count, error } = await supabase\n        .from('quality_incidents')\n        .select('*', { count: 'exact', head: true })\n        .eq('facility_id', facilityId)\n        .eq('status', 'escalated')\n        .gte('updated_at', startDate)\n        .lte('updated_at', endDate);\n\n      if (error) throw error;\n      return count || 0;\n    } catch (error) {\n      logger.error('Error getting escalated count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get compliance score\n   */\n  private static async getComplianceScore(facilityId: string): Promise<number> {\n    try {\n      // This is a simplified calculation - in practice, you'd use the compliance service\n      const { data: incidents, error } = await supabase\n        .from('quality_incidents')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .gte(\n          'created_at',\n          new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()\n        );\n\n      if (error) throw error;\n\n      if (!incidents || incidents.length === 0) return 100;\n\n      const resolvedCount = incidents.filter(\n        (i) => i.status === 'resolved'\n      ).length;\n      const totalCount = incidents.length;\n\n      return Math.round((resolvedCount / totalCount) * 100);\n    } catch (error) {\n      logger.error('Error getting compliance score:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Calculate risk level\n   */\n  private static calculateRiskLevel(\n    incidents: BIIncident[],\n    complianceScore: number\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    const criticalIncidents = incidents.filter(\n      (i) => i.severity === 'critical'\n    ).length;\n    const unresolvedIncidents = incidents.filter(\n      (i) => i.status !== 'resolved'\n    ).length;\n\n    if (criticalIncidents > 0 || complianceScore < 50) return 'critical';\n    if (unresolvedIncidents > 10 || complianceScore < 70) return 'high';\n    if (unresolvedIncidents > 5 || complianceScore < 85) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Format audit description\n   */\n  private static formatAuditDescription(log: AuditLog): string {\n    const action = log.action;\n    const module = log.module;\n\n    switch (action) {\n      case 'create':\n        return `New ${module} incident created`;\n      case 'update':\n        return `${module} incident updated`;\n      case 'resolve':\n        return `${module} incident resolved`;\n      case 'escalate':\n        return `${module} incident escalated`;\n      default:\n        return `${action} action on ${module}`;\n    }\n  }\n\n  /**\n   * Determine activity severity\n   */\n  private static determineActivitySeverity(\n    log: AuditLog\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    const action = log.action;\n\n    switch (action) {\n      case 'escalate':\n        return 'high';\n      case 'create':\n      case 'update':\n        return 'medium';\n      default:\n        return 'low';\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\BIFailureTrendAnalysisService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\analytics\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\notification\\formatters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\notification\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\notification\\messenger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\notification\\scheduler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\notification\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\failure\\test-exports.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\EmailNotificationService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'to' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 200,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 200,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'subject' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 201,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 201,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'body' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 202,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 202,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 203,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 203,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport { BIFailureNotificationDataProvider } from './data/BIFailureNotificationDataProvider';\n// import * as nodemailer from 'nodemailer';\n\n/**\n * Email Notification Service\n * Handles email processing and sending via various providers\n */\nexport class EmailNotificationService {\n  /**\n   * Process email alert\n   */\n  static async processEmailAlert(alert: {\n    id: string;\n    incidentId: string;\n    facilityId: string;\n    recipientType: string;\n    emailAddress: string;\n    subject: string;\n    body: string;\n    priority: string;\n    retryCount: number;\n    maxRetries: number;\n  }): Promise<void> {\n    try {\n      // Update status to sending\n      await BIFailureNotificationDataProvider.updateEmailAlertStatus(\n        alert.id,\n        'sending'\n      );\n\n      // Send email\n      await this.sendEmail(alert.emailAddress, alert.subject, alert.body);\n\n      // Update status to sent\n      await BIFailureNotificationDataProvider.updateEmailAlertStatus(\n        alert.id,\n        'sent'\n      );\n\n      // Log successful email\n      await BIFailureNotificationDataProvider.logNotificationAuditEvent(\n        alert.id,\n        'email_sent',\n        `Email sent to ${alert.emailAddress}`\n      );\n    } catch (error) {\n      // Update status to failed\n      await BIFailureNotificationDataProvider.updateEmailAlertStatus(\n        alert.id,\n        'failed',\n        alert.retryCount + 1\n      );\n\n      // Log email failure\n      await BIFailureNotificationDataProvider.logNotificationAuditEvent(\n        alert.id,\n        'email_failed',\n        `Email failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Process email notification\n   */\n  static async processEmailNotification(notification: {\n    id: string;\n    data: Record<string, unknown>;\n  }): Promise<void> {\n    const { recipients, subject, body } = notification.data as {\n      recipients: string[];\n      subject: string;\n      body: string;\n    };\n\n    for (const recipient of recipients) {\n      await this.sendEmail(recipient, subject, body);\n    }\n  }\n\n  /**\n   * Send email using configured email service\n   */\n  private static async sendEmail(\n    to: string,\n    subject: string,\n    body: string\n  ): Promise<void> {\n    try {\n      const emailConfig = await this.getEmailServiceConfig();\n\n      if (!emailConfig.enabled) {\n        return;\n      }\n\n      switch (emailConfig.provider) {\n        case 'sendgrid':\n          await this.sendEmailViaSendGrid(to, subject, body, emailConfig);\n          break;\n        case 'supabase':\n          await this.sendEmailViaSupabase(to, subject, body, emailConfig);\n          break;\n        case 'smtp':\n          await this.sendEmailViaSMTP(to, subject, body, emailConfig);\n          break;\n        default:\n      }\n    } catch (error) {\n      console.error('Failed to send email:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get email service configuration\n   */\n  private static async getEmailServiceConfig(): Promise<{\n    enabled: boolean;\n    provider: 'sendgrid' | 'supabase' | 'smtp' | 'none';\n    apiKey?: string;\n    fromEmail?: string;\n    smtpConfig?: {\n      host: string;\n      port: number;\n      username: string;\n      password: string;\n    };\n  }> {\n    // TEMPORARILY DISABLED TO STOP EMAIL BOUNCES\n    return {\n      enabled: false,\n      provider: 'none',\n    };\n    try {\n      const { data, error } = await supabase\n        .from('facility_notification_config')\n        .select('email_service_config')\n        .single();\n\n      if (error || !data?.email_service_config) {\n        return { enabled: false, provider: 'none' };\n      }\n\n      return {\n        enabled:\n          (data.email_service_config as { enabled?: boolean })?.enabled ||\n          false,\n        provider: ((data.email_service_config as { provider?: string })\n          ?.provider || 'none') as 'none' | 'sendgrid' | 'supabase' | 'smtp',\n        apiKey: (data.email_service_config as { apiKey?: string })?.apiKey,\n        fromEmail: (data.email_service_config as { fromEmail?: string })\n          ?.fromEmail,\n        smtpConfig: (\n          data.email_service_config as { smtpConfig?: Record<string, unknown> }\n        )?.smtpConfig as\n          | { host: string; port: number; username: string; password: string }\n          | undefined,\n      };\n    } catch (error) {\n      console.error('Error getting email service config:', error);\n      return { enabled: false, provider: 'none' };\n    }\n  }\n\n  /**\n   * Send email via SendGrid\n   */\n  private static async sendEmailViaSendGrid(\n    to: string,\n    subject: string,\n    body: string,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${config.apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        personalizations: [{ to: [{ email: to }] }],\n        from: { email: config.fromEmail },\n        subject,\n        content: [{ type: 'text/plain', value: body }],\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`SendGrid API error: ${response.statusText}`);\n    }\n  }\n\n  /**\n   * Send email via Supabase\n   */\n  private static async sendEmailViaSupabase(\n    to: string,\n    subject: string,\n    body: string,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    try {\n      // Use Supabase's admin email API to send custom emails\n      // Note: Supabase doesn't have sendEmail method, using alternative approach\n      const error = null; // Placeholder for now\n\n      if (error) {\n        throw new Error(`Supabase email error: ${(error as Error).message}`);\n      }\n    } catch (error) {\n      console.error('Failed to send email via Supabase:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send email via SMTP\n   */\n  private static async sendEmailViaSMTP(\n    to: string,\n    subject: string,\n    body: string,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    try {\n      const smtpConfig = config.smtpConfig as {\n        host: string;\n        port: number;\n        username: string;\n        password: string;\n      };\n\n      if (!smtpConfig) {\n        throw new Error('SMTP configuration not provided');\n      }\n\n      // Create SMTP transporter\n      // const transporter = nodemailer.createTransporter({\n      //   host: smtpConfig.host,\n      //   port: smtpConfig.port,\n      //   secure: smtpConfig.port === 465, // true for 465, false for other ports\n      //   auth: {\n      //     user: smtpConfig.username,\n      //     pass: smtpConfig.password,\n      //   },\n      // });\n\n      // Send email\n      // const info = await transporter.sendMail({\n      //   from: config.fromEmail || 'noreply@cliniio.com',\n      //   to: to,\n      //   subject: subject,\n      //   text: body,\n      //   html: `<pre>${body}</pre>`, // Convert plain text to HTML\n      // });\n    } catch (error) {\n      console.error('Failed to send email via SMTP:', error);\n      throw error;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\NotificationProcessorService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\NotificationRetryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\NotificationScheduler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\NotificationSchedulerService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\WebhookNotificationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\data\\BIFailureNotificationDataProvider.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 88,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 88,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2066, 2069], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2066, 2069], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 129,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 129,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3186, 3189], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3186, 3189], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 154,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 154,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4109, 4112], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4109, 4112], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 199,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 199,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5437, 5440], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5437, 5440], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 247,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 247,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6851, 6854], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6851, 6854], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 284,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 284,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7751, 7754], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7751, 7754], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 350,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 350,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9582, 9585], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9582, 9585], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 381,
        "column": 71,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 381,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10347, 10350], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10347, 10350], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 395,
        "column": 75,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 395,
        "endColumn": 78,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10764, 10767], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10764, 10767], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 409,
        "column": 75,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 409,
        "endColumn": 78,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11188, 11191], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11188, 11191], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 460,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 460,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12427, 12430], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12427, 12430], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 510,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 510,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13626, 13629], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13626, 13629], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\types\\BIFailureNotificationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\utils\\BIFailureNotificationGenerators.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\notification\\utils\\BIFailureNotificationValidators.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\predictive\\__tests__\\biFailureRecommendations.test.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Invalid character.",
        "line": 960,
        "column": 3,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport {\n  Recommendation,\n  generatePredictiveRecommendations,\n  generatePatternBasedRecommendations,\n  generateGeneralRecommendations,\n  generateRiskBasedRecommendations,\n  generateTrendBasedRecommendations,\n  generateSeasonalRecommendations,\n  prioritizeRecommendations,\n  filterRecommendationsByType,\n  filterRecommendationsByPriority,\n  getTopRecommendations,\n} from '../biFailureRecommendations';\nimport { IncidentPatterns } from '../biTrendAnalysis';\n\n// Mock Supabase client\nconst mockSupabase = {\n  from: vi.fn(() => ({\n    select: vi.fn(() => ({\n      eq: vi.fn(() => ({\n        gte: vi.fn(() => ({\n          data: [],\n          error: null,\n        })),\n      })),\n    })),\n  })),\n};\n\n// Mock logger to avoid console output during tests\nvi.mock('../../../lib/supabaseClient', () => ({\n  supabase: mockSupabase,\n}));\n\nvi.mock('../../../utils/_core/logger', () => ({\n  logger: {\n    error: vi.fn(),\n    info: vi.fn(),\n    warn: vi.fn(),\n  },\n}));\n\n// Mock the analyzeIncidentPatterns function from biTrendAnalysis\nvi.mock('../biTrendAnalysis', async () => {\n  const actual = await vi.importActual('../biTrendAnalysis');\n  return {\n    ...actual,\n    analyzeIncidentPatterns: vi.fn(() => ({\n      highFrequencyPeriods: ['Monday', 'Friday'],\n      commonRootCauses: ['Equipment failure', 'Human error'],\n      equipmentFailureRate: 0.4,\n      responseTimeTrend: 1.3,\n    })),\n  };\n});\n\ndescribe('biFailureRecommendations', () => {\n  // Mock data for testing\n  const mockIncidents = [\n    {\n      created_at: '2024-01-15T10:00:00Z',\n      severity: 'critical',\n      status: 'resolved',\n    },\n    {\n      created_at: '2024-01-20T14:30:00Z',\n      severity: 'high',\n      status: 'resolved',\n    },\n    {\n      created_at: '2024-02-10T09:15:00Z',\n      severity: 'medium',\n      status: 'open',\n    },\n  ];\n\n  const mockPatterns: IncidentPatterns = {\n    highFrequencyPeriods: ['Monday', 'Friday'],\n    commonRootCauses: [\n      'Equipment failure',\n      'Human error',\n      'Maintenance issues',\n    ],\n    equipmentFailureRate: 0.4,\n    responseTimeTrend: 1.3,\n  };\n\n  const mockRiskFactors = [\n    {\n      factor: 'Daily Incident Rate',\n      weight: 0.3,\n      description: 'Average incidents per day',\n      currentValue: 0.5,\n      threshold: 0.3,\n      status: 'critical' as const,\n    },\n    {\n      factor: 'Critical Incident Rate',\n      weight: 0.25,\n      description: 'Percentage of critical severity incidents',\n      currentValue: 15,\n      threshold: 20,\n      status: 'warning' as const,\n    },\n    {\n      factor: 'Compliance Score',\n      weight: 0.1,\n      description: 'Overall compliance percentage',\n      currentValue: 95,\n      threshold: 85,\n      status: 'normal' as const,\n    },\n  ];\n\n  const mockTrendAnalysis = {\n    incidentTrend: 'increasing' as const,\n    riskTrend: 'increasing' as const,\n    confidence: 0.85,\n    nextWeekPrediction: 8,\n    nextMonthPrediction: 25,\n  };\n\n  const mockSeasonalPatterns = [\n    {\n      period: 'Winter',\n      incidentRate: 0.7,\n      description: 'Higher failure rates due to temperature fluctuations',\n      confidence: 0.8,\n    },\n    {\n      period: 'Summer',\n      incidentRate: 0.3,\n      description: 'Lower failure rates during stable weather',\n      confidence: 0.6,\n    },\n  ];\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    // Reset mock implementation\n    mockSupabase.from.mockReturnValue({\n      select: vi.fn(() => ({\n        eq: vi.fn(() => ({\n          gte: vi.fn(() => ({\n            data: mockIncidents,\n            error: null,\n          })),\n        })),\n      })),\n    });\n  });\n\n  describe('generatePredictiveRecommendations', () => {\n    it('should return empty array on error', async () => {\n      mockSupabase.from.mockReturnValue({\n        select: vi.fn(() => ({\n          eq: vi.fn(() => ({\n            gte: vi.fn(() => ({\n              data: null,\n              error: new Error('Database error'),\n            })),\n          })),\n        })),\n      });\n\n      const result = await generatePredictiveRecommendations('facility-1');\n      expect(result).toEqual([]);\n    });\n\n    it('should handle database connection errors gracefully', async () => {\n      // Mock a network error\n      mockSupabase.from.mockImplementation(() => {\n        throw new Error('Network error');\n      });\n\n      const result = await generatePredictiveRecommendations('facility-1');\n      expect(result).toEqual([]);\n    });\n\n    it('should handle empty facility ID gracefully', async () => {\n      const result = await generatePredictiveRecommendations('');\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('generatePatternBasedRecommendations', () => {\n    it('should generate recommendations for high frequency periods', () => {\n      const result = generatePatternBasedRecommendations(mockPatterns);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'frequency-pattern',\n            type: 'preventive',\n            title:\n              'Implement Preventive Measures During High-Frequency Periods',\n            priority: 'high',\n            estimatedImpact: 'high',\n            confidence: 0.85,\n          }),\n        ])\n      );\n    });\n\n    it('should generate recommendations for common root causes', () => {\n      const result = generatePatternBasedRecommendations(mockPatterns);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'root-cause-prevention',\n            type: 'preventive',\n            title: 'Address Common Root Causes',\n            priority: 'high',\n            estimatedImpact: 'high',\n            confidence: 0.9,\n          }),\n        ])\n      );\n    });\n\n    it('should generate recommendations for high equipment failure rate', () => {\n      const result = generatePatternBasedRecommendations(mockPatterns);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'equipment-maintenance',\n            type: 'preventive',\n            title: 'Enhance Equipment Maintenance Schedule',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.8,\n          }),\n        ])\n      );\n    });\n\n    it('should generate recommendations for high response time trend', () => {\n      const result = generatePatternBasedRecommendations(mockPatterns);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'response-time-optimization',\n            type: 'optimization',\n            title: 'Optimize Incident Response Procedures',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.75,\n          }),\n        ])\n      );\n    });\n\n    it('should return empty array for no patterns', () => {\n      const emptyPatterns: IncidentPatterns = {\n        highFrequencyPeriods: [],\n        commonRootCauses: [],\n        equipmentFailureRate: 0.1,\n        responseTimeTrend: 1.0,\n      };\n\n      const result = generatePatternBasedRecommendations(emptyPatterns);\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('generateGeneralRecommendations', () => {\n    it('should always return baseline recommendations', () => {\n      const result = generateGeneralRecommendations();\n\n      expect(result).toHaveLength(2);\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'staff-training',\n            type: 'preventive',\n            title: 'Implement Predictive Training Program',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.7,\n            timeframe: '6-8 weeks',\n          }),\n          expect.objectContaining({\n            id: 'monitoring-enhancement',\n            type: 'preventive',\n            title: 'Enhance Real-Time Monitoring',\n            priority: 'low',\n            estimatedImpact: 'high',\n            confidence: 0.65,\n            timeframe: '8-12 weeks',\n          }),\n        ])\n      );\n    });\n  });\n\n  describe('generateRiskBasedRecommendations', () => {\n    it('should generate critical recommendations for critical risk factors', () => {\n      const result = generateRiskBasedRecommendations(mockRiskFactors);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'critical-daily-incident-rate',\n            type: 'reactive',\n            title: 'Address Critical Daily Incident Rate',\n            priority: 'critical',\n            estimatedImpact: 'high',\n            confidence: 0.9,\n            timeframe: '1-2 weeks',\n          }),\n        ])\n      );\n    });\n\n    it('should generate warning recommendations for warning risk factors', () => {\n      const result = generateRiskBasedRecommendations(mockRiskFactors);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'warning-critical-incident-rate',\n            type: 'preventive',\n            title: 'Monitor Critical Incident Rate',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.7,\n            timeframe: '2-4 weeks',\n          }),\n        ])\n      );\n    });\n\n    it('should not generate recommendations for normal risk factors', () => {\n      const result = generateRiskBasedRecommendations(mockRiskFactors);\n\n      // Should not contain recommendations for normal status factors\n      const normalFactorRecommendations = result.filter((rec) =>\n        rec.title.includes('Compliance Score')\n      );\n      expect(normalFactorRecommendations).toHaveLength(0);\n    });\n\n    it('should return empty array for empty risk factors', () => {\n      const result = generateRiskBasedRecommendations([]);\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('generateTrendBasedRecommendations', () => {\n    it('should generate recommendations for increasing incident trend', () => {\n      const result = generateTrendBasedRecommendations(mockTrendAnalysis);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'increasing-incident-trend',\n            type: 'preventive',\n            title: 'Address Increasing Incident Trend',\n            priority: 'high',\n            estimatedImpact: 'high',\n            confidence: 0.85,\n            timeframe: '2-3 weeks',\n          }),\n        ])\n      );\n    });\n\n    it('should generate recommendations for increasing risk trend', () => {\n      const result = generateTrendBasedRecommendations(mockTrendAnalysis);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'increasing-risk-trend',\n            type: 'preventive',\n            title: 'Mitigate Increasing Risk Trend',\n            priority: 'high',\n            estimatedImpact: 'high',\n            confidence: 0.85,\n            timeframe: '1-2 weeks',\n          }),\n        ])\n      );\n    });\n\n    it('should generate recommendations for high weekly prediction', () => {\n      const result = generateTrendBasedRecommendations(mockTrendAnalysis);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'high-weekly-prediction',\n            type: 'reactive',\n            title: 'Prepare for High Incident Volume',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.85,\n            timeframe: '1 week',\n          }),\n        ])\n      );\n    });\n\n    it('should return minimal recommendations for stable trends', () => {\n      const stableTrendAnalysis = {\n        incidentTrend: 'stable' as const,\n        riskTrend: 'stable' as const,\n        confidence: 0.5,\n        nextWeekPrediction: 2,\n        nextMonthPrediction: 8,\n      };\n\n      const result = generateTrendBasedRecommendations(stableTrendAnalysis);\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('generateSeasonalRecommendations', () => {\n    it('should generate recommendations for high incident rate periods', () => {\n      const result = generateSeasonalRecommendations(mockSeasonalPatterns);\n\n      expect(result).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: 'high-winter-incidents',\n            type: 'preventive',\n            title: 'Prepare for High Winter Incident Rate',\n            priority: 'medium',\n            estimatedImpact: 'medium',\n            confidence: 0.8,\n            timeframe: '4-6 weeks',\n          }),\n        ])\n      );\n    });\n\n    it('should not generate recommendations for low incident rate periods', () => {\n      const result = generateSeasonalRecommendations(mockSeasonalPatterns);\n\n      // Should not contain recommendations for summer (low rate)\n      const summerRecommendations = result.filter((rec) =>\n        rec.title.includes('Summer')\n      );\n      expect(summerRecommendations).toHaveLength(0);\n    });\n\n    it('should return empty array for empty seasonal patterns', () => {\n      const result = generateSeasonalRecommendations([]);\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('prioritizeRecommendations', () => {\n    it('should sort by priority correctly', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: 'low-priority',\n          type: 'preventive',\n          title: 'Low Priority',\n          description: 'Low priority task',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.9,\n          timeframe: '1 week',\n        },\n        {\n          id: 'critical-priority',\n          type: 'reactive',\n          title: 'Critical Priority',\n          description: 'Critical priority task',\n          priority: 'critical',\n          estimatedImpact: 'high',\n          confidence: 0.7,\n          timeframe: '1 day',\n        },\n        {\n          id: 'medium-priority',\n          type: 'optimization',\n          title: 'Medium Priority',\n          description: 'Medium priority task',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.8,\n          timeframe: '2 weeks',\n        },\n      ];\n\n      const result = prioritizeRecommendations(recommendations);\n\n      expect(result[0].priority).toBe('critical');\n      expect(result[1].priority).toBe('medium');\n      expect(result[2].priority).toBe('low');\n    });\n\n    it('should sort by impact when priority is equal', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: 'low-impact',\n          type: 'preventive',\n          title: 'Low Impact',\n          description: 'Low impact task',\n          priority: 'medium',\n          estimatedImpact: 'low',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n        {\n          id: 'high-impact',\n          type: 'preventive',\n          title: 'High Impact',\n          description: 'High impact task',\n          priority: 'medium',\n          estimatedImpact: 'high',\n          confidence: 0.7,\n          timeframe: '2 weeks',\n        },\n      ];\n\n      const result = prioritizeRecommendations(recommendations);\n\n      expect(result[0].estimatedImpact).toBe('high');\n      expect(result[1].estimatedImpact).toBe('low');\n    });\n\n    it('should sort by confidence when priority and impact are equal', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: 'low-confidence',\n          type: 'preventive',\n          title: 'Low Confidence',\n          description: 'Low confidence task',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.6,\n          timeframe: '1 week',\n        },\n        {\n          id: 'high-confidence',\n          type: 'preventive',\n          title: 'High Confidence',\n          description: 'High confidence task',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.9,\n          timeframe: '2 weeks',\n        },\n      ];\n\n      const result = prioritizeRecommendations(recommendations);\n\n      expect(result[0].confidence).toBe(0.9);\n      expect(result[1].confidence).toBe(0.6);\n    });\n  });\n\n  describe('filterRecommendationsByType', () => {\n    it('should filter by preventive type', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Preventive 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'Reactive 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        {\n          id: '3',\n          type: 'preventive',\n          title: 'Preventive 2',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n      ];\n\n      const result = filterRecommendationsByType(recommendations, 'preventive');\n\n      expect(result).toHaveLength(2);\n      expect(result.every((rec) => rec.type === 'preventive')).toBe(true);\n    });\n\n    it('should filter by reactive type', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Preventive 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'Reactive 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        {\n          id: '3',\n          type: 'optimization',\n          title: 'Optimization 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n      ];\n\n      const result = filterRecommendationsByType(recommendations, 'reactive');\n\n      expect(result).toHaveLength(1);\n      expect(result[0].type).toBe('reactive');\n    });\n\n    it('should return empty array for no matching type', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Preventive 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n      ];\n\n      const result = filterRecommendationsByType(recommendations, 'reactive');\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('filterRecommendationsByPriority', () => {\n    it('should filter by critical priority', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Critical 1',\n          description: '',\n          priority: 'critical',\n          estimatedImpact: 'high',\n          confidence: 0.9,\n          timeframe: '1 day',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'High 1',\n          description: '',\n          priority: 'high',\n          estimatedImpact: 'high',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n        {\n          id: '3',\n          type: 'preventive',\n          title: 'Critical 2',\n          description: '',\n          priority: 'critical',\n          estimatedImpact: 'high',\n          confidence: 0.9,\n          timeframe: '1 day',\n        },\n      ];\n\n      const result = filterRecommendationsByPriority(\n        recommendations,\n        'critical'\n      );\n\n      expect(result).toHaveLength(2);\n      expect(result.every((rec) => rec.priority === 'critical')).toBe(true);\n    });\n\n    it('should filter by medium priority', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Medium 1',\n          description: '',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.7,\n          timeframe: '2 weeks',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'High 1',\n          description: '',\n          priority: 'high',\n          estimatedImpact: 'high',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n        {\n          id: '3',\n          type: 'optimization',\n          title: 'Medium 2',\n          description: '',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.7,\n          timeframe: '2 weeks',\n        },\n      ];\n\n      const result = filterRecommendationsByPriority(recommendations, 'medium');\n\n      expect(result).toHaveLength(2);\n      expect(result.every((rec) => rec.priority === 'medium')).toBe(true);\n    });\n\n    it('should return empty array for no matching priority', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Low 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 month',\n        },\n      ];\n\n      const result = filterRecommendationsByPriority(\n        recommendations,\n        'critical'\n      );\n      expect(result).toEqual([]);\n    });\n  });\n\n  describe('getTopRecommendations', () => {\n    it('should return top N recommendations by priority', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Low 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 month',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'Critical 1',\n          description: '',\n          priority: 'critical',\n          estimatedImpact: 'high',\n          confidence: 0.9,\n          timeframe: '1 day',\n        },\n        {\n          id: '3',\n          type: 'preventive',\n          title: 'High 1',\n          description: '',\n          priority: 'high',\n          estimatedImpact: 'high',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n        {\n          id: '4',\n          type: 'optimization',\n          title: 'Medium 1',\n          description: '',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.7,\n          timeframe: '2 weeks',\n        },\n        {\n          id: '5',\n          type: 'reactive',\n          title: 'Critical 2',\n          description: '',\n          priority: 'critical',\n          estimatedImpact: 'high',\n          confidence: 0.9,\n          timeframe: '1 day',\n        },\n      ];\n\n      const result = getTopRecommendations(recommendations, 3);\n\n      expect(result).toHaveLength(3);\n      expect(result[0].priority).toBe('critical');\n      expect(result[1].priority).toBe('critical');\n      expect(result[2].priority).toBe('high');\n    });\n\n    it('should return all recommendations when limit is greater than array length', () => {\n      const recommendations: Recommendation[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Test 1',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        {\n          id: '2',\n          type: 'reactive',\n          title: 'Test 2',\n          description: '',\n          priority: 'high',\n          estimatedImpact: 'high',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n      ];\n\n      const result = getTopRecommendations(recommendations, 5);\n\n      expect(result).toHaveLength(2);\n    });\n\n    it('should use default limit of 5', () => {\n      const recommendations: Recommendation[] = Array(10)\n        .fill(null)\n        .map((_, i) => ({\n          id: `test-${i}`,\n          type: 'preventive' as const,\n          title: `Test ${i}`,\n          description: '',\n          priority: 'low' as const,\n          estimatedImpact: 'low' as const,\n          confidence: 0.5,\n          timeframe: '1 week',\n        }));\n\n      const result = getTopRecommendations(recommendations);\n\n      expect(result).toHaveLength(5);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle empty arrays gracefully', () => {\n      expect(prioritizeRecommendations([])).toEqual([]);\n      expect(filterRecommendationsByType([], 'preventive')).toEqual([]);\n      expect(filterRecommendationsByPriority([], 'critical')).toEqual([]);\n      expect(getTopRecommendations([])).toEqual([]);\n    });\n\n    it('should handle mixed invalid input gracefully', () => {\n      const invalidRecommendations = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Valid',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        null,\n        undefined,\n        {\n          id: '2',\n          type: 'preventive',\n          title: 'Valid 2',\n          description: '',\n          priority: 'high',\n          estimatedImpact: 'high',\n          confidence: 0.8,\n          timeframe: '1 week',\n        },\n      ].filter(Boolean) as Recommendation[];\n\n      expect(() =>\n        prioritizeRecommendations(invalidRecommendations)\n      ).not.toThrow();\n      expect(() =>\n        filterRecommendationsByType(invalidRecommendations, 'preventive')\n      ).not.toThrow();\n      expect(() =>\n        filterRecommendationsByPriority(invalidRecommendations, 'high')\n      ).not.toThrow();\n      expect(() => getTopRecommendations(invalidRecommendations)).not.toThrow();\n    });\n\n    it('should handle recommendations with missing properties gracefully', () => {\n      const incompleteRecommendations: any[] = [\n        {\n          id: '1',\n          type: 'preventive',\n          title: 'Complete',\n          description: '',\n          priority: 'low',\n          estimatedImpact: 'low',\n          confidence: 0.5,\n          timeframe: '1 week',\n        },\n        { id: '2', type: 'preventive', title: 'Incomplete', priority: 'high' }, // Missing properties\n        {\n          id: '3',\n          type: 'reactive',\n          title: 'Another Complete',\n          description: '',\n          priority: 'medium',\n          estimatedImpact: 'medium',\n          confidence: 0.7,\n          timeframe: '2 weeks',\n        },\n      ];\n\n      expect(() =>\n        prioritizeRecommendations(incompleteRecommendations)\n      ).not.toThrow();\n      expect(() =>\n        filterRecommendationsByType(incompleteRecommendations, 'preventive')\n      ).not.toThrow();\n      expect(() =>\n        filterRecommendationsByPriority(incompleteRecommendations, 'high')\n      ).not.toThrow();\n    });\n  });\n});\u0000\n\u0000",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\predictive\\__tests__\\biRiskScoringEngine.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\bi\\predictive\\__tests__\\biTrendAnalysis.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\CacheInvalidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\CacheWarmingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\DistributedCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\DistributedFacilityCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\InMemoryCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\SimpleCacheInvalidationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\SimpleCacheWarmingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\cacheInvalidationCompatibility.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cache\\cacheWarmingCompatibility.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cameraScanningService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: 'catch' or 'finally' expected.",
        "line": 106,
        "column": 7,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { BrowserMultiFormatReader } from '@zxing/library';\n\nexport interface ScanResult {\n  barcode: string;\n  format: string;\n  timestamp: string;\n  confidence?: number;\n}\n\nexport interface CameraConfig {\n  width: number;\n  height: number;\n  facingMode: 'environment' | 'user';\n  formats: string[];\n}\n\nexport class CameraScanningService {\n  private static zxingReader: BrowserMultiFormatReader | null = null;\n  private static isInitialized = false;\n\n  /**\n   * Initialize camera scanning service\n   */\n  static async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Initialize ZXing reader for barcode detection\n      this.zxingReader = new BrowserMultiFormatReader();\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize camera scanning service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start camera scanning with real-time barcode detection\n   */\n  static async startCameraScan(\n    videoElement: HTMLVideoElement,\n    onScanComplete: (result: ScanResult) => void,\n    onError: (error: string) => void\n  ): Promise<void> {\n    try {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n\n      // Use ZXing for barcode detection\n      if (this.zxingReader) {\n        await this.startZXingScan(videoElement, onScanComplete, onError);\n      } else {\n        onError('ZXing reader not initialized');\n      }\n    } catch (error) {\n      console.error('Failed to start camera scan:', error);\n      onError(\n        error instanceof Error ? error.message : 'Failed to start camera scan'\n      );\n    }\n  }\n\n  /**\n   * Start ZXing barcode scanning\n   */\n  private static async startZXingScan(\n    videoElement: HTMLVideoElement,\n    onScanComplete: (result: ScanResult) => void,\n    onError: (error: string) => void\n  ): Promise<void> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          facingMode: 'environment',\n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n        },\n      });\n\n      videoElement.srcObject = stream;\n      videoElement.play();\n\n      // Start continuous scanning\n      const scanLoop = async () => {\n        try {\n          const result =\n            await this.zxingReader!.decodeFromVideoElement(videoElement);\n\n          if (result) {\n            const scanResult: ScanResult = {\n              barcode: result.getText(),\n              format: result.getBarcodeFormat().toString(),\n              timestamp: new Date().toISOString(),\n            };\n\n            onScanComplete(scanResult);\n            return; // Stop scanning after successful scan\n          }\n        } catch (err) { console.error(err); throw err; }\n          onError('Failed to start ZXing scanning');\n        }\n\n        // Continue scanning\n        requestAnimationFrame(scanLoop);\n      };\n\n      scanLoop();\n    } catch (err) { console.error(err); throw err; }\n      onError('Failed to access camera');\n    }\n  }\n\n  /**\n   * Stop camera scanning\n   */\n  static stopCameraScan(): void {\n    try {\n      if (this.zxingReader) {\n        this.zxingReader.reset();\n      }\n    } catch (err) { console.error(err); throw err; }\n      console.error('Error stopping camera scan');\n    }\n  }\n\n  /**\n   * Process image file for barcode detection\n   */\n  static async processImageFile(\n    file: File,\n    onScanComplete: (result: ScanResult) => void,\n    onError: (error: string) => void\n  ): Promise<void> {\n    try {\n      if (!this.zxingReader) {\n        await this.initialize();\n      }\n\n      // Create image element\n      const img = new Image();\n      const url = URL.createObjectURL(file);\n\n      img.onload = async () => {\n        try {\n          const result = await this.zxingReader!.decodeFromImage(img);\n\n          const scanResult: ScanResult = {\n            barcode: result.getText(),\n            format: result.getBarcodeFormat().toString(),\n            timestamp: new Date().toISOString(),\n          };\n\n          onScanComplete(scanResult);\n        } catch (err) { console.error(err); throw err; }\n          onError('No barcode found in image');\n        } finally {\n          URL.revokeObjectURL(url);\n        }\n      };\n\n      img.onerror = () => {\n        onError('Failed to load image');\n        URL.revokeObjectURL(url);\n      };\n\n      img.src = url;\n    } catch (err) { console.error(err); throw err; }\n      onError('Failed to process image');\n    }\n  }\n\n  /**\n   * Check if camera is available\n   */\n  static async isCameraAvailable(): Promise<boolean> {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.some((device) => device.kind === 'videoinput');\n    } catch (err) { console.error(err); throw err; }\n      return false;\n    }\n  }\n\n  /**\n   * Get camera permissions\n   */\n  static async requestCameraPermission(): Promise<boolean> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return true;\n    } catch (err) { console.error(err); throw err; }\n      return false;\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  static cleanup(): void {\n    this.stopCameraScan();\n    this.isInitialized = false;\n    this.zxingReader = null;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\categoryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\challengeCompletionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\challengeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningScheduleService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\services\\cleaningScheduleAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\services\\cleaningScheduleAssignmentService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\services\\cleaningScheduleCoreService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\services\\cleaningScheduleGeneratorService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\services\\cleaningScheduleIntegrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\types\\cleaningScheduleServiceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\utils\\cleaningScheduleCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\utils\\cleaningScheduleHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\cleaningSchedule\\utils\\cleaningScheduleTransformers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\databaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\enhancedLeaderboardService.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 64,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 64,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1482, 1485], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1482, 1485], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 98,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 98,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2327, 2330], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2327, 2330], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 326,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 326,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9378, 9381], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9378, 9381], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\environmental\\environmentalCleaningTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\errorReportingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\error\\ErrorHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\facilityService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\feedbackService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\gamificationService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'enhancedError' is defined but never used.",
        "line": 126,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 126,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 132,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 132,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3733, 3736], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3733, 3736], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 194,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 194,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5677, 5680], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5677, 5680], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 210,
        "column": 69,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 210,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6263, 6266], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6263, 6266], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 254,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 254,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7603, 7606], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7603, 7606], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 304,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 304,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9144, 9147], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9144, 9147], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type {\n  GamificationStats,\n  LeaderboardData,\n  ChallengeData,\n  MetricsData,\n} from '../types/home';\nimport { supabase } from '../lib/supabaseClient';\n\n// Database row interfaces\ninterface UserGamificationStatsRow {\n  current_streak: number;\n  total_points: number;\n  total_tasks: number;\n  completed_tasks: number;\n  best_streak: number;\n}\n\ninterface UserLeaderboardRow {\n  user_id: string;\n  total_points: number;\n  current_streak: number;\n}\n\ninterface UserRow {\n  id: string;\n  full_name: string | null;\n}\n\ninterface ChallengeRow {\n  title: string;\n  description: string;\n  points: number;\n  difficulty: string;\n}\n\ninterface MetricsRow {\n  metric_name: string;\n  metric_value: number;\n}\n\nexport interface GamificationServiceResponse {\n  gamificationData: GamificationStats;\n  leaderboardData: LeaderboardData;\n  challengeData: ChallengeData;\n  metricsData: MetricsData;\n}\n\nexport interface GamificationService {\n  fetchGamificationData(): Promise<GamificationStats>;\n  fetchLeaderboardData(): Promise<LeaderboardData>;\n  fetchChallengeData(): Promise<ChallengeData>;\n  fetchMetricsData(): Promise<MetricsData>;\n  fetchAllData(): Promise<GamificationServiceResponse>;\n}\n\n/**\n * Gamification service for managing gamification data\n */\nclass GamificationServiceImpl implements GamificationService {\n  private cachedData: Partial<GamificationServiceResponse> = {};\n\n  private async getCurrentFacilityId(): Promise<string> {\n    try {\n      const { FacilityService } = await import('./facilityService');\n      const { facilityId } = await FacilityService.getCurrentUserAndFacility();\n      return facilityId;\n    } catch (error) {\n      console.error('Failed to get current facility ID:', error);\n      throw error;\n    }\n  }\n\n  private async getCurrentUserId(): Promise<string | null> {\n    try {\n      const { data, error } = await supabase.auth.getUser();\n      if (error || !data?.user) {\n        console.error('Error getting user:', error);\n        return null;\n      }\n      return data.user.id;\n    } catch (error) {\n      console.error('Error fetching user:', error);\n      return null;\n    }\n  }\n\n  async fetchGamificationData(): Promise<GamificationStats> {\n    if (this.cachedData.gamificationData) {\n      return this.cachedData.gamificationData;\n    }\n\n    try {\n      const userId = await this.getCurrentUserId();\n      if (!userId) {\n        return this.getDefaultGamificationData();\n      }\n\n      try {\n        const { data } = await supabase.auth.getUser();\n        if (data?.user?.id) {\n          const { calculateEnhancedLevel } = await import(\n            '../utils/enhancedGamification'\n          );\n          const facilityId = await this.getCurrentFacilityId();\n          const enhancedData = await calculateEnhancedLevel(userId, facilityId);\n\n          const gamificationData: GamificationStats = {\n            streak: enhancedData.totalExperience > 0 ? 1 : 0,\n            level: enhancedData.coreLevel,\n            rank: enhancedData.rank,\n            totalScore: enhancedData.totalExperience,\n            stats: {\n              toolsSterilized: 0,\n              inventoryChecks: 0,\n              perfectDays: 0,\n              totalTasks: 0,\n              completedTasks: 0,\n              currentStreak: enhancedData.totalExperience > 0 ? 1 : 0,\n              bestStreak: enhancedData.totalExperience > 0 ? 1 : 0,\n            },\n          };\n\n          this.cachedData.gamificationData = gamificationData;\n          return gamificationData;\n        }\n      } catch (enhancedError) {\n        // TODO: handle error\n      }\n\n      const facilityId = await this.getCurrentFacilityId();\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { data, error } = await (supabase as any)\n        .from('user_gamification_stats')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (error || !data) {\n        return this.getDefaultGamificationData();\n      }\n\n      const statsData = data as UserGamificationStatsRow;\n      const gamificationData: GamificationStats = {\n        streak: statsData.current_streak ?? 0,\n        level: 1, // Calculate level based on total_points\n        rank: 999, // This would need to be calculated separately\n        totalScore: statsData.total_points ?? 0,\n        stats: {\n          toolsSterilized: 0, // Not available in this table\n          inventoryChecks: 0, // Not available in this table\n          perfectDays: 0, // Not available in this table\n          totalTasks: statsData.total_tasks ?? 0,\n          completedTasks: statsData.completed_tasks ?? 0,\n          currentStreak: statsData.current_streak ?? 0,\n          bestStreak: statsData.best_streak ?? 0,\n        },\n      };\n\n      this.cachedData.gamificationData = gamificationData;\n      return gamificationData;\n    } catch (error) {\n      console.error('Error fetching gamification data:', error);\n      return this.getDefaultGamificationData();\n    }\n  }\n\n  private getDefaultGamificationData(): GamificationStats {\n    return {\n      streak: 0,\n      level: 1,\n      rank: 999,\n      totalScore: 0,\n      stats: {\n        toolsSterilized: 0,\n        inventoryChecks: 0,\n        perfectDays: 0,\n        totalTasks: 0,\n        completedTasks: 0,\n        currentStreak: 0,\n        bestStreak: 0,\n      },\n    };\n  }\n\n  async fetchLeaderboardData(): Promise<LeaderboardData> {\n    if (this.cachedData.leaderboardData) {\n      return this.cachedData.leaderboardData;\n    }\n\n    try {\n      const facilityId = await this.getCurrentFacilityId();\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { data, error } = await (supabase as any)\n        .from('user_gamification_stats')\n        .select('user_id, total_points')\n        .eq('facility_id', facilityId)\n        .order('total_points', { ascending: false })\n        .limit(10);\n\n      if (error || !data) {\n        return this.getDefaultLeaderboardData();\n      }\n\n      const leaderboardData = data as UserLeaderboardRow[];\n      const userIds = leaderboardData.map(\n        (item: UserLeaderboardRow) => item.user_id\n      );\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { data: users, error: usersError } = await (supabase as any)\n        .from('users')\n        .select('id, full_name')\n        .in('id', userIds);\n\n      if (usersError || !users) {\n        return this.getDefaultLeaderboardData();\n      }\n\n      const userData = users as UserRow[];\n      const userMap = new Map(\n        userData.map((user: UserRow) => [user.id, user.full_name ?? ''])\n      );\n\n      const leaderboardDataResult: LeaderboardData = {\n        rank: 999,\n        topUsers: leaderboardData.map((item: UserLeaderboardRow) => ({\n          name: userMap.get(item.user_id) || 'Unknown User',\n          score: item.total_points ?? 0,\n          avatar: (userMap.get(item.user_id) || 'UU')\n            .substring(0, 2)\n            .toUpperCase(),\n        })),\n      };\n\n      this.cachedData.leaderboardData = leaderboardDataResult;\n      return leaderboardDataResult;\n    } catch (error) {\n      console.error('Error fetching leaderboard data:', error);\n      return this.getDefaultLeaderboardData();\n    }\n  }\n\n  private getDefaultLeaderboardData(): LeaderboardData {\n    return { rank: 999, topUsers: [] };\n  }\n\n  async fetchChallengeData(): Promise<ChallengeData> {\n    if (this.cachedData.challengeData) {\n      return this.cachedData.challengeData;\n    }\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { data, error } = await (supabase as any)\n        .from('home_challenges')\n        .select('*')\n        .eq('is_active', true)\n        .order('created_at', { ascending: false })\n        .limit(5);\n\n      if (error || !data) {\n        return this.getDefaultChallengeData();\n      }\n\n      const challengeDataArray = data as ChallengeRow[];\n      const challengeData: ChallengeData = {\n        title: challengeDataArray[0]?.title ?? 'Default Challenge',\n        description:\n          challengeDataArray[0]?.description ?? 'Complete daily tasks',\n        reward: challengeDataArray[0]?.points?.toString() ?? '10',\n        difficulty: challengeDataArray[0]?.difficulty ?? 'easy',\n      };\n\n      this.cachedData.challengeData = challengeData;\n      return challengeData;\n    } catch (error) {\n      console.error('Error fetching challenge data:', error);\n      return this.getDefaultChallengeData();\n    }\n  }\n\n  private getDefaultChallengeData(): ChallengeData {\n    return {\n      title: 'Default Challenge',\n      description: 'Complete daily tasks',\n      reward: '10',\n      difficulty: 'easy',\n    };\n  }\n\n  async fetchMetricsData(): Promise<MetricsData> {\n    if (this.cachedData.metricsData) {\n      return this.cachedData.metricsData;\n    }\n\n    try {\n      const userId = await this.getCurrentUserId();\n      const facilityId = await this.getCurrentFacilityId();\n      if (!userId || !facilityId) {\n        return this.getDefaultMetricsData();\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { data, error } = await (supabase as any)\n        .from('performance_metrics')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('facility_id', facilityId);\n\n      if (error || !data) {\n        return this.getDefaultMetricsData();\n      }\n\n      // Convert key-value pairs to structured data\n      const metricsDataArray = data as MetricsRow[];\n      const metricsMap = new Map(\n        metricsDataArray.map((item: MetricsRow) => [\n          item.metric_name,\n          item.metric_value,\n        ])\n      );\n\n      const metricsData: MetricsData = {\n        timeSaved: {\n          daily: metricsMap.get('time_saved_daily') ?? 0,\n          monthly: metricsMap.get('time_saved_monthly') ?? 0,\n        },\n        costSavings: {\n          monthly: metricsMap.get('cost_savings_monthly') ?? 0,\n          annual: metricsMap.get('cost_savings_annual') ?? 0,\n        },\n        aiEfficiency: {\n          timeSavings: metricsMap.get('ai_time_savings') ?? 0,\n          proactiveMgmt: metricsMap.get('ai_proactive_mgmt') ?? 0,\n        },\n        teamPerformance: {\n          skills: metricsMap.get('team_skills_score') ?? 0,\n          inventory: metricsMap.get('team_inventory_score') ?? 0,\n          sterilization: metricsMap.get('team_sterilization_score') ?? 0,\n        },\n      };\n\n      this.cachedData.metricsData = metricsData;\n      return metricsData;\n    } catch (error) {\n      console.error('Error fetching metrics data:', error);\n      return this.getDefaultMetricsData();\n    }\n  }\n\n  private getDefaultMetricsData(): MetricsData {\n    return {\n      timeSaved: { daily: 0, monthly: 0 },\n      costSavings: { monthly: 0, annual: 0 },\n      aiEfficiency: { timeSavings: 0, proactiveMgmt: 0 },\n      teamPerformance: { skills: 0, inventory: 0, sterilization: 0 },\n    };\n  }\n\n  async fetchAllData(): Promise<GamificationServiceResponse> {\n    const [gamificationData, leaderboardData, challengeData, metricsData] =\n      await Promise.all([\n        this.fetchGamificationData(),\n        this.fetchLeaderboardData(),\n        this.fetchChallengeData(),\n        this.fetchMetricsData(),\n      ]);\n    return { gamificationData, leaderboardData, challengeData, metricsData };\n  }\n\n  clearCache(): void {\n    this.cachedData = {};\n  }\n}\n\nexport const gamificationService = new GamificationServiceImpl();\nexport const createGamificationService = (): GamificationService =>\n  new GamificationServiceImpl();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\homeDataService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\homeIntegrationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\homeSterilizationIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\home\\homeMetricsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\initialization\\SystemInitializer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryCacheService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryErrorHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryFilterService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryLoadingManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryServiceFacade.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 71,
        "column": 12,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 72,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [2596, 2601], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  InventoryServiceFacade,\n  InventoryCategoryService,\n  InventoryFilterService,\n  InventoryStatusService,\n  InventoryItem,\n  LocalInventoryItem,\n  InventoryResponse,\n  InventoryDataResponse,\n  OperationResult,\n  SearchOptions,\n  FilterOptions,\n  PaginationOptions,\n  SortOptions,\n  AdapterType,\n  AdapterMetadata,\n  CacheStats,\n  InventoryUpdateResponse,\n  InventoryDeleteResponse,\n  InventoryCreateResponse,\n  InventorySingleResponse,\n  InventoryFilters,\n  InventoryBulkResponse,\n  InventoryCacheManager,\n  InventoryRepository,\n  InventoryAdapterManager,\n} from './facade';\nimport { cacheInvalidationService } from '../cache/cacheInvalidationCompatibility';\nimport { trackEvent as trackAnalyticsEvent } from '../analytics';\nimport { inventorySupabaseService } from './services/inventorySupabaseService';\nimport { getItemStatus } from '../../types/inventoryTypes';\nimport { performanceMonitor } from '../monitoring/PerformanceMonitor';\n\n// ============================================================================\n// SERVICE FACADE INTERFACE\n// ============================================================================\n\n// The InventoryServiceFacade type is already imported from the facade module\n\n// ============================================================================\n// BUSINESS LOGIC SERVICES\n// ============================================================================\n\n// Export the business logic services from the facade modules\nexport {\n  InventoryCategoryService,\n  InventoryFilterService,\n  InventoryStatusService,\n};\n\n// ============================================================================\n// MAIN FACADE IMPLEMENTATION\n// ============================================================================\n\nexport class InventoryServiceFacadeImpl implements InventoryServiceFacade {\n  // Use the new facade modules\n  private readonly cacheManager = new InventoryCacheManager();\n  private readonly repository = new InventoryRepository();\n  private readonly adapterManager = new InventoryAdapterManager();\n  private isInitialized = false;\n  private initializationPromise: Promise<void> | null = null;\n\n  // Static instance for true singleton behavior\n  private static instance: InventoryServiceFacadeImpl | null = null;\n\n  private constructor() {\n    // Private constructor to enforce singleton pattern\n    // Register with centralized cache invalidation service only if not already registered\n    if (!cacheInvalidationService.isRegistered('inventory_service')) {\n      cacheInvalidationService.registerCacheManager('inventory_service', this);\n    } else {\n    }\n  }\n\n  // Static getInstance method for true singleton\n  static getInstance(): InventoryServiceFacadeImpl {\n    if (!InventoryServiceFacadeImpl.instance) {\n      InventoryServiceFacadeImpl.instance = new InventoryServiceFacadeImpl();\n    }\n    return InventoryServiceFacadeImpl.instance;\n  }\n\n  // Debug method to check instance identity\n  getInstanceId(): string {\n    return `instance_${this === InventoryServiceFacadeImpl.instance ? 'SINGLETON' : 'NEW'}`;\n  }\n\n  // Business logic services\n  public readonly categoryService = new InventoryCategoryService();\n  public readonly filterService = new InventoryFilterService();\n  public readonly statusService = new InventoryStatusService();\n\n  // Error handling - using static methods\n  // private errorHandler: InventoryErrorHandler;\n\n  async initialize(): Promise<void> {\n    const startTime = performance.now();\n\n    if (this.isInitialized) {\n      return; // Already initialized, prevent multiple initializations\n    }\n\n    // If initialization is already in progress, wait for it to complete\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n      return;\n    }\n\n    // Create the initialization promise\n    this.initializationPromise = (async () => {\n      try {\n        await this.adapterManager.initialize();\n        await this.repository.initialize(\n          this.adapterManager.getAdapter(),\n          this.adapterManager.getCurrentAdapterType()\n        );\n        this.isInitialized = true;\n\n        const duration = performance.now() - startTime;\n        performanceMonitor.recordResponseTime(\n          'inventory_service_initialization',\n          duration,\n          {\n            service: 'InventoryServiceFacade',\n            operation: 'initialize',\n          }\n        );\n      } finally {\n        // Clear the promise reference\n        this.initializationPromise = null;\n      }\n    })();\n\n    await this.initializationPromise;\n  }\n\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  async fetchInventoryItems(): Promise<LocalInventoryItem[]> {\n    return await this.repository.fetchInventoryItems();\n  }\n\n  async fetchAllInventoryData(): Promise<InventoryDataResponse> {\n    const startTime = performance.now();\n\n    // Check cache first\n    const cachedData = this.cacheManager.get();\n    if (cachedData) {\n      return cachedData;\n    }\n\n    if (!this.repository.isInitialized) {\n      console.warn(\n        `[InventoryServiceFacade] Repository not initialized (facade.isInitialized: ${this.isInitialized}) ‚Äî auto-initializing now.`\n      );\n      await this.initialize();\n    }\n\n    const result = await this.repository.fetchAllInventoryData();\n    const duration = performance.now() - startTime;\n\n    performanceMonitor.recordDataFetch(\n      'fetchAllInventoryData',\n      duration,\n      !result.error,\n      {\n        service: 'InventoryServiceFacade',\n        operation: 'fetchAllInventoryData',\n        toolsCount: String(result.tools?.length || 0),\n        suppliesCount: String(result.supplies?.length || 0),\n        equipmentCount: String(result.equipment?.length || 0),\n        officeHardwareCount: String(result.officeHardware?.length || 0),\n      }\n    );\n\n    // Update cache\n    this.cacheManager.set(result);\n\n    return result;\n  }\n\n  // Implement required interface methods\n  async getAllItems() // filters parameter removed as it's not used\n  // options parameter removed as it's not used\n  : Promise<InventoryResponse> {\n    if (!this.repository.isInitialized) {\n      console.warn(\n        `[InventoryServiceFacade] Repository not initialized (facade.isInitialized: ${this.isInitialized}) ‚Äî auto-initializing now.`\n      );\n      await this.initialize();\n    }\n    const data = await this.fetchAllInventoryData();\n    return {\n      data: [\n        ...data.tools,\n        ...data.supplies,\n        ...data.equipment,\n        ...data.officeHardware,\n      ],\n      error: data.error,\n    };\n  }\n\n  async getItemById(id: string): Promise<InventorySingleResponse> {\n    return await this.repository.getItemById(id);\n  }\n\n  async createItem(\n    item: Omit<InventoryItem, 'id' | 'lastUpdated'>\n    // options parameter removed as it's not used\n  ): Promise<InventoryCreateResponse> {\n    return await this.repository.createItem(item);\n  }\n\n  async updateItem(\n    id: string,\n    updates: Partial<InventoryItem>\n    // options parameter removed as it's not used\n  ): Promise<InventoryUpdateResponse> {\n    return await this.repository.updateItem(id, updates);\n  }\n\n  async deleteItem(id: string): Promise<InventoryDeleteResponse> {\n    return await this.repository.deleteItem(id);\n  }\n\n  async addInventoryItem(item: LocalInventoryItem): Promise<InventoryItem> {\n    return await this.repository.addInventoryItem(item);\n  }\n\n  async addCategory(\n    category: string\n  ): Promise<{ success: boolean; error: string | null }> {\n    return await this.repository.addCategory(category);\n  }\n\n  async deleteCategory(\n    category: string\n  ): Promise<{ success: boolean; error: string | null }> {\n    return await this.repository.deleteCategory(category);\n  }\n\n  async bulkCreateItems(\n    items: Omit<InventoryItem, 'id' | 'lastUpdated'>[]\n  ): Promise<InventoryBulkResponse> {\n    return await this.repository.bulkCreateItems(items);\n  }\n\n  async bulkUpdateItems(\n    updates: Array<{ id: string; updates: Partial<InventoryItem> }>\n  ): Promise<InventoryBulkResponse> {\n    return await this.repository.bulkUpdateItems(updates);\n  }\n\n  async bulkDeleteItems(ids: string[]): Promise<InventoryBulkResponse> {\n    return await this.repository.bulkDeleteItems(ids);\n  }\n\n  async searchItems(query: string): Promise<InventoryResponse> {\n    return await this.repository.searchItems(query);\n  }\n\n  async getFilteredItems(\n    filters: InventoryFilters\n    // options parameter removed as it's not used\n  ): Promise<InventoryResponse> {\n    return await this.repository.getFilteredItems(filters);\n  }\n\n  async getCategories(): Promise<{ data: string[]; error: string | null }> {\n    return await this.repository.getCategories();\n  }\n\n  async getLocations(): Promise<{ data: string[]; error: string | null }> {\n    return await this.repository.getLocations();\n  }\n\n  async getInventoryStats(): Promise<{\n    data: Record<string, unknown> | null;\n    error: string | null;\n  }> {\n    return await this.repository.getInventoryStats();\n  }\n\n  async refresh(): Promise<{ success: boolean; error: string | null }> {\n    try {\n      await this.refreshData();\n      return { success: true, error: null };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async validateItem(\n    item: Partial<InventoryItem>\n  ): Promise<{ isValid: boolean; errors: string[] }> {\n    const errors: string[] = [];\n\n    if (!item.name) {\n      errors.push('Item name is required');\n    }\n\n    if (!item.category) {\n      errors.push('Category is required');\n    }\n\n    if (!item.location) {\n      errors.push('Location is required');\n    }\n\n    if (\n      item.quantity !== undefined &&\n      item.quantity !== null &&\n      item.quantity < 0\n    ) {\n      errors.push('Quantity cannot be negative');\n    }\n\n    if (\n      item.unit_cost !== undefined &&\n      item.unit_cost !== null &&\n      item.unit_cost < 0\n    ) {\n      errors.push('Cost cannot be negative');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n    };\n  }\n\n  async getItemHistory(): Promise<Record<string, unknown>[]> {\n    // This would typically fetch from an audit log or history table\n    // For now, return empty array as placeholder\n    return [];\n  }\n\n  subscribeToChanges(): () => void {\n    try {\n      // Use the working inventorySupabaseService for real-time updates\n      return inventorySupabaseService.subscribeToChanges((payload: unknown) => {\n        // Clear cache when inventory changes\n        this.clearCache();\n\n        // Track the real-time update event\n        trackAnalyticsEvent('inventory_realtime_update', {\n          source: 'facade',\n          payload_type: typeof payload,\n          adapter_type: this.adapterManager.getCurrentAdapterType(),\n        });\n      });\n    } catch (error) {\n      console.error(\n        '‚ùå Failed to set up real-time subscription in InventoryServiceFacade:',\n        error\n      );\n      // Return no-op unsubscribe function as fallback\n      return () => {};\n    }\n  }\n\n  async updateInventoryItem(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    const result = await this.updateItem(id, updates);\n    if (!result.data) {\n      throw new Error('Failed to update inventory item');\n    }\n    return result.data;\n  }\n\n  async deleteInventoryItem(id: string): Promise<void> {\n    await this.deleteItem(id);\n  }\n\n  getFilteredData(\n    data: LocalInventoryItem[],\n    searchOptions: SearchOptions,\n    filters?: FilterOptions,\n    pagination?: PaginationOptions,\n    sorting?: SortOptions\n  ): LocalInventoryItem[] {\n    let filteredData = data;\n\n    // Search filtering\n    if (searchOptions.query.trim()) {\n      const query = searchOptions.caseSensitive\n        ? searchOptions.query\n        : searchOptions.query.toLowerCase();\n\n      const searchableFields = searchOptions.fields || [\n        'name',\n        'category',\n        'location',\n        'description',\n      ];\n\n      filteredData = filteredData.filter((item) => {\n        return searchableFields.some((field: string) => {\n          const value = (item as unknown as Record<string, unknown>)[field];\n          if (!value) return false;\n\n          const fieldValue = searchOptions.caseSensitive\n            ? value.toString()\n            : value.toString().toLowerCase();\n\n          return fieldValue.includes(query);\n        });\n      });\n    }\n\n    // Additional filters\n    if (filters) {\n      filteredData = filteredData.filter((item) => {\n        // Apply filters\n        if (filters.category && item.category !== filters.category)\n          return false;\n        if (filters.status && item.status !== filters.status) return false;\n        if (filters.location && item.location !== filters.location)\n          return false;\n        if (\n          (filters as { minQuantity?: number }).minQuantity !== undefined &&\n          (item.quantity || 0) <\n            (filters as { minQuantity: number }).minQuantity\n        )\n          return false;\n        if (\n          (filters as { maxQuantity?: number }).maxQuantity !== undefined &&\n          (item.quantity || 0) >\n            (filters as { maxQuantity: number }).maxQuantity\n        )\n          return false;\n        if (\n          filters.isActive !== undefined &&\n          item.data?.isActive !== filters.isActive\n        )\n          return false;\n        // Note: tracked and favorite properties are not available in FilterOptions interface\n        // These filters are handled at a higher level in the UI\n        return true;\n      });\n    }\n\n    // Sorting\n    if (sorting) {\n      filteredData.sort((a, b) => {\n        const aValue = a[sorting.field as keyof LocalInventoryItem];\n        const bValue = b[sorting.field as keyof LocalInventoryItem];\n\n        if (sorting.direction === 'asc') {\n          return String(aValue) < String(bValue)\n            ? -1\n            : String(aValue) > String(bValue)\n              ? 1\n              : 0;\n        } else {\n          return String(aValue) > String(bValue)\n            ? -1\n            : String(aValue) < String(bValue)\n              ? 1\n              : 0;\n        }\n      });\n    }\n\n    // Apply pagination\n    if (pagination) {\n      const startIndex = (pagination.page - 1) * pagination.limit;\n      const endIndex = startIndex + pagination.limit;\n      filteredData = filteredData.slice(startIndex, endIndex);\n    }\n\n    return filteredData;\n  }\n\n  clearCache(): void {\n    this.cacheManager.clear();\n  }\n\n  async refreshData(): Promise<InventoryResponse> {\n    this.clearCache();\n    const data = await this.fetchAllInventoryData();\n    return {\n      data: [\n        ...data.tools,\n        ...data.supplies,\n        ...data.equipment,\n        ...data.officeHardware,\n      ],\n      error: data.error,\n    };\n  }\n\n  getCurrentAdapterType(): AdapterType {\n    return this.adapterManager.getCurrentAdapterType() as AdapterType;\n  }\n\n  getAdapterMetadata(): AdapterMetadata {\n    return this.adapterManager.getAdapterMetadata() as AdapterMetadata;\n  }\n\n  getAvailableAdapters(): AdapterType[] {\n    return this.adapterManager.getAvailableAdapters() as AdapterType[];\n  }\n\n  getCacheStats(): CacheStats {\n    return this.cacheManager.getStats();\n  }\n\n  /**\n   * Get error statistics from the error handler\n   */\n  getErrorStats(): Record<string, unknown> {\n    return {\n      totalErrors: 0,\n      lastError: null,\n      errorRate: 0,\n    };\n  }\n\n  async switchAdapter(type: AdapterType): Promise<OperationResult> {\n    try {\n      await this.initialize();\n      return { success: true, data: type };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  private getItemId(item: LocalInventoryItem): string {\n    return (\n      item.id ||\n      (item.data?.barcode && typeof item.data.barcode === 'string'\n        ? item.data.barcode\n        : '') ||\n      ''\n    );\n  }\n\n  private getItemStatus(item: LocalInventoryItem): string {\n    return getItemStatus(item) || 'Unknown';\n  }\n}\n\n// ============================================================================\n// SINGLETON INSTANCE\n// ============================================================================\n\n// Create singleton instance using static getInstance method\nexport const inventoryServiceFacade = InventoryServiceFacadeImpl.getInstance();\n\n// Export the class for backward compatibility\nexport { InventoryServiceFacadeImpl as InventoryServiceFacade };\n\n// Note: Individual services are now accessed through the main facade\n// to prevent multiple instances and improve performance\n\n// Export types for backward compatibility\nexport type {\n  InventoryResponse,\n  FilterOptions,\n  SearchOptions,\n  PaginationOptions,\n  SortOptions,\n  OperationResult,\n  DeleteItemOptions,\n  CacheStats,\n  AdapterType,\n  AdapterMetadata,\n  InventoryErrorCode,\n} from '../../types/inventoryServiceTypes';\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryServiceFactory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventorySortService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventoryStateManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\InventorySyncService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token. A constructor, method, accessor, or property was expected.",
        "line": 75,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { InventoryResponse } from './InventoryServiceFacade';\n\nexport interface SyncOperation {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  entity: 'item' | 'category';\n  data: unknown;\n  timestamp: number;\n  retryCount: number;\n  maxRetries: number;\n}\n\nexport interface SyncStatus {\n  isOnline: boolean;\n  lastSyncTime: number | null;\n  pendingOperations: number;\n  syncInProgress: boolean;\n  error: string | null;\n}\n\nexport interface InventorySyncService {\n  // Core sync operations\n  sync(): Promise<void>;\n  queueOperation(\n    operation: Omit<SyncOperation, 'id' | 'timestamp' | 'retryCount'>\n  ): void;\n  processPendingOperations(): Promise<void>;\n\n  // Status and monitoring\n  getSyncStatus(): SyncStatus;\n  isOnline(): boolean;\n  setOnlineStatus(isOnline: boolean): void;\n\n  // Data synchronization\n  syncInventoryData(data: InventoryResponse): Promise<void>;\n  syncInventoryItem(item: unknown): Promise<void>;\n  syncCategory(category: string): Promise<void>;\n\n  // Conflict resolution\n  resolveConflicts(localData: unknown, remoteData: unknown): unknown;\n  mergeData(localData: unknown[], remoteData: unknown[]): unknown[];\n\n  // Cleanup\n  clearPendingOperations(): void;\n  getPendingOperations(): SyncOperation[];\n}\n\nexport class InventorySyncServiceImpl implements InventorySyncService {\n  private pendingOperations: SyncOperation[] = [];\n  private syncStatus: SyncStatus = {\n    isOnline: navigator.onLine,\n    lastSyncTime: null,\n    pendingOperations: 0,\n    syncInProgress: false,\n    error: null,\n  };\n\n  constructor() {\n    this.setupOnlineStatusListeners();\n  }\n\n  async sync(): Promise<void> {\n    if (!this.isOnline() || this.syncStatus.syncInProgress) {\n      return;\n    }\n\n    this.syncStatus.syncInProgress = true;\n\n    try {\n      await this.processPendingOperations();\n      this.syncStatus.lastSyncTime = Date.now();\n    } catch (err) { console.error(err); throw err; }\n      this.syncStatus.error = 'Sync failed';\n      throw new Error('Sync failed');\n    } finally {\n      this.syncStatus.syncInProgress = false;\n    }\n  }\n\n  queueOperation(\n    operation: Omit<SyncOperation, 'id' | 'timestamp' | 'retryCount'>\n  ): void {\n    const syncOperation: SyncOperation = {\n      ...operation,\n      id: this.generateOperationId(),\n      timestamp: Date.now(),\n      retryCount: 0,\n    };\n\n    this.pendingOperations.push(syncOperation);\n    this.updatePendingOperationsCount();\n  }\n\n  async processPendingOperations(): Promise<void> {\n    const operationsToProcess = [...this.pendingOperations];\n\n    // Process operations concurrently for better performance\n    const operationPromises = operationsToProcess.map(async (operation) => {\n      try {\n        await this.processOperation(operation);\n        this.removeOperation(operation.id);\n        return { success: true, operationId: operation.id };\n      } catch (error) {\n        operation.retryCount++;\n        if (operation.retryCount >= operation.maxRetries) {\n          this.removeOperation(operation.id);\n          console.error(\n            `Operation failed after ${operation.maxRetries} retries:`,\n            operation\n          );\n        }\n        return { success: false, operationId: operation.id, error };\n      }\n    });\n\n    const results = await Promise.allSettled(operationPromises);\n\n    // Log any failures for debugging\n    const failures = results\n      .map((result, index) =>\n        result.status === 'rejected' ? operationsToProcess[index]?.id : null\n      )\n      .filter(Boolean);\n\n    if (failures.length > 0) {\n      console.warn(\n        `Sync: ${failures.length} operations failed to process:`,\n        failures\n      );\n    }\n  }\n\n  getSyncStatus(): SyncStatus {\n    return { ...this.syncStatus };\n  }\n\n  isOnline(): boolean {\n    return this.syncStatus.isOnline;\n  }\n\n  setOnlineStatus(isOnline: boolean): void {\n    this.syncStatus.isOnline = isOnline;\n    if (isOnline && this.pendingOperations.length > 0) {\n      this.sync().catch(console.error);\n    }\n  }\n\n  async syncInventoryData(data: InventoryResponse): Promise<void> {\n    // Implementation would depend on the backend API\n    // For now, just simulate sync\n    await new Promise((resolve) => setTimeout(resolve, 100));\n  }\n\n  async syncInventoryItem(item: unknown): Promise<void> {\n    // Implementation would depend on the backend API\n    await new Promise((resolve) => setTimeout(resolve, 50));\n  }\n\n  async syncCategory(category: string): Promise<void> {\n    // Implementation would depend on the backend API\n    await new Promise((resolve) => setTimeout(resolve, 50));\n  }\n\n  resolveConflicts(localData: unknown, remoteData: unknown): unknown {\n    // Simple conflict resolution: prefer remote data if it's newer\n    const local = localData as { updatedAt?: number };\n    const remote = remoteData as { updatedAt?: number };\n\n    if (remote.updatedAt && local.updatedAt) {\n      return remote.updatedAt > local.updatedAt ? remoteData : localData;\n    }\n    return remoteData;\n  }\n\n  mergeData(localData: unknown[], remoteData: unknown[]): unknown[] {\n    const merged = new Map();\n\n    // Add local data\n    localData.forEach((item) => {\n      const itemWithId = item as { id: string };\n      merged.set(itemWithId.id, item);\n    });\n\n    // Merge with remote data, resolving conflicts\n    remoteData.forEach((item) => {\n      const itemWithId = item as { id: string };\n      const existing = merged.get(itemWithId.id);\n      if (existing) {\n        merged.set(itemWithId.id, this.resolveConflicts(existing, item));\n      } else {\n        merged.set(itemWithId.id, item);\n      }\n    });\n\n    return Array.from(merged.values());\n  }\n\n  clearPendingOperations(): void {\n    this.pendingOperations = [];\n    this.updatePendingOperationsCount();\n  }\n\n  getPendingOperations(): SyncOperation[] {\n    return [...this.pendingOperations];\n  }\n\n  private async processOperation(operation: SyncOperation): Promise<void> {\n    switch (operation.type) {\n      case 'create':\n        if (operation.entity === 'item') {\n          await this.syncInventoryItem(operation.data);\n        } else if (operation.entity === 'category') {\n          await this.syncCategory(operation.data as string);\n        }\n        break;\n      case 'update':\n        if (operation.entity === 'item') {\n          await this.syncInventoryItem(operation.data);\n        }\n        break;\n      case 'delete':\n        // Handle delete operations\n        break;\n      default:\n        throw new Error(`Unknown operation type: ${operation.type}`);\n    }\n  }\n\n  private removeOperation(operationId: string): void {\n    this.pendingOperations = this.pendingOperations.filter(\n      (op) => op.id !== operationId\n    );\n    this.updatePendingOperationsCount();\n  }\n\n  private updatePendingOperationsCount(): void {\n    this.syncStatus.pendingOperations = this.pendingOperations.length;\n  }\n\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private setupOnlineStatusListeners(): void {\n    window.addEventListener('online', () => this.setOnlineStatus(true));\n    window.addEventListener('offline', () => this.setOnlineStatus(false));\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\UnifiedInventoryDataService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\ApiAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\InventoryAdapterFactory.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ';' expected.",
        "line": 174,
        "column": 24,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { DataSourceConfig, InventoryDataAdapter } from './InventoryDataAdapter';\nimport { getSupabaseAdapter } from './SupabaseAdapterLoader';\n\nimport { LocalStorageAdapter } from './LocalStorageAdapter';\n\nexport interface AdapterFactoryConfig {\n  defaultAdapter: 'localStorage' | 'api' | 'supabase';\n  adapters: {\n    localStorage?: DataSourceConfig;\n    api?: DataSourceConfig;\n    supabase?: DataSourceConfig;\n  };\n  fallbackAdapter?: 'localStorage' | 'supabase';\n}\n\nexport interface AdapterRegistry {\n  [key: string]: InventoryDataAdapter;\n}\n\nexport interface InventoryAdapterFactory {\n  // Factory methods\n  createAdapter(\n    type: string,\n    config?: DataSourceConfig\n  ): Promise<InventoryDataAdapter>;\n  getAdapter(type: string): InventoryDataAdapter | null;\n  registerAdapter(type: string, adapter: InventoryDataAdapter): void;\n  unregisterAdapter(type: string): void;\n\n  // Adapter management\n  initializeDefaultAdapter(): Promise<InventoryDataAdapter>;\n  getAvailableAdapters(): string[];\n  getAdapterMetadata(type: string): unknown;\n\n  // Configuration\n  updateConfig(config: Partial<AdapterFactoryConfig>): void;\n  getConfig(): AdapterFactoryConfig;\n}\n\nexport class InventoryAdapterFactoryImpl implements InventoryAdapterFactory {\n  private config: AdapterFactoryConfig;\n  private registry: AdapterRegistry = {};\n  private defaultAdapter: InventoryDataAdapter | null = null;\n\n  constructor(config: AdapterFactoryConfig) {\n    this.config = {\n      defaultAdapter: config.defaultAdapter || 'localStorage',\n      adapters: { ...config.adapters },\n      fallbackAdapter: config.fallbackAdapter || 'supabase',\n    };\n  }\n\n  async createAdapter(\n    type: string,\n    config?: DataSourceConfig\n  ): Promise<InventoryDataAdapter> {\n    // Check if adapter already exists in registry\n    if (this.registry[type]) {\n      return this.registry[type];\n    }\n\n    let adapter: InventoryDataAdapter;\n\n    switch (type) {\n      case 'static': {\n        const { StaticDataAdapter } = await import('./StaticDataAdapter');\n        adapter = new StaticDataAdapter(config || { type: 'static' });\n        break;\n      }\n      case 'localStorage': {\n        adapter = new LocalStorageAdapter(\n          config || this.config.adapters.localStorage\n        );\n        break;\n      }\n      case 'api': {\n        const { ApiAdapter, isApiAdapterConfig } = await import('./ApiAdapter');\n        const apiConfig = config || this.config.adapters.api;\n        if (!apiConfig) {\n          throw new Error('API adapter configuration is required');\n        }\n        if (!isApiAdapterConfig(apiConfig)) {\n          throw new Error('API adapter requires baseUrl configuration');\n        }\n        adapter = new ApiAdapter(apiConfig);\n        break;\n      }\n      case 'supabase': {\n        const { SupabaseAdapter } = await getSupabaseAdapter();\n        const supabaseConfig = config || this.config.adapters.supabase;\n        if (!supabaseConfig) {\n          throw new Error('Supabase adapter configuration is required');\n        }\n        adapter = new SupabaseAdapter(supabaseConfig);\n        break;\n      }\n      default:\n        throw new Error(`Unknown adapter type: ${type}`);\n    }\n\n    // Initialize the adapter\n    await adapter.initialize();\n\n    // Register the adapter\n    this.registerAdapter(type, adapter);\n\n    return adapter;\n  }\n\n  getAdapter(type: string): InventoryDataAdapter | null {\n    return this.registry[type] || null;\n  }\n\n  registerAdapter(type: string, adapter: InventoryDataAdapter): void {\n    this.registry[type] = adapter;\n\n    // Set as default if it's the configured default adapter\n    if (type === this.config.defaultAdapter) {\n      this.defaultAdapter = adapter;\n    }\n  }\n\n  unregisterAdapter(type: string): void {\n    const adapter = this.registry[type];\n    if (adapter) {\n      adapter.disconnect().catch(console.error);\n      delete this.registry[type];\n\n      // Clear default adapter if it was this one\n      if (this.defaultAdapter === adapter) {\n        this.defaultAdapter = null;\n      }\n    }\n  }\n\n  async initializeDefaultAdapter(): Promise<InventoryDataAdapter> {\n    if (this.defaultAdapter) {\n      return this.defaultAdapter;\n    }\n\n    try {\n      const adapter = await this.createAdapter(this.config.defaultAdapter);\n      this.defaultAdapter = adapter;\n      return adapter;\n    } catch (err) { console.error(err); throw err; }\n      console.error(\n        `Failed to initialize default adapter (${this.config.defaultAdapter}):`\n      );\n\n      // Try fallback adapter\n      if (\n        this.config.fallbackAdapter &&\n        this.config.fallbackAdapter !== this.config.defaultAdapter\n      ) {\n        try {\n          const fallbackAdapter = await this.createAdapter(\n            this.config.fallbackAdapter\n          );\n          this.defaultAdapter = fallbackAdapter;\n          return fallbackAdapter;\n        } catch (fallbackError) {\n          console.error(\n            `Failed to initialize fallback adapter (${this.config.fallbackAdapter}):`,\n            fallbackError\n          );\n          throw new Error('No available adapters could be initialized');\n        }\n      }\n\n      throw new Error('No available adapters could be initialized');\n    }\n  }\n\n  getAvailableAdapters(): string[] {\n    return Object.keys(this.registry);\n  }\n\n  getAdapterMetadata(type: string): unknown {\n    const adapter = this.registry[type];\n    return adapter ? adapter.getMetadata() : null;\n  }\n\n  updateConfig(config: Partial<AdapterFactoryConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  getConfig(): AdapterFactoryConfig {\n    return { ...this.config };\n  }\n\n  // Utility methods for adapter switching\n  async switchDefaultAdapter(type: string): Promise<InventoryDataAdapter> {\n    // Validate adapter type\n    if (!['localStorage', 'api', 'supabase'].includes(type)) {\n      throw new Error(`Invalid adapter type: ${type}`);\n    }\n\n    // Update config\n    this.config.defaultAdapter = type as 'localStorage' | 'api' | 'supabase';\n\n    // Clear current default\n    this.defaultAdapter = null;\n\n    // Initialize new default\n    return this.initializeDefaultAdapter();\n  }\n\n  async getBestAvailableAdapter(): Promise<InventoryDataAdapter> {\n    // Try to get the default adapter\n    try {\n      return await this.initializeDefaultAdapter();\n    } catch (err) { console.error(err); throw err; }\n      // If default fails, try to find any available adapter\n      const availableTypes = ['supabase', 'localStorage'];\n\n      for (const type of availableTypes) {\n        try {\n          const adapter = await this.createAdapter(type);\n          return adapter;\n        } catch (adapterError) {\n          console.warn(`Failed to create adapter ${type}:`, adapterError);\n          continue;\n        }\n      }\n\n      throw new Error('No adapters are available');\n    }\n  }\n\n  // Cleanup method\n  async cleanup(): Promise<void> {\n    const cleanupPromises = Object.values(this.registry).map((adapter) =>\n      adapter.disconnect().catch(console.error)\n    );\n\n    await Promise.all(cleanupPromises);\n    this.registry = {};\n    this.defaultAdapter = null;\n  }\n}\n\n// Default factory instance\nexport const inventoryAdapterFactory = new InventoryAdapterFactoryImpl({\n  defaultAdapter: 'supabase',\n  adapters: {\n    supabase: { type: 'supabase' },\n    localStorage: { type: 'localStorage' },\n  },\n  fallbackAdapter: 'localStorage',\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\InventoryDataAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\LocalStorageAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\StaticDataAdapter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'id' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 102,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 102,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'category' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 122,
        "column": 24,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 122,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { InventoryItem } from '../../../types/inventoryTypes';\nimport { InventoryResponse } from '../InventoryServiceFacade';\nimport {\n  BaseInventoryDataAdapter,\n  DataSourceConfig,\n  AdapterCapabilities,\n} from './InventoryDataAdapter';\nimport { isDevelopment, isBrowser } from '../../../lib/getEnv';\n\nexport class StaticDataAdapter extends BaseInventoryDataAdapter {\n  constructor(config: DataSourceConfig = { type: 'static' }) {\n    const capabilities: AdapterCapabilities = {\n      supportsRead: isDevelopment() || !isBrowser(),\n      supportsWrite: isDevelopment() || !isBrowser(),\n      supportsDelete: isDevelopment() || !isBrowser(),\n      supportsRealTime: false,\n      supportsOffline: isDevelopment() || !isBrowser(),\n      supportsBatch: false,\n    };\n\n    super(config, {\n      name: 'StaticDataAdapter',\n      version: '1.0.0',\n      description:\n        'Static data adapter for development or when Supabase is not configured',\n      capabilities,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    // Allow static adapter in development mode or when not in browser\n    if (isDevelopment() || !isBrowser()) {\n      return;\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  isConnected(): boolean {\n    return isDevelopment() || !isBrowser();\n  }\n\n  async fetchAllInventoryData(): Promise<InventoryResponse> {\n    if (isDevelopment() || !isBrowser()) {\n      return {\n        data: this.getMockInventoryItems(),\n        error: null,\n        count: this.getMockInventoryItems().length,\n      };\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async fetchInventoryItems(): Promise<InventoryItem[]> {\n    if (isDevelopment() || !isBrowser()) {\n      return this.getMockInventoryItems();\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async fetchCategories(): Promise<string[]> {\n    if (isDevelopment() || !isBrowser()) {\n      return this.getMockCategories();\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async addInventoryItem(item: InventoryItem): Promise<InventoryItem> {\n    if (isDevelopment() || !isBrowser()) {\n      return { ...item, id: `mock-${Date.now()}` };\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async updateInventoryItem(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    if (isDevelopment() || !isBrowser()) {\n      return { id, name: 'Mock Item', ...updates } as InventoryItem;\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async deleteInventoryItem(id: string): Promise<void> {\n    if (isDevelopment() || !isBrowser()) {\n      return;\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async addCategory(category: string): Promise<string> {\n    if (isDevelopment() || !isBrowser()) {\n      return category;\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  async deleteCategory(category: string): Promise<void> {\n    if (isDevelopment() || !isBrowser()) {\n      return;\n    }\n\n    throw new Error(\n      'Static data adapter is disabled. This project should not use mock data. Please configure Supabase instead.'\n    );\n  }\n\n  // Mock data methods for development\n  private getMockInventoryItems(): InventoryItem[] {\n    return [\n      {\n        id: 'mock-1',\n        facility_id: 'mock-facility',\n        name: 'Surgical Scissors',\n        category: 'Surgical Instruments',\n        location: 'Operating Room 1',\n        status: 'Available',\n        quantity: 5,\n        unit_cost: 150.0,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        reorder_point: 2,\n        expiration_date: null,\n        data: {\n          lastUpdated: new Date().toISOString(),\n        },\n      },\n      {\n        id: 'mock-2',\n        facility_id: 'mock-facility',\n        name: 'Stethoscope',\n        category: 'Diagnostic Equipment',\n        location: 'Exam Room 2',\n        status: 'Available',\n        quantity: 3,\n        unit_cost: 75.0,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        reorder_point: 1,\n        expiration_date: null,\n        data: {\n          lastUpdated: new Date().toISOString(),\n        },\n      },\n      {\n        id: 'mock-3',\n        facility_id: 'mock-facility',\n        name: 'Blood Pressure Cuff',\n        category: 'Diagnostic Equipment',\n        location: 'Exam Room 1',\n        status: 'In Use',\n        quantity: 2,\n        unit_cost: 45.0,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        reorder_point: 1,\n        expiration_date: null,\n        data: {\n          lastUpdated: new Date().toISOString(),\n        },\n      },\n    ];\n  }\n\n  private getMockCategories(): string[] {\n    return [\n      'Surgical Instruments',\n      'Diagnostic Equipment',\n      'Medical Supplies',\n      'Office Equipment',\n      'Emergency Equipment',\n    ];\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\SupabaseAdapter.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 61,
        "column": 16,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 62,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [2488, 2497], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 93,
        "column": 14,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 94,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [3373, 3380], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'category' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 309,
        "column": 24,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 309,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  InventoryDataAdapter,\n  DataSourceConfig,\n  AdapterMetadata,\n} from './InventoryDataAdapter';\nimport { InventoryItem } from '../../../types/inventoryTypes';\nimport { InventoryResponse } from '../types/inventoryServiceTypes';\nimport { isSupabaseConfigured } from '../../../lib/supabase';\nimport { InventoryDataTransformer } from '../utils/inventoryTransformers';\nimport { InventoryCrudOperations } from '../utils/inventoryCrudOperations';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { supabase } from '@/lib/supabase';\nimport { TypedSupabaseAdapter } from './TypedSupabaseAdapter';\nimport { RealtimeInventoryPayload } from '../types/supabaseTypes';\n\n// === 1) ADD THESE HELPERS NEAR THE TOP OF THE FILE (module scope) ===\n\nexport class SupabaseAdapter implements InventoryDataAdapter {\n  private config: DataSourceConfig;\n  private isInitialized = false;\n  private lastError: Error | null = null;\n  private lastSyncTime: Date | null = null;\n  private pendingChanges = false;\n  private cachedItems: unknown[] | null = null;\n  private cacheTimestamp: number = 0;\n  private readonly CACHE_DURATION = 5000; // 5 seconds cache\n  private typedAdapter: TypedSupabaseAdapter;\n\n  constructor(config: DataSourceConfig) {\n    this.config = config;\n    this.typedAdapter = new TypedSupabaseAdapter();\n  }\n\n  // Make sure the class has these fields (ADD if missing):\n  private client: SupabaseClient | null = null;\n  private initPromise: Promise<SupabaseClient> | null = null;\n\n  // ADD (or REPLACE existing init logic) this private helper to guarantee a client:\n  private getClient = async (): Promise<SupabaseClient> => {\n    if (this.client) return this.client;\n    if (!this.initPromise) {\n      // Kick off one-time init\n      this.initPromise = (async () => {\n        // Ensure we construct the client here and keep a reference\n        // const url = import.meta.env.VITE_SUPABASE_URL!;\n        // const key = import.meta.env.VITE_SUPABASE_ANON_KEY!;\n        // Use centralized supabase client\n        const client = supabase;\n\n        // Lightweight probe to ensure `from` exists and auth/cors are sane\n        const { error } = await client\n          .from('inventory_items')\n          .select('id')\n          .limit(1);\n        if (error) {\n          console.warn(\n            'SupabaseAdapter.ts:test ‚ùå Probe failed',\n            error.message || error\n          );\n          // Still return the client; queries will surface errors to the caller\n        } else {\n        }\n\n        this.client = client;\n        return client;\n      })();\n    }\n    return this.initPromise;\n  };\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return; // Already initialized, prevent multiple initializations\n    }\n\n    if (!isSupabaseConfigured()) {\n      throw new Error('Supabase is not properly configured');\n    }\n\n    // Initialize without blocking database call - test connection asynchronously\n    this.isInitialized = true;\n\n    // Test connection asynchronously without blocking initialization\n    this.testConnectionAsync();\n  }\n\n  private async testConnectionAsync(): Promise<void> {\n    try {\n      const response = await InventoryCrudOperations.getItems();\n      if (response.error) {\n        console.warn('‚ö†Ô∏è Supabase connection test failed:', response.error);\n        // Don't throw error, just log warning\n      } else {\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Supabase connection test failed:', error);\n      // Don't throw error, just log warning\n    }\n  }\n\n  public getAllItems = async (params?: {\n    facilityId?: string;\n  }): Promise<unknown[]> => {\n    // Check cache first\n    const now = Date.now();\n    if (this.cachedItems && now - this.cacheTimestamp < this.CACHE_DURATION) {\n      return this.cachedItems;\n    }\n\n    // Get facility ID from params or current user context\n    let facilityId = params?.facilityId;\n    if (!facilityId) {\n      const { FacilityService } = await import('@/services/facilityService');\n      facilityId = await FacilityService.getCurrentFacilityId();\n    }\n\n    // Use typed adapter for type-safe operations\n    const result = await this.typedAdapter.getAllItems({\n      filters: {\n        facility_id: facilityId,\n      },\n    });\n\n    if (!result.success || !result.data) {\n      console.warn('Failed to get inventory items:', result.error);\n      return [];\n    }\n\n    // Cache the results\n    this.cachedItems = result.data;\n    this.cacheTimestamp = Date.now();\n\n    return result.data;\n  };\n\n  async getItemsByCategory(category: string): Promise<InventoryItem[]> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const result = await this.typedAdapter.getAllItems({\n        filters: {\n          category,\n        },\n      });\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to get items by category');\n      }\n\n      return result.data;\n    } catch (error) {\n      throw new Error(\n        `Failed to get items by category: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async getFilteredItems(\n    searchQuery: string,\n    filters?: Record<string, unknown>\n  ): Promise<InventoryItem[]> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const result = await this.typedAdapter.getAllItems({\n        filters: {\n          search: searchQuery,\n          ...filters,\n        },\n      });\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to get filtered items');\n      }\n\n      return result.data;\n    } catch (error) {\n      throw new Error(\n        `Failed to get filtered items: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async getCategories(): Promise<string[]> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const response = await InventoryCrudOperations.getCategories();\n      return response || [];\n    } catch (error) {\n      throw new Error(\n        `Failed to get categories: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async fetchCategories(): Promise<string[]> {\n    return this.getCategories();\n  }\n\n  async updateInventoryItem(\n    id: string,\n    item: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const supabaseItem = InventoryDataTransformer.transformToSupabase(item);\n      const response = await InventoryCrudOperations.updateItem(\n        id,\n        supabaseItem\n      );\n      return response;\n    } catch (error) {\n      throw new Error(\n        `Failed to update inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async deleteInventoryItem(id: string): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      await InventoryCrudOperations.deleteItem(id);\n    } catch (error) {\n      throw new Error(\n        `Failed to delete inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  // Required interface methods\n  isConnected(): boolean {\n    return this.isInitialized;\n  }\n\n  getMetadata(): AdapterMetadata {\n    return {\n      name: 'Supabase Adapter',\n      version: '1.0.0',\n      description: 'Supabase-based inventory data adapter',\n      capabilities: {\n        supportsRead: true,\n        supportsWrite: true,\n        supportsDelete: true,\n        supportsRealTime: true,\n        supportsOffline: false,\n        supportsBatch: false,\n      },\n      config: this.config,\n    };\n  }\n\n  async fetchAllInventoryData(): Promise<InventoryResponse> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    const items = await this.getAllItems();\n\n    // Return all items without hardcoded filtering\n    // Let the UI handle categorization dynamically\n    return {\n      data: items as InventoryItem[],\n      error: null,\n      count: items.length,\n    };\n  }\n\n  async fetchInventoryItems(): Promise<InventoryItem[]> {\n    return this.getAllItems();\n  }\n\n  async addInventoryItem(item: InventoryItem): Promise<InventoryItem> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const supabaseItem = InventoryDataTransformer.transformToSupabase(item);\n      const response = await InventoryCrudOperations.createItem(\n        supabaseItem as Omit<InventoryItem, 'id' | 'lastUpdated'>\n      );\n      return response;\n    } catch (error) {\n      throw new Error(\n        `Failed to add inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async addCategory(category: string): Promise<string> {\n    // This would need to be implemented based on your Supabase schema\n    // For now, we'll just return the category name\n    return category;\n  }\n\n  async deleteCategory(category: string): Promise<void> {\n    // This would need to be implemented based on your Supabase schema\n    // For now, we'll just log it\n  }\n\n  async batchAddItems(items: InventoryItem[]): Promise<InventoryItem[]> {\n    const results: InventoryItem[] = [];\n    for (const item of items) {\n      try {\n        const result = await this.addInventoryItem(item);\n        results.push(result);\n      } catch (error) {\n        this.lastError = error as Error;\n        throw error;\n      }\n    }\n    return results;\n  }\n\n  async batchUpdateItems(\n    updates: Array<{ id: string; item: Partial<InventoryItem> }>\n  ): Promise<InventoryItem[]> {\n    const results: InventoryItem[] = [];\n    for (const update of updates) {\n      try {\n        const result = await this.updateInventoryItem(update.id, update.item);\n        results.push(result);\n      } catch (error) {\n        this.lastError = error as Error;\n        throw error;\n      }\n    }\n    return results;\n  }\n\n  async batchDeleteItems(ids: string[]): Promise<void> {\n    for (const id of ids) {\n      try {\n        await this.deleteInventoryItem(id);\n      } catch (error) {\n        this.lastError = error as Error;\n        throw error;\n      }\n    }\n  }\n\n  async sync(): Promise<void> {\n    try {\n      this.lastSyncTime = new Date();\n      this.pendingChanges = false;\n    } catch (error) {\n      this.lastError = error as Error;\n      throw error;\n    }\n  }\n\n  getLastSyncTime(): Date | null {\n    return this.lastSyncTime;\n  }\n\n  hasPendingChanges(): boolean {\n    return this.pendingChanges;\n  }\n\n  getLastError(): Error | null {\n    return this.lastError;\n  }\n\n  clearError(): void {\n    this.lastError = null;\n  }\n\n  async disconnect(): Promise<void> {\n    this.isInitialized = false;\n    this.lastError = null;\n  }\n\n  async fetchData(): Promise<void> {\n    // Data is fetched on-demand in Supabase, so this is a no-op\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n\n  async createItem(item: Partial<InventoryItem>): Promise<InventoryItem> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const supabaseItem = InventoryDataTransformer.transformToSupabase(item);\n      const response = await InventoryCrudOperations.createItem(\n        supabaseItem as Omit<InventoryItem, 'id' | 'lastUpdated'>\n      );\n      return response;\n    } catch (error) {\n      throw new Error(\n        `Failed to create inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async updateItem(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const supabaseUpdates =\n        InventoryDataTransformer.transformToSupabase(updates);\n      const response = await InventoryCrudOperations.updateItem(\n        id,\n        supabaseUpdates\n      );\n      return response;\n    } catch (error) {\n      throw new Error(\n        `Failed to update inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async deleteItem(id: string): Promise<void> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      await InventoryCrudOperations.deleteItem(id);\n    } catch (error) {\n      throw new Error(\n        `Failed to delete inventory item: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async getAnalyticsData(): Promise<Record<string, unknown>> {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      const response = await InventoryCrudOperations.getAnalytics();\n      return {\n        totalItems: response.totalItems,\n        activeItems: response.activeItems,\n        totalValue: response.totalValue,\n        categories: response.categories,\n      };\n    } catch (error) {\n      throw new Error(\n        `Failed to get analytics data: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  // Helper methods for data transformation\n  private transformToInventoryItems(\n    supabaseItems: Record<string, unknown>[]\n  ): InventoryItem[] {\n    return supabaseItems.map((item) =>\n      InventoryDataTransformer.transformFromSupabase(item)\n    );\n  }\n\n  // Real-time subscription methods\n  subscribeToChanges(\n    callback?: (payload: RealtimeInventoryPayload) => void\n  ): () => void {\n    if (!this.isInitialized) {\n      throw new Error('Supabase adapter not initialized');\n    }\n\n    try {\n      // Use typed adapter for type-safe realtime subscriptions\n      return this.typedAdapter.subscribeToChanges(\n        (payload: RealtimeInventoryPayload) => {\n          if (callback) {\n            callback(payload);\n          }\n        },\n        { event: '*' }\n      );\n    } catch (error) {\n      console.error(\n        '‚ùå Failed to set up real-time subscription in SupabaseAdapter:',\n        error\n      );\n      // Return no-op unsubscribe function as fallback\n      return () => {};\n    }\n  }\n\n  // Configuration methods\n  getConfig(): DataSourceConfig {\n    return this.config;\n  }\n\n  // Cache management\n  clearCache(): void {\n    this.cachedItems = null;\n    this.cacheTimestamp = 0;\n  }\n\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\SupabaseAdapterLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\TypedSupabaseAdapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\adapters\\TypedSupabaseAdapterLoader.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\data\\inventoryDataProvider.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'filterSummary' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 46,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 46,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport { InventoryItem } from '@/types/inventoryTypes';\nimport {\n  InventoryResponse,\n  InventoryFilters,\n} from '../types/inventoryServiceTypes';\nimport { InventoryDataTransformer } from '../utils/inventoryTransformers';\nimport { InventoryFilterOperations } from '../utils/inventoryFilterOperations';\nimport { InventoryActionService } from '@/pages/Inventory/services/inventoryActionService';\n\n// Helper function for safe number conversion\nconst safeNumber = (value: unknown, defaultValue: number = 0): number => {\n  if (typeof value === 'number' && !isNaN(value)) {\n    return value;\n  }\n  return defaultValue;\n};\n\n// Helper function for safe string conversion\nconst safeString = (\n  value: unknown,\n  defaultValue: string = 'Unknown'\n): string => {\n  if (typeof value === 'string' && value.trim() !== '') {\n    return value;\n  }\n  return defaultValue;\n};\n\n// Helper function for safe error handling\nconst getErrorMessage = (error: unknown): string => {\n  if (error instanceof Error) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return 'An unknown error occurred';\n};\n\nexport class InventoryDataProvider {\n  static async getItemsFromSupabase(\n    filters?: InventoryFilters\n  ): Promise<InventoryResponse> {\n    try {\n      const filterSummary = InventoryFilterOperations.getFilterSummary(filters);\n\n      // Validate filters\n      if (!InventoryFilterOperations.validateFilters(filters)) {\n        throw new Error('Invalid filter parameters');\n      }\n\n      const query = InventoryFilterOperations.applyFiltersToTable(\n        supabase,\n        'inventory_items',\n        filters\n      );\n\n      const { data, error, count } = await query.order('created_at', {\n        ascending: false,\n      });\n\n      if (error) {\n        console.error('Error fetching items from Supabase:', error);\n        throw error;\n      }\n\n      const transformedData =\n        (data as Record<string, unknown>[])?.map(\n          (item: Record<string, unknown>) =>\n            InventoryDataTransformer.transformFromSupabase(item)\n        ) || [];\n\n      return {\n        data: transformedData,\n        error: null,\n        count: count || 0,\n      };\n    } catch (error) {\n      console.error('Failed to fetch items from Supabase:', error);\n      throw error; // Re-throw the error so the core service can catch it\n    }\n  }\n\n  static async getItemByIdFromSupabase(\n    id: string\n  ): Promise<InventoryItem | null> {\n    try {\n      return await InventoryActionService.getItemById(id);\n    } catch (error) {\n      console.error('Error fetching item by ID:', error);\n      return null;\n    }\n  }\n\n  static async createItemInSupabase(\n    item: Omit<InventoryItem, 'id' | 'lastUpdated'>\n  ): Promise<InventoryItem> {\n    try {\n      const data = await InventoryActionService.processItemCreation(item);\n      return data;\n    } catch (error) {\n      console.error('Error creating item:', error);\n      throw new Error(`Failed to create item: ${getErrorMessage(error)}`);\n    }\n  }\n\n  static async updateItemInSupabase(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    try {\n      const data = await InventoryActionService.processItemUpdate(id, updates);\n      return data;\n    } catch (error) {\n      console.error('Error updating item:', error);\n      throw new Error(`Failed to update item: ${getErrorMessage(error)}`);\n    }\n  }\n\n  static async deleteItemFromSupabase(id: string): Promise<void> {\n    try {\n      await InventoryActionService.processItemDeletion(id);\n    } catch (error) {\n      throw new Error(`Failed to delete item: ${getErrorMessage(error)}`);\n    }\n  }\n\n  static async getCategories(): Promise<string[]> {\n    try {\n      const result = await InventoryFilterOperations.applyFiltersToCategories(\n        supabase,\n        'inventory_items'\n      );\n\n      if (!result) {\n        console.error('‚ùå Error fetching categories');\n        throw new Error('Failed to fetch categories');\n      }\n\n      const categories = InventoryFilterOperations.extractUniqueValues(\n        (result as { data: Record<string, unknown>[] }).data,\n        'category'\n      );\n      return categories.sort();\n    } catch (error) {\n      console.error('Error fetching categories:', error);\n      return [];\n    }\n  }\n\n  static async getCategoriesFromSupabase(): Promise<string[]> {\n    return this.getCategories();\n  }\n\n  static async getLocations(): Promise<string[]> {\n    try {\n      const result = await InventoryFilterOperations.applyFiltersToLocations(\n        supabase,\n        'inventory_items'\n      );\n\n      if (!result) {\n        console.error('‚ùå Error fetching locations');\n        throw new Error('Failed to fetch locations');\n      }\n\n      const locations = InventoryFilterOperations.extractUniqueValues(\n        (result as { data: Record<string, unknown>[] }).data,\n        'location'\n      );\n      return locations.sort();\n    } catch (error) {\n      console.error('Error fetching locations:', error);\n      return [];\n    }\n  }\n\n  static async getLocationsFromSupabase(): Promise<string[]> {\n    return this.getLocations();\n  }\n\n  static async getInventoryStatsFromSupabase(): Promise<{\n    totalItems: number;\n    activeItems: number;\n    totalValue: number;\n    categories: { [key: string]: number };\n  }> {\n    try {\n      const items = await InventoryActionService.getItems();\n\n      const totalItems = items.length;\n      const activeItems = items.filter(\n        (item) => item.status === 'active'\n      ).length;\n      const totalValue = items.reduce(\n        (sum, item) => sum + safeNumber(item.unit_cost),\n        0\n      );\n\n      const categories: { [key: string]: number } = {};\n      items.forEach((item) => {\n        const category = safeString(item.category);\n        categories[category] = (categories[category] || 0) + 1;\n      });\n\n      return {\n        totalItems,\n        activeItems,\n        totalValue,\n        categories,\n      };\n    } catch (error) {\n      console.error('Error fetching inventory stats:', error);\n      return {\n        totalItems: 0,\n        activeItems: 0,\n        totalValue: 0,\n        categories: {},\n      };\n    }\n  }\n\n  static calculateTotalValue(items: InventoryItem[]): number {\n    try {\n      const totalValue = items.reduce((sum, item) => {\n        const cost = safeNumber(item.unit_cost);\n        const quantity = safeNumber(item.quantity, 1);\n        return sum + cost * quantity;\n      }, 0);\n\n      return totalValue;\n    } catch (error) {\n      console.error('Error calculating total value:', error);\n      return 0;\n    }\n  }\n\n  static getCategoryBreakdown(items: InventoryItem[]): Record<string, number> {\n    try {\n      const categories: Record<string, number> = {};\n\n      items.forEach((item) => {\n        const category = safeString(item.category);\n        categories[category] = (categories[category] || 0) + 1;\n      });\n\n      return categories;\n    } catch (error) {\n      console.error('Error calculating category breakdown:', error);\n      return {};\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\facade\\adapters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\facade\\cache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\facade\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\facade\\repository.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'uniqueCategories' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 167,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 31
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 200,
        "column": 36,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 201,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [5898, 5907], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { InventoryItem, LocalInventoryItem } from './types';\nimport { InventoryDataAdapter } from '../adapters/InventoryDataAdapter';\nimport { inventoryAdapterFactory } from '../adapters/InventoryAdapterFactory';\nimport { InventoryErrorHandler } from '../InventoryErrorHandler';\nimport { cacheInvalidationService } from '../../cache/cacheInvalidationCompatibility';\nimport { logEvent, trackUserAction } from '../../../utils/monitoring';\nimport { trackEvent as trackAnalyticsEvent } from '../../analytics';\n\n// Normalize categories to one of the four main buckets\nexport function normalizeCategory(category: string): string {\n  const normalized = category.toLowerCase().trim();\n\n  if (\n    normalized.includes('mask') ||\n    normalized.includes('glove') ||\n    normalized.includes('gown') ||\n    normalized.includes('supply')\n  ) {\n    return 'Supplies';\n  }\n\n  if (\n    normalized.includes('scalpel') ||\n    normalized.includes('forceps') ||\n    normalized.includes('tool') ||\n    normalized.includes('instrument')\n  ) {\n    return 'Tools';\n  }\n\n  if (\n    normalized.includes('chair') ||\n    normalized.includes('autoclave') ||\n    normalized.includes('machine') ||\n    normalized.includes('equipment')\n  ) {\n    return 'Equipment';\n  }\n\n  if (\n    normalized.includes('computer') ||\n    normalized.includes('printer') ||\n    normalized.includes('office') ||\n    normalized.includes('hardware')\n  ) {\n    return 'Office Hardware';\n  }\n\n  // Fallback\n  return 'Tools';\n}\n\n// Use normalizeCategory consistently when building buckets\nexport function categorizeItems(normalized: Record<string, unknown>[]) {\n  const tools: Record<string, unknown>[] = [];\n  const supplies: Record<string, unknown>[] = [];\n  const equipment: Record<string, unknown>[] = [];\n  const officeHardware: Record<string, unknown>[] = [];\n\n  normalized.forEach((item) => {\n    const normalizedCategory = normalizeCategory(item.category || '');\n\n    switch (normalizedCategory) {\n      case 'Tools':\n        tools.push(item);\n        break;\n      case 'Supplies':\n        supplies.push(item);\n        break;\n      case 'Equipment':\n        equipment.push(item);\n        break;\n      case 'Office Hardware':\n        officeHardware.push(item);\n        break;\n      default:\n        tools.push(item);\n        break;\n    }\n  });\n\n  return { tools, supplies, equipment, officeHardware };\n}\n\nfunction withNormalizedCategory<T extends { category?: string | null }>(\n  items: T[]\n): T[] {\n  return items.map((it) => ({\n    ...it,\n    category: normalizeCategory(it.category),\n  }));\n}\n\nexport class InventoryRepository {\n  private currentAdapter: InventoryDataAdapter | null = null;\n  private adapterType: string = 'static';\n  private initialized = false;\n\n  constructor() {\n    // Adapter will be initialized by the facade\n  }\n\n  get isInitialized() {\n    return this.initialized;\n  }\n\n  async initialize(\n    adapter: InventoryDataAdapter,\n    adapterType: string\n  ): Promise<void> {\n    if (!this.initialized) {\n      this.currentAdapter = adapter;\n      this.adapterType = adapterType;\n      if (typeof this.currentAdapter.initialize === 'function') {\n        await this.currentAdapter.initialize();\n      }\n      this.initialized = true;\n      console.info('[InventoryRepository] Initialized successfully.');\n    }\n  }\n\n  private getAdapter(): InventoryDataAdapter {\n    if (!this.initialized || !this.currentAdapter) {\n      throw new Error(\n        'Inventory repository not initialized. Must call initialize() first.'\n      );\n    }\n    return this.currentAdapter;\n  }\n\n  /**\n   * Fetch all inventory items\n   */\n  async fetchInventoryItems(): Promise<LocalInventoryItem[]> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'fetchInventoryItems',\n      async () => {\n        const adapter = this.getAdapter();\n        return await adapter.fetchInventoryItems();\n      }\n    );\n    return result;\n  }\n\n  /**\n   * Fetch all inventory data with category transformation\n   */\n  async fetchAllInventoryData(): Promise<{\n    tools: LocalInventoryItem[];\n    supplies: LocalInventoryItem[];\n    equipment: LocalInventoryItem[];\n    officeHardware: LocalInventoryItem[];\n    categories: string[];\n    isLoading: boolean;\n    error: string | null;\n  }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'fetchAllInventoryData',\n      async () => {\n        const adapter = this.getAdapter();\n        const response = await adapter.fetchAllInventoryData();\n\n        // Transform InventoryResponse to InventoryDataResponse\n        const items = response.data || [];\n\n        // Show unique categories before normalization\n        const uniqueCategories = Array.from(\n          new Set(items.map((item) => item.category))\n        );\n\n        // Normalize categories to UI-expected buckets\n        const normalized = withNormalizedCategory(items);\n\n        // Filter by normalized categories - ensure each item only goes into one category\n        const tools: LocalInventoryItem[] = [];\n        const supplies: LocalInventoryItem[] = [];\n        const equipment: LocalInventoryItem[] = [];\n        const officeHardware: LocalInventoryItem[] = [];\n\n        // Use the unified categorization function\n        const categorized = categorizeItems(normalized);\n        tools.push(...categorized.tools);\n        supplies.push(...categorized.supplies);\n        equipment.push(...categorized.equipment);\n        officeHardware.push(...categorized.officeHardware);\n\n        // Ensure no duplicates by checking IDs\n        const allItemIds = new Set();\n        const duplicateIds = new Set();\n\n        [tools, supplies, equipment, officeHardware].forEach((category) => {\n          category.forEach((item) => {\n            if (allItemIds.has(item.id)) {\n              duplicateIds.add(item.id);\n            }\n            allItemIds.add(item.id);\n          });\n        });\n\n        if (duplicateIds.size > 0) {\n        }\n\n        // Get categories from normalized items\n        const categories = Array.from(\n          new Set(normalized.map((item) => item.category).filter(Boolean))\n        ) as string[];\n\n        return {\n          tools,\n          supplies,\n          equipment,\n          officeHardware,\n          categories,\n          isLoading: false,\n          error: response.error,\n        };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Get item by ID\n   */\n  async getItemById(\n    id: string\n  ): Promise<{ data: LocalInventoryItem | null; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'getItemById',\n      async () => {\n        const adapter = this.getAdapter();\n        const items = await adapter.fetchInventoryItems();\n        const item = items.find((item) => item.id === id) || null;\n        return { data: item, error: null };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Create new inventory item\n   */\n  async createItem(\n    item: Omit<InventoryItem, 'id' | 'lastUpdated'>\n  ): Promise<{ data: InventoryItem; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'createItem',\n      async () => {\n        const adapter = this.getAdapter();\n        const result = await adapter.addInventoryItem(item as InventoryItem);\n        cacheInvalidationService.invalidateRelated(\n          'inventory:create',\n          result.id\n        );\n\n        // Track inventory item creation\n        logEvent(\n          'inventory',\n          'item_created',\n          `Inventory item created: ${item.name || item.item}`,\n          'info',\n          {\n            itemId: result.id,\n            itemName: item.name || item.item,\n            category: item.category,\n            adapterType: this.adapterType,\n          }\n        );\n\n        trackUserAction('create_item', 'inventory', {\n          itemId: result.id,\n          itemName: item.name || item.item,\n          category: item.category,\n        });\n\n        trackAnalyticsEvent('inventory_item_created', {\n          itemId: result.id,\n          itemName: item.name || item.item,\n          category: item.category,\n          adapterType: this.adapterType,\n        });\n\n        return result;\n      }\n    );\n\n    return { data: result, error: null };\n  }\n\n  /**\n   * Update inventory item\n   */\n  async updateItem(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<{ data: InventoryItem; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'updateItem',\n      async () => {\n        const adapter = this.getAdapter();\n        return await adapter.updateInventoryItem(id, updates);\n      }\n    );\n\n    return { data: result, error: null };\n  }\n\n  /**\n   * Delete inventory item\n   */\n  async deleteItem(\n    id: string\n  ): Promise<{ success: boolean; error: string | null }> {\n    await InventoryErrorHandler.handleOperation('deleteItem', async () => {\n      const adapter = this.getAdapter();\n      await adapter.deleteInventoryItem(id);\n      return true;\n    });\n\n    return { success: true, error: null };\n  }\n\n  /**\n   * Add inventory item\n   */\n  async addInventoryItem(item: LocalInventoryItem): Promise<InventoryItem> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'addInventoryItem',\n      async () => {\n        const adapter = this.getAdapter();\n        const result = await adapter.addInventoryItem(item);\n        cacheInvalidationService.invalidateRelated('inventory:create', item.id);\n\n        // Track inventory item creation\n        logEvent(\n          'inventory',\n          'item_created',\n          `Inventory item created: ${item.name || item.item}`,\n          'info',\n          {\n            itemId: item.id,\n            itemName: item.name || item.item,\n            category: item.category,\n            adapterType: this.adapterType,\n          }\n        );\n\n        trackUserAction('create_item', 'inventory', {\n          itemId: item.id,\n          itemName: item.name || item.item,\n          category: item.category,\n        });\n\n        trackAnalyticsEvent('inventory_item_created', {\n          itemId: item.id,\n          itemName: item.name || item.item,\n          category: item.category,\n          adapterType: this.adapterType,\n        });\n\n        return result;\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Add category\n   */\n  async addCategory(\n    category: string\n  ): Promise<{ success: boolean; error: string | null }> {\n    await InventoryErrorHandler.handleOperation('addCategory', async () => {\n      const adapter = this.getAdapter();\n      await adapter.addCategory(category);\n      cacheInvalidationService.invalidateRelated(\n        'inventory:categories',\n        category\n      );\n\n      // Track category creation\n      logEvent(\n        'inventory',\n        'category_created',\n        `Category created: ${category}`,\n        'info',\n        {\n          category,\n          adapterType: this.adapterType,\n        }\n      );\n\n      trackUserAction('create_category', 'inventory', { category });\n\n      trackAnalyticsEvent('inventory_category_created', {\n        category,\n        adapterType: this.adapterType,\n      });\n\n      return true;\n    });\n\n    return { success: true, error: null };\n  }\n\n  /**\n   * Delete category\n   */\n  async deleteCategory(\n    category: string\n  ): Promise<{ success: boolean; error: string | null }> {\n    await InventoryErrorHandler.handleOperation('deleteCategory', async () => {\n      const adapter = this.getAdapter();\n      await adapter.deleteCategory(category);\n      cacheInvalidationService.invalidateRelated(\n        'inventory:categories',\n        category\n      );\n\n      // Track category deletion\n      logEvent(\n        'inventory',\n        'category_deleted',\n        `Category deleted: ${category}`,\n        'info',\n        {\n          category,\n          adapterType: this.adapterType,\n        }\n      );\n\n      trackUserAction('delete_category', 'inventory', { category });\n\n      trackAnalyticsEvent('inventory_category_deleted', {\n        category,\n        adapterType: this.adapterType,\n      });\n\n      return true;\n    });\n\n    return { success: true, error: null };\n  }\n\n  /**\n   * Bulk create items\n   */\n  async bulkCreateItems(\n    items: Omit<InventoryItem, 'id' | 'lastUpdated'>[]\n  ): Promise<{\n    success: boolean;\n    processedCount: number;\n    successCount: number;\n    errorCount: number;\n    errors: string[];\n    data: InventoryItem[];\n  }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'bulkCreateItems',\n      async () => {\n        const adapter = this.getAdapter();\n        const createdItems: InventoryItem[] = [];\n        const errors: string[] = [];\n        let successCount = 0;\n        let errorCount = 0;\n\n        for (const item of items) {\n          try {\n            const createdItem = await adapter.addInventoryItem(\n              item as InventoryItem\n            );\n            createdItems.push(createdItem);\n            cacheInvalidationService.invalidateRelated(\n              'inventory:create',\n              createdItem.id\n            );\n            successCount++;\n          } catch (error) {\n            errors.push(\n              `Failed to create item ${item.name || item.item}: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n            errorCount++;\n          }\n        }\n\n        return {\n          success: errorCount === 0,\n          processedCount: items.length,\n          successCount,\n          errorCount,\n          errors,\n          data: createdItems,\n        };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Bulk update items\n   */\n  async bulkUpdateItems(\n    updates: Array<{ id: string; updates: Partial<InventoryItem> }>\n  ): Promise<{\n    success: boolean;\n    processedCount: number;\n    successCount: number;\n    errorCount: number;\n    errors: string[];\n    data: InventoryItem[];\n  }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'bulkUpdateItems',\n      async () => {\n        const adapter = this.getAdapter();\n        const updatedItems: InventoryItem[] = [];\n        const errors: string[] = [];\n        let successCount = 0;\n        let errorCount = 0;\n\n        for (const update of updates) {\n          try {\n            const updatedItem = await adapter.updateInventoryItem(\n              update.id,\n              update.updates\n            );\n            updatedItems.push(updatedItem);\n            cacheInvalidationService.invalidateRelated(\n              'inventory:update',\n              update.id\n            );\n            successCount++;\n          } catch (error) {\n            errors.push(\n              `Failed to update item ${update.id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n            errorCount++;\n          }\n        }\n\n        return {\n          success: errorCount === 0,\n          processedCount: updates.length,\n          successCount,\n          errorCount,\n          errors,\n          data: updatedItems,\n        };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Bulk delete items\n   */\n  async bulkDeleteItems(ids: string[]): Promise<{\n    success: boolean;\n    processedCount: number;\n    successCount: number;\n    errorCount: number;\n    errors: string[];\n    data: InventoryItem[];\n  }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'bulkDeleteItems',\n      async () => {\n        const adapter = this.getAdapter();\n        const errors: string[] = [];\n        let successCount = 0;\n        let errorCount = 0;\n\n        for (const id of ids) {\n          try {\n            await adapter.deleteInventoryItem(id);\n            cacheInvalidationService.invalidateRelated('inventory:delete', id);\n            successCount++;\n          } catch (error) {\n            errors.push(\n              `Failed to delete item ${id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n            errorCount++;\n          }\n        }\n\n        return {\n          success: errorCount === 0,\n          processedCount: ids.length,\n          successCount,\n          errorCount,\n          errors,\n          data: [],\n        };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Search items\n   */\n  async searchItems(\n    query: string\n  ): Promise<{ data: LocalInventoryItem[]; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'searchItems',\n      async () => {\n        const adapter = this.getAdapter();\n        const allItems = await adapter.fetchInventoryItems();\n\n        const searchResults = allItems.filter(\n          (item) =>\n            item.name?.toLowerCase().includes(query.toLowerCase()) ||\n            (item.data as Record<string, unknown>)?.description\n              ?.toString()\n              .toLowerCase()\n              .includes(query.toLowerCase()) ||\n            item.category?.toLowerCase().includes(query.toLowerCase())\n        );\n\n        return { data: searchResults, error: null };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Get filtered items\n   */\n  async getFilteredItems(filters: {\n    category?: string;\n    status?: string;\n    location?: string;\n    searchQuery?: string;\n  }): Promise<{ data: LocalInventoryItem[]; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'getFilteredItems',\n      async () => {\n        const adapter = this.getAdapter();\n        const allItems = await adapter.fetchInventoryItems();\n\n        let filteredItems = allItems;\n\n        if (filters.category) {\n          filteredItems = filteredItems.filter(\n            (item) => item.category === filters.category\n          );\n        }\n\n        if (filters.status) {\n          filteredItems = filteredItems.filter(\n            (item) => item.status === filters.status\n          );\n        }\n\n        if (filters.location) {\n          filteredItems = filteredItems.filter(\n            (item) => item.location === filters.location\n          );\n        }\n\n        if (filters.searchQuery) {\n          const query = filters.searchQuery.toLowerCase();\n          filteredItems = filteredItems.filter(\n            (item) =>\n              item.name?.toLowerCase().includes(query) ||\n              (item.data as Record<string, unknown>)?.description\n                ?.toString()\n                .toLowerCase()\n                .includes(query)\n          );\n        }\n\n        return { data: filteredItems, error: null };\n      }\n    );\n\n    return result;\n  }\n\n  /**\n   * Get categories\n   */\n  async getCategories(): Promise<{ data: string[]; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'getCategories',\n      async () => {\n        const adapter = this.getAdapter();\n        return await adapter.fetchCategories();\n      }\n    );\n\n    return { data: result, error: null };\n  }\n\n  /**\n   * Get locations\n   */\n  async getLocations(): Promise<{ data: string[]; error: string | null }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'getLocations',\n      async () => {\n        const adapter = this.getAdapter();\n        const allItems = await adapter.fetchInventoryItems();\n        const locations = Array.from(\n          new Set(allItems.map((item) => item.location).filter(Boolean))\n        ) as string[];\n        return locations;\n      }\n    );\n\n    return { data: result, error: null };\n  }\n\n  /**\n   * Get inventory stats\n   */\n  async getInventoryStats(): Promise<{\n    data: Record<string, unknown> | null;\n    error: string | null;\n  }> {\n    const result = await InventoryErrorHandler.handleOperation(\n      'getInventoryStats',\n      async () => {\n        const adapter = this.getAdapter();\n        const allItems = await adapter.fetchInventoryItems();\n\n        const stats = {\n          totalItems: allItems.length,\n          categories: Array.from(new Set(allItems.map((item) => item.category)))\n            .length,\n          locations: Array.from(new Set(allItems.map((item) => item.location)))\n            .length,\n          activeItems: allItems.filter((item) => item.status === 'active')\n            .length,\n          maintenanceItems: allItems.filter(\n            (item) => item.status === 'maintenance'\n          ).length,\n          inactiveItems: allItems.filter((item) => item.status === 'inactive')\n            .length,\n          retiredItems: allItems.filter((item) => item.status === 'retired')\n            .length,\n        };\n\n        return stats;\n      }\n    );\n\n    return { data: result, error: null };\n  }\n\n  /**\n   * Get current adapter type\n   */\n  getCurrentAdapterType(): string {\n    return this.adapterType;\n  }\n\n  /**\n   * Get adapter metadata\n   */\n  getAdapterMetadata() {\n    const metadata = inventoryAdapterFactory.getAdapterMetadata(\n      this.adapterType\n    );\n    return metadata;\n  }\n\n  /**\n   * Get available adapters\n   */\n  getAvailableAdapters() {\n    return inventoryAdapterFactory.getAvailableAdapters();\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\facade\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\inventoryTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\SimpleInventoryLoadBalancer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 60,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 60,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 70,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 70,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 80,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 80,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 91,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 91,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 101,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 101,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 110,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 110,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 119,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 119,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'priority' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 128,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 128,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Simplified inventory load balancer\n * Removes unnecessary complexity while maintaining interface compatibility\n */\n\nimport { inventorySupabaseService } from './inventorySupabaseService';\nimport { INVENTORY_CONFIG } from '@/config/inventoryConfig';\nimport {\n  InventoryResponse,\n  InventoryFilters,\n} from '../types/inventoryServiceTypes';\nimport { InventoryItem } from '@/types/inventoryTypes';\n\nexport interface LoadBalancerConfig {\n  maxConcurrentRequests: number;\n  requestTimeout: number;\n  retryAttempts: number;\n  retryDelay: number;\n  enableCaching: boolean;\n  cacheTTL: number;\n  enableConnectionPooling: boolean;\n  enableQueryOptimization: boolean;\n}\n\n/**\n * Simplified load balancer that removes excessive complexity\n * while maintaining the same interface for compatibility\n */\nexport class SimpleInventoryLoadBalancer {\n  private static instance: SimpleInventoryLoadBalancer;\n  private config: LoadBalancerConfig;\n\n  private constructor() {\n    this.config = {\n      maxConcurrentRequests: INVENTORY_CONFIG.performance.maxConcurrentRequests,\n      requestTimeout: INVENTORY_CONFIG.performance.requestTimeout,\n      retryAttempts: INVENTORY_CONFIG.errorHandling.maxRetryAttempts,\n      retryDelay: 1000,\n      enableCaching: INVENTORY_CONFIG.cache.enabled,\n      cacheTTL: INVENTORY_CONFIG.cache.ttl,\n      enableConnectionPooling:\n        INVENTORY_CONFIG.performance.enableConnectionPooling,\n      enableQueryOptimization:\n        INVENTORY_CONFIG.performance.enableQueryOptimization,\n    };\n  }\n\n  static getInstance(): SimpleInventoryLoadBalancer {\n    if (!SimpleInventoryLoadBalancer.instance) {\n      SimpleInventoryLoadBalancer.instance = new SimpleInventoryLoadBalancer();\n    }\n    return SimpleInventoryLoadBalancer.instance;\n  }\n\n  /**\n   * Get inventory items (simplified - direct call)\n   */\n  async getItems(\n    filters?: InventoryFilters,\n    priority: 'high' | 'medium' | 'low' = 'medium'\n  ): Promise<InventoryResponse> {\n    return inventorySupabaseService.getItems(filters);\n  }\n\n  /**\n   * Get item by ID (simplified - direct call)\n   */\n  async getItemById(\n    id: string,\n    priority: 'high' | 'medium' | 'low' = 'high'\n  ): Promise<InventoryItem | null> {\n    return inventorySupabaseService.getItemById(id);\n  }\n\n  /**\n   * Create item (simplified - direct call)\n   */\n  async createItem(\n    item: Omit<InventoryItem, 'id' | 'lastUpdated'>,\n    priority: 'high' | 'medium' | 'low' = 'high'\n  ): Promise<InventoryItem> {\n    return inventorySupabaseService.createItem(item);\n  }\n\n  /**\n   * Update item (simplified - direct call)\n   */\n  async updateItem(\n    id: string,\n    updates: Partial<InventoryItem>,\n    priority: 'high' | 'medium' | 'low' = 'high'\n  ): Promise<InventoryItem> {\n    return inventorySupabaseService.updateItem(id, updates);\n  }\n\n  /**\n   * Delete item (simplified - direct call)\n   */\n  async deleteItem(\n    id: string,\n    priority: 'high' | 'medium' | 'low' = 'high'\n  ): Promise<void> {\n    return inventorySupabaseService.deleteItem(id);\n  }\n\n  /**\n   * Get categories (simplified - direct call)\n   */\n  async getCategories(\n    priority: 'high' | 'medium' | 'low' = 'low'\n  ): Promise<string[]> {\n    return inventorySupabaseService.getCategories();\n  }\n\n  /**\n   * Get locations (simplified - direct call)\n   */\n  async getLocations(\n    priority: 'high' | 'medium' | 'low' = 'low'\n  ): Promise<string[]> {\n    return inventorySupabaseService.getLocations();\n  }\n\n  /**\n   * Get analytics (simplified - direct call)\n   */\n  async getAnalytics(\n    priority: 'high' | 'medium' | 'low' = 'low'\n  ): Promise<unknown> {\n    return inventorySupabaseService.getAnalytics();\n  }\n\n  /**\n   * Get load balancer statistics (simplified)\n   */\n  getStats(): {\n    queueLength: number;\n    activeRequests: number;\n    cacheSize: number;\n    maxConcurrentRequests: number;\n  } {\n    return {\n      queueLength: 0, // No queue in simplified version\n      activeRequests: 0, // No request tracking in simplified version\n      cacheSize: 0, // No cache in simplified version\n      maxConcurrentRequests: this.config.maxConcurrentRequests,\n    };\n  }\n\n  /**\n   * Clear cache (no-op for compatibility)\n   */\n  clearCache(): void {}\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<LoadBalancerConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}\n\n// Export singleton instance\nexport const simpleInventoryLoadBalancer =\n  SimpleInventoryLoadBalancer.getInstance();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventoryAnalyticsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventoryCoreService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isSupabaseConfigured' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'InventoryResponse' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { isSupabaseConfigured } from '@/lib/supabase';\nimport {\n  InventoryResponse,\n  InventoryFilters,\n} from '../types/inventoryServiceTypes';\nimport { InventoryItem } from '@/types/inventoryTypes';\nimport { InventoryCrudOperations } from '../utils/inventoryCrudOperations';\nimport { InventoryCacheManager } from '../utils/inventoryCache';\n\nexport class InventoryCoreService {\n  private cacheManager: InventoryCacheManager;\n\n  constructor() {\n    this.cacheManager = new InventoryCacheManager();\n  }\n\n  async getFilteredItems(filters: InventoryFilters): Promise<InventoryItem[]> {\n    const response = await InventoryCrudOperations.getItems(filters);\n    return response.data;\n  }\n\n  async fetchInventoryItems(): Promise<InventoryItem[]> {\n    const response = await InventoryCrudOperations.getItems();\n    return response.data;\n  }\n\n  async refresh(): Promise<void> {\n    this.cacheManager.clearCache();\n  }\n\n  clearCache(): void {\n    this.cacheManager.clearCache();\n  }\n\n  getCacheManager(): InventoryCacheManager {\n    return this.cacheManager;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventoryLoadBalancer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventoryLoadBalancerCompatibility.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventorySubscriptionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\services\\inventorySupabaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\types\\inventoryServiceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\types\\supabaseTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryCrudOperations.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'getTableName' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 2,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'InventoryDataTransformer' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SupabaseSingleResponse' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 13,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 222,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 222,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6921, 6924], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6921, 6924], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 254,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 254,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7777, 7780], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7777, 7780], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 310,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 310,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9219, 9222], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9219, 9222], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 313,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 313,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9339, 9342], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9339, 9342], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 319,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 319,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9514, 9517], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9514, 9517], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../../lib/supabase';\nimport { getTableName } from '../../../config/inventoryConfig';\nimport { InventoryItem } from '../../../types/inventory';\nimport {\n  InventoryResponse,\n  InventoryFilters,\n} from '../types/inventoryServiceTypes';\nimport { InventoryDataTransformer } from './inventoryTransformers';\nimport { InventoryFilterOperations } from './inventoryFilterOperations';\nimport { InventoryErrorOperations } from './inventoryErrorOperations';\nimport { getTypedSupabaseAdapter } from '../adapters/TypedSupabaseAdapterLoader';\n\ninterface SupabaseSingleResponse {\n  data: unknown;\n  error: unknown;\n}\n\n// Helper function to handle Supabase errors\nconst handleSupabaseError = (error: unknown): Error => {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === 'object' && error !== null && 'message' in error) {\n    return new Error(String((error as { message: string }).message));\n  }\n  return new Error('Unknown Supabase error occurred');\n};\n\n/**\n * Shared CRUD operations for inventory services\n * Eliminates duplication across InventorySupabaseService, InventoryCoreService, etc.\n */\nexport class InventoryCrudOperations {\n  private static async getTypedAdapter() {\n    const { TypedSupabaseAdapter } = await getTypedSupabaseAdapter();\n    return new TypedSupabaseAdapter();\n  }\n  /**\n   * Get all inventory items with optional filtering\n   */\n  static async getItems(\n    filters?: InventoryFilters\n  ): Promise<InventoryResponse> {\n    const operation = 'Fetching inventory items';\n    const filterSummary = InventoryFilterOperations.getFilterSummary(filters);\n\n    InventoryErrorOperations.logStart(operation, filterSummary);\n\n    try {\n      // Validate filters\n      if (!InventoryFilterOperations.validateFilters(filters)) {\n        throw new Error('Invalid filter parameters');\n      }\n\n      // Use typed adapter for type-safe operations\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.getAllItems({\n        filters: filters as Record<string, unknown>,\n        orderBy: {\n          column: 'created_at',\n          ascending: false,\n        },\n      });\n\n      if (!result.success || !Array.isArray(result.data)) {\n        throw new Error(result.error || 'Failed to fetch inventory items');\n      }\n\n      const transformedData = result.data as InventoryItem[];\n\n      InventoryErrorOperations.logSuccess(\n        operation,\n        `${transformedData.length} items`\n      );\n\n      return {\n        data: transformedData,\n        error: null,\n        count: result.processedCount,\n      };\n    } catch (error) {\n      console.error('‚ùå InventoryCrudOperations.getItems failed:', error);\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a single inventory item by ID\n   */\n  static async getItemById(id: string): Promise<InventoryItem | null> {\n    const operation = `Fetching inventory item by ID: ${id}`;\n    InventoryErrorOperations.logStart(operation);\n\n    try {\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.getItemById(id);\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to fetch inventory item');\n      }\n\n      const item = result.data as InventoryItem;\n\n      InventoryErrorOperations.logSuccess(operation, item.name || 'Unknown');\n      return item;\n    } catch (error) {\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new inventory item\n   */\n  static async createItem(\n    item: Omit<InventoryItem, 'id' | 'lastUpdated'>\n  ): Promise<InventoryItem> {\n    const operation = `Creating inventory item: ${item.name}`;\n\n    InventoryErrorOperations.logStart(operation);\n\n    try {\n      // Use typed adapter for type-safe operations\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.createItem({\n        facility_id: item.facility_id || '',\n        name: item.name || '',\n        quantity: item.quantity ?? undefined,\n        data: item.data ?? undefined,\n        reorder_point: item.reorder_point ?? undefined,\n        expiration_date: item.expiration_date ?? undefined,\n        unit_cost: item.unit_cost ?? undefined,\n        category: item.category ?? undefined,\n      });\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to create inventory item');\n      }\n\n      InventoryErrorOperations.logSuccess(\n        operation,\n        result.data.name || 'Unknown'\n      );\n      return result.data as InventoryItem;\n    } catch (error) {\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an existing inventory item\n   */\n  static async updateItem(\n    id: string,\n    updates: Partial<InventoryItem>\n  ): Promise<InventoryItem> {\n    try {\n      // Use typed adapter for type-safe operations\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.updateItem(id, {\n        name: updates.name ?? undefined,\n        quantity: updates.quantity ?? undefined,\n        data: updates.data ?? undefined,\n        reorder_point: updates.reorder_point ?? undefined,\n        expiration_date: updates.expiration_date ?? undefined,\n        unit_cost: updates.unit_cost ?? undefined,\n        category: updates.category ?? undefined,\n      });\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to update inventory item');\n      }\n\n      return result.data as InventoryItem;\n    } catch (error) {\n      console.error('‚ùå Failed to update item in Supabase:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an inventory item\n   */\n  static async deleteItem(id: string): Promise<void> {\n    const operation = `Deleting inventory item: ${id}`;\n    InventoryErrorOperations.logStart(operation);\n\n    try {\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.deleteItem(id);\n\n      if (!result.success) {\n        throw new Error(result.error || 'Failed to delete inventory item');\n      }\n\n      InventoryErrorOperations.logSuccess(operation, `Deleted ${id}`);\n    } catch (error) {\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get inventory categories\n   */\n  static async getCategories(): Promise<string[]> {\n    const operation = 'Fetching inventory categories';\n    InventoryErrorOperations.logStart(operation);\n\n    try {\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.getAllItems();\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to fetch categories');\n      }\n\n      const categories = Array.from(\n        new Set(\n          result.data.map((item) => (item as any).category).filter(Boolean)\n        )\n      ) as string[];\n\n      InventoryErrorOperations.logSuccess(\n        operation,\n        `${categories.length} categories`\n      );\n      return categories;\n    } catch (error) {\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get inventory locations\n   */\n  static async getLocations(): Promise<string[]> {\n    const operation = 'Fetching inventory locations';\n    InventoryErrorOperations.logStart(operation);\n\n    try {\n      const typedAdapter = await this.getTypedAdapter();\n      const result = await typedAdapter.getAllItems();\n\n      if (!result.success || !result.data) {\n        throw new Error(result.error || 'Failed to fetch locations');\n      }\n\n      const locations = Array.from(\n        new Set(\n          result.data.map((item) => (item as any).location).filter(Boolean)\n        )\n      ) as string[];\n\n      InventoryErrorOperations.logSuccess(\n        operation,\n        `${locations.length} locations`\n      );\n      return locations;\n    } catch (error) {\n      InventoryErrorOperations.logFailure(operation, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get inventory analytics\n   */\n  static async getAnalytics(): Promise<{\n    totalItems: number;\n    activeItems: number;\n    totalValue: number;\n    categories: { [key: string]: number };\n  }> {\n    try {\n      // Get user's facility ID\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get user's facility ID from users table\n      const { data: userProfile } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      const facilityId =\n        userProfile?.facility_id || '550e8400-e29b-41d4-a716-446655440000';\n\n      const { data, error } = await supabase\n        .from('inventory_items')\n        .select('*')\n        .eq('facility_id', facilityId);\n\n      if (error) {\n        console.error('‚ùå Error fetching analytics from Supabase:', error);\n        throw handleSupabaseError(error);\n      }\n\n      const items = data || [];\n      const totalItems = items.length;\n      const activeItems = items.filter(\n        (item) => (item as any).status === 'active'\n      ).length;\n      const totalValue = items.reduce(\n        (sum, item) => sum + (((item as any).unit_cost as number) || 0),\n        0\n      );\n\n      const categories: { [key: string]: number } = {};\n      items.forEach((item) => {\n        const category = (item as any).category as string;\n        categories[category] = (categories[category] || 0) + 1;\n      });\n\n      return {\n        totalItems,\n        activeItems,\n        totalValue,\n        categories,\n      };\n    } catch (error) {\n      console.error('‚ùå Failed to fetch analytics from Supabase:', error);\n      throw error;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryErrorOperations.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'message' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 38,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'message' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 45,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 45,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { handleSupabaseError } from '../../../lib/supabase';\n\n/**\n * Simple error handling operations for inventory services\n * Standardizes error handling without over-engineering\n */\nexport class InventoryErrorOperations {\n  /**\n   * Handle Supabase errors consistently\n   */\n  static handleError(error: unknown, operation: string): never {\n    console.error(`‚ùå ${operation} failed:`, error);\n\n    if (error && typeof error === 'object' && 'message' in error) {\n      throw handleSupabaseError(error as Error);\n    }\n\n    throw new Error(`${operation} failed: ${error}`);\n  }\n\n  /**\n   * Handle Supabase response with consistent error checking\n   */\n  static handleResponse<T>(\n    response: { data: T; error: unknown },\n    operation: string\n  ): T {\n    if (response.error) {\n      this.handleError(response.error, operation);\n    }\n    return response.data;\n  }\n\n  /**\n   * Log operation start\n   */\n  static logStart(operation: string, details?: string): void {\n    const message = details ? `${operation}: ${details}` : operation;\n  }\n\n  /**\n   * Log operation success\n   */\n  static logSuccess(operation: string, details?: string): void {\n    const message = details ? `${operation}: ${details}` : operation;\n  }\n\n  /**\n   * Log operation failure\n   */\n  static logFailure(operation: string, error: unknown): void {\n    console.error(`‚ùå ${operation} failed:`, error);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryFilterOperations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryStandardizedErrorHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryStandardizedFilters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\inventory\\utils\\inventoryTransformers.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 26,
        "column": 7,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 27,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [960, 965], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { InventoryItem } from '../../../types/inventory';\n\n/**\n * Single source of truth for all Inventory data transformations\n * Consolidates all transformation logic to eliminate redundancy\n */\nexport class InventoryDataTransformer {\n  // ============================================================================\n  // SUPABASE TRANSFORMATIONS (Single Implementation)\n  // ============================================================================\n\n  static transformFromSupabase(\n    supabaseItem: Record<string, unknown>\n  ): InventoryItem {\n    // Extract category from data JSONB field if it exists\n    const data = (supabaseItem.data as Record<string, unknown>) || {};\n    const category =\n      (supabaseItem.category as string) ||\n      (data.category as string) ||\n      'unknown';\n\n    // Reduced logging in development - only log in debug mode\n    if (\n      import.meta.env.DEV &&\n      import.meta.env.VITE_DEBUG_INVENTORY === 'true'\n    ) {\n    }\n\n    return {\n      id: supabaseItem.id as string,\n      name: supabaseItem.name as string,\n      category: category,\n      location: '', // Default empty since not in DB\n      status: 'active', // Default since not in DB\n      updated_at: supabaseItem.updated_at as string,\n      quantity: supabaseItem.quantity as number,\n      unit_cost: supabaseItem.unit_cost as number,\n      reorder_point: (supabaseItem.reorder_point as number) || 0,\n      expiration_date: (supabaseItem.expiration_date as string) || '',\n      created_at: supabaseItem.created_at as string,\n      facility_id: (supabaseItem.facility_id as string) || '',\n      data: {\n        description: (data.description as string) || '',\n        barcode: (data.barcode as string) || '',\n        warranty: (data.warranty as string) || '',\n        serialNumber: (data.serialNumber as string) || '',\n        manufacturer: (data.manufacturer as string) || '',\n        lastServiced: (data.lastServiced as string) || '',\n        unit: (data.unit as string) || '',\n        supplier: (data.supplier as string) || '',\n        notes: (data.notes as string) || '',\n        tags: (data.tags as string[]) || [],\n        imageUrl: (data.imageUrl as string) || '',\n        isActive: (data.isActive as boolean) ?? true,\n        tracked: (data.tracked as boolean) ?? true,\n        favorite: (data.favorite as boolean) ?? false,\n        purchaseDate: (data.purchaseDate as string) || '',\n        createdAt: (data.createdAt as string) || '',\n        updatedAt: (data.updatedAt as string) || '',\n        currentPhase: (data.currentPhase as string) || '',\n        sku: (data.sku as string) || '',\n        p2Status: (data.p2Status as string) || '',\n        toolId: (data.toolId as string) || '',\n        supplyId: (data.supplyId as string) || '',\n        equipmentId: (data.equipmentId as string) || '',\n        hardwareId: (data.hardwareId as string) || '',\n        serviceProvider: (data.serviceProvider as string) || '',\n        assignedTo: (data.assignedTo as string) || '',\n      },\n    };\n  }\n\n  static transformToSupabase(\n    inventoryItem: Partial<InventoryItem>\n  ): Record<string, unknown> {\n    // Only include columns that definitely exist in the database schema\n    // This prevents schema cache mismatch errors\n    const transformed: Record<string, unknown> = {\n      name: inventoryItem.name,\n      category: inventoryItem.category,\n      quantity: inventoryItem.quantity || 0,\n      unit_cost: inventoryItem.unit_cost || 0,\n      status: inventoryItem.status || 'active',\n    };\n\n    // Only add facility_id if it's provided (don't override existing)\n    if (inventoryItem.facility_id) {\n      transformed.facility_id = inventoryItem.facility_id;\n    }\n\n    // Only add optional columns if they exist and have values\n    if (inventoryItem.data?.description) {\n      transformed.description = inventoryItem.data.description;\n    }\n\n    if (inventoryItem.location) {\n      transformed.location = inventoryItem.location;\n    }\n\n    if (inventoryItem.data?.sku) {\n      transformed.sku = inventoryItem.data.sku;\n    }\n\n    if (inventoryItem.data?.barcode) {\n      transformed.barcode = inventoryItem.data.barcode;\n    }\n\n    if (inventoryItem.data?.manufacturer) {\n      transformed.manufacturer = inventoryItem.data.manufacturer;\n    }\n\n    if (inventoryItem.data?.serialNumber) {\n      transformed.serial_number = inventoryItem.data.serialNumber;\n    }\n\n    if (inventoryItem.data?.expiration) {\n      transformed.expiration_date = inventoryItem.data.expiration;\n    }\n\n    if (inventoryItem.data?.unit) {\n      transformed.unit_of_measure = inventoryItem.data.unit;\n    }\n\n    if (inventoryItem.reorder_point !== undefined) {\n      transformed.reorder_point = inventoryItem.reorder_point;\n    }\n\n    // maxQuantity removed - not in Supabase schema\n\n    if (inventoryItem.data?.createdAt) {\n      transformed.created_at = inventoryItem.data.createdAt;\n    }\n\n    if (inventoryItem.data?.updatedAt) {\n      transformed.updated_at = inventoryItem.data.updatedAt;\n    }\n\n    return transformed;\n  }\n\n  // ============================================================================\n  // UI TRANSFORMATIONS (Single Implementation)\n  // ============================================================================\n\n  /**\n   * Transform inventory items for modal display\n   * Single source of truth for modal transformations\n   */\n  static transformForModal(items: InventoryItem[]): Array<{\n    id: string;\n    name: string;\n    barcode: string;\n    currentPhase: string;\n    category: string;\n  }> {\n    return items.map((item) => ({\n      id: item.id || '',\n      name: item.name || '',\n      barcode:\n        ((item.data as Record<string, unknown>)?.barcode as string) ||\n        item.id ||\n        '',\n      currentPhase:\n        item.status ||\n        ((item.data as Record<string, unknown>)?.currentPhase as string) ||\n        'Unknown',\n      category: item.category || '',\n    }));\n  }\n\n  /**\n   * Transform inventory items for table display\n   * Single source of truth for table transformations\n   */\n  static transformForTable(items: InventoryItem[]): Array<{\n    id: string;\n    name: string;\n    category: string;\n    location: string;\n    status: string;\n    tracked: boolean;\n    favorite: boolean;\n    lastUpdated: string;\n  }> {\n    return items.map((item) => ({\n      id: item.id || '',\n      name: item.name || '',\n      category: item.category || '',\n      location: item.location || '',\n      status:\n        item.status ||\n        ((item.data as Record<string, unknown>)?.currentPhase as string) ||\n        'Unknown',\n      tracked:\n        ((item.data as Record<string, unknown>)?.tracked as boolean) || false,\n      favorite:\n        ((item.data as Record<string, unknown>)?.favorite as boolean) || false,\n      lastUpdated:\n        ((item.data as Record<string, unknown>)?.updatedAt as string) || '',\n    }));\n  }\n\n  /**\n   * Transform inventory items for export\n   * Single source of truth for export transformations\n   */\n  static transformForExport(items: InventoryItem[]): Record<string, string>[] {\n    return items.map((item) => ({\n      ID: item.id || '',\n      Name: item.name || '',\n      Category: item.category || '',\n      Location: item.location || '',\n      Status:\n        item.status ||\n        ((item.data as Record<string, unknown>)?.currentPhase as string) ||\n        '',\n      Quantity: String(item.quantity || 0),\n      Cost: String(item.unit_cost || 0),\n      Barcode:\n        ((item.data as Record<string, unknown>)?.barcode as string) || '',\n      SerialNumber:\n        ((item.data as Record<string, unknown>)?.serialNumber as string) || '',\n      Manufacturer:\n        ((item.data as Record<string, unknown>)?.manufacturer as string) || '',\n      SKU: ((item.data as Record<string, unknown>)?.sku as string) || '',\n      Description:\n        ((item.data as Record<string, unknown>)?.description as string) || '',\n      Warranty:\n        ((item.data as Record<string, unknown>)?.warranty as string) || '',\n      LastServiced:\n        ((item.data as Record<string, unknown>)?.lastServiced as string) || '',\n      Notes: ((item.data as Record<string, unknown>)?.notes as string) || '',\n      Tags: Array.isArray((item.data as Record<string, unknown>)?.tags)\n        ? ((item.data as Record<string, unknown>).tags as string[]).join(', ')\n        : '',\n      CreatedAt:\n        ((item.data as Record<string, unknown>)?.createdAt as string) || '',\n      UpdatedAt:\n        ((item.data as Record<string, unknown>)?.updatedAt as string) || '',\n    }));\n  }\n\n  /**\n   * Transform inventory items for search\n   * Single source of truth for search transformations\n   */\n  static transformForSearch(\n    items: InventoryItem[]\n  ): Record<string, string | number | undefined>[] {\n    return items.map((item) => ({\n      id: item.id,\n      name: item.name || '',\n      category: item.category || '',\n      location: item.location || '',\n      status:\n        item.status ||\n        ((item.data as Record<string, unknown>)?.currentPhase as string) ||\n        '',\n      quantity: item.quantity || 0,\n      unit_cost: item.unit_cost || 0,\n      barcode:\n        ((item.data as Record<string, unknown>)?.barcode as string) ||\n        undefined,\n      description: (item.data as Record<string, unknown>)\n        ?.description as string,\n    }));\n  }\n\n  // ============================================================================\n  // UTILITY TRANSFORMATIONS\n  // ============================================================================\n\n  /**\n   * Create a new inventory item with default values\n   */\n  static createNewItem(\n    item: Partial<Omit<InventoryItem, 'id' | 'lastUpdated'>>\n  ): InventoryItem {\n    const now = new Date().toISOString();\n\n    return {\n      id: '',\n      name: (item as Partial<InventoryItem>).name || '',\n      category: (item as Partial<InventoryItem>).category || '',\n      location: (item as Partial<InventoryItem>).location || '',\n      status: (item as Partial<InventoryItem>).status || 'Active',\n      quantity: (item as Partial<InventoryItem>).quantity || 0,\n      unit_cost: (item as Partial<InventoryItem>).unit_cost || 0,\n      reorder_point: (item as Partial<InventoryItem>).reorder_point || 0,\n      expiration_date: (item as Partial<InventoryItem>).expiration_date || '',\n      created_at: now,\n      updated_at: now,\n      facility_id: (item as Partial<InventoryItem>).facility_id || '',\n      data: {\n        description: (item as Partial<InventoryItem>).data?.description || '',\n        barcode: (item as Partial<InventoryItem>).data?.barcode || '',\n        warranty: (item as Partial<InventoryItem>).data?.warranty || '',\n        serialNumber: (item as Partial<InventoryItem>).data?.serialNumber || '',\n        expiration: (item as Partial<InventoryItem>).data?.expiration || '',\n        manufacturer: (item as Partial<InventoryItem>).data?.manufacturer || '',\n        lastServiced: (item as Partial<InventoryItem>).data?.lastServiced || '',\n        unit: (item as Partial<InventoryItem>).data?.unit || '',\n        supplier: (item as Partial<InventoryItem>).data?.supplier || '',\n        notes: (item as Partial<InventoryItem>).data?.notes || '',\n        tags: (item as Partial<InventoryItem>).data?.tags || [],\n        imageUrl: (item as Partial<InventoryItem>).data?.imageUrl || '',\n        isActive: (item as Partial<InventoryItem>).data?.isActive ?? true,\n        tracked: (item as Partial<InventoryItem>).data?.tracked ?? false,\n        favorite: (item as Partial<InventoryItem>).data?.favorite ?? false,\n        purchaseDate: (item as Partial<InventoryItem>).data?.purchaseDate || '',\n        createdAt: now,\n        updatedAt: now,\n        currentPhase:\n          (item as Partial<InventoryItem>).data?.currentPhase || 'Active',\n        sku: (item as Partial<InventoryItem>).data?.sku || '',\n        p2Status: (item as Partial<InventoryItem>).data?.p2Status || '',\n        toolId: (item as Partial<InventoryItem>).data?.toolId || '',\n        supplyId: (item as Partial<InventoryItem>).data?.supplyId || '',\n        equipmentId: (item as Partial<InventoryItem>).data?.equipmentId || '',\n        hardwareId: (item as Partial<InventoryItem>).data?.hardwareId || '',\n        serviceProvider:\n          (item as Partial<InventoryItem>).data?.serviceProvider || '',\n        assignedTo: (item as Partial<InventoryItem>).data?.assignedTo || '',\n      },\n    };\n  }\n\n  /**\n   * Update an item with current timestamp\n   */\n  static updateItemWithTimestamp(\n    item: Partial<InventoryItem>\n  ): Partial<InventoryItem> {\n    const now = new Date().toISOString();\n\n    return {\n      ...item,\n      data: {\n        ...item.data,\n        lastUpdated: now,\n        updatedAt: now,\n      },\n    };\n  }\n\n  // ============================================================================\n  // LEGACY TRANSFORMATION FUNCTIONS (Consolidated from transformation.ts)\n  // ============================================================================\n\n  /**\n   * Normalizes item name (removes extra spaces, converts to title case)\n   */\n  static normalizeItemName(name: string): string {\n    if (!name) return '';\n\n    return name\n      .trim()\n      .replace(/\\s+/g, ' ')\n      .split(' ')\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n\n  /**\n   * Normalizes category name\n   */\n  static normalizeCategory(category: string): string {\n    if (!category) return '';\n\n    return category\n      .trim()\n      .toLowerCase()\n      .replace(/\\s+/g, '_')\n      .replace(/[^a-z0-9_]/g, '');\n  }\n\n  /**\n   * Transforms raw inventory data to normalized format\n   */\n  static transformInventoryItem(item: InventoryItem): InventoryItem & {\n    normalizedName: string;\n    normalizedCategory: string;\n    quantityInStock: number;\n    isExpired: boolean;\n    daysUntilExpiry: number | null;\n  } {\n    const normalizedName = this.normalizeItemName(item.name || '');\n    const normalizedCategory = this.normalizeCategory(item.category || '');\n    const expiryDate = (item.data as Record<string, unknown>)?.expiration\n      ? new Date((item.data as Record<string, unknown>).expiration as string)\n      : null;\n    const now = new Date();\n\n    const isExpired = expiryDate ? expiryDate < now : false;\n    const daysUntilExpiry = expiryDate\n      ? Math.ceil(\n          (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\n        )\n      : null;\n\n    return {\n      ...item,\n      normalizedName,\n      normalizedCategory,\n      quantityInStock: Math.max(0, item.quantity || 1),\n      isExpired,\n      daysUntilExpiry,\n    };\n  }\n\n  /**\n   * Transforms array of inventory items\n   */\n  static transformInventoryBatch(\n    items: InventoryItem[]\n  ): ReturnType<typeof this.transformInventoryItem>[] {\n    return items.map((item) => this.transformInventoryItem(item));\n  }\n\n  /**\n   * Converts inventory item to CSV format\n   */\n  static transformToCSV(items: InventoryItem[]): string {\n    if (items.length === 0) return '';\n\n    const headers = ['Name', 'Quantity', 'Category', 'Status', 'Expiry Date'];\n    const rows = items.map((item) => [\n      item.name,\n      (item.quantity || 1).toString(),\n      item.category,\n      item.status,\n      ((item.data as Record<string, unknown>)?.expiration as string) || '',\n    ]);\n\n    const csvContent = [headers, ...rows]\n      .map((row) => row.map((field) => `\"${field}\"`).join(','))\n      .join('\\n');\n\n    return csvContent;\n  }\n\n  /**\n   * Converts CSV string to inventory items\n   */\n  static transformFromCSV(csvString: string): InventoryItem[] {\n    const lines = csvString.trim().split('\\n');\n    if (lines.length < 2) return [];\n\n    const headers = lines[0].split(',').map((h) => h.replace(/\"/g, '').trim());\n    const dataLines = lines.slice(1);\n\n    return dataLines.map((line) => {\n      const values = line.split(',').map((v) => v.replace(/\"/g, '').trim());\n      const item: Record<string, unknown> = {};\n\n      headers.forEach((header, index) => {\n        item[header.toLowerCase().replace(/\\s+/g, '')] = values[index] || '';\n      });\n\n      return {\n        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n        name: (item.name as string) || '',\n        category: (item.category as string) || '',\n        status: (item.status as string) || 'active',\n        quantity: parseInt(item.quantity as string) || 1,\n        unit_cost: 0,\n        reorder_point: 0,\n        expiration_date: (item.expirydate as string) || '',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        facility_id: '',\n        location: '',\n        data: {\n          description: '',\n          barcode: '',\n          warranty: '',\n          serialNumber: '',\n          manufacturer: '',\n          lastServiced: '',\n          unit: '',\n          supplier: '',\n          notes: '',\n          tags: [],\n          imageUrl: '',\n          isActive: true,\n          tracked: false,\n          favorite: false,\n          purchaseDate: '',\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          currentPhase: '',\n          sku: '',\n          p2Status: '',\n          toolId: '',\n          supplyId: '',\n          equipmentId: '',\n          hardwareId: '',\n          serviceProvider: '',\n          assignedTo: '',\n        },\n      } as InventoryItem;\n    });\n  }\n\n  /**\n   * Transforms inventory data for API response\n   */\n  static transformForAPI(items: InventoryItem[]): Record<string, unknown>[] {\n    return items.map((item) => ({\n      id: item.id,\n      name: item.name,\n      category: item.category,\n      status: item.status,\n      quantity: item.quantity,\n      location: item.location,\n      unit_cost: item.unit_cost,\n      reorder_point: item.reorder_point,\n      expiration_date: item.expiration_date,\n      created_at: item.created_at,\n      updated_at: item.updated_at,\n      facility_id: item.facility_id,\n      data: {\n        description: (item.data as Record<string, unknown>)\n          ?.description as string,\n        barcode:\n          ((item.data as Record<string, unknown>)?.barcode as string) ||\n          undefined,\n        serialNumber: (item.data as Record<string, unknown>)\n          ?.serialNumber as string,\n        manufacturer: (item.data as Record<string, unknown>)\n          ?.manufacturer as string,\n        supplier: (item.data as Record<string, unknown>)?.supplier as string,\n        expiration: (item.data as Record<string, unknown>)\n          ?.expiration as string,\n        warranty: (item.data as Record<string, unknown>)?.warranty as string,\n        notes: (item.data as Record<string, unknown>)?.notes as string,\n        tags: (item.data as Record<string, unknown>)?.tags as string[],\n        imageUrl: (item.data as Record<string, unknown>)?.imageUrl as string,\n        isActive: (item.data as Record<string, unknown>)?.isActive as boolean,\n        tracked: (item.data as Record<string, unknown>)?.tracked as boolean,\n        favorite: (item.data as Record<string, unknown>)?.favorite as boolean,\n        purchaseDate: (item.data as Record<string, unknown>)\n          ?.purchaseDate as string,\n        lastServiced: (item.data as Record<string, unknown>)\n          ?.lastServiced as string,\n        unit: (item.data as Record<string, unknown>)?.unit as string,\n        currentPhase: (item.data as Record<string, unknown>)\n          ?.currentPhase as string,\n        sku: (item.data as Record<string, unknown>)?.sku as string,\n        p2Status: (item.data as Record<string, unknown>)?.p2Status as string,\n        toolId: (item.data as Record<string, unknown>)?.toolId as string,\n        supplyId: (item.data as Record<string, unknown>)?.supplyId as string,\n        equipmentId: (item.data as Record<string, unknown>)\n          ?.equipmentId as string,\n        hardwareId: (item.data as Record<string, unknown>)\n          ?.hardwareId as string,\n        serviceProvider: (item.data as Record<string, unknown>)\n          ?.serviceProvider as string,\n        assignedTo: (item.data as Record<string, unknown>)\n          ?.assignedTo as string,\n      },\n    }));\n  }\n\n  /**\n   * Transforms API response to internal format\n   */\n  static transformFromAPI(apiData: Record<string, unknown>[]): InventoryItem[] {\n    return apiData.map((item) => ({\n      id: item.id as string,\n      name: item.name as string,\n      category: item.category as string,\n      location: item.location as string,\n      status: item.status as string,\n      updated_at: item.updated_at as string,\n      quantity: item.quantity as number,\n      unit_cost: item.unit_cost as number,\n      reorder_point: item.reorder_point as number,\n      expiration_date: item.expiration_date as string,\n      created_at: item.created_at as string,\n      facility_id: item.facility_id as string,\n      data: {\n        description: (item.data as Record<string, unknown>)\n          ?.description as string,\n        barcode: (item.data as Record<string, unknown>)?.barcode as string,\n        warranty: (item.data as Record<string, unknown>)?.warranty as string,\n        serialNumber: (item.data as Record<string, unknown>)\n          ?.serialNumber as string,\n        expiration: (item.data as Record<string, unknown>)\n          ?.expiration as string,\n        manufacturer: (item.data as Record<string, unknown>)\n          ?.manufacturer as string,\n        lastServiced: (item.data as Record<string, unknown>)\n          ?.lastServiced as string,\n        unit: (item.data as Record<string, unknown>)?.unit as string,\n        supplier: (item.data as Record<string, unknown>)?.supplier as string,\n        notes: (item.data as Record<string, unknown>)?.notes as string,\n        tags: (item.data as Record<string, unknown>)?.tags as string[],\n        imageUrl: (item.data as Record<string, unknown>)?.imageUrl as string,\n        isActive: (item.data as Record<string, unknown>)?.isActive as boolean,\n        tracked: (item.data as Record<string, unknown>)?.tracked as boolean,\n        favorite: (item.data as Record<string, unknown>)?.favorite as boolean,\n        purchaseDate: (item.data as Record<string, unknown>)\n          ?.purchaseDate as string,\n        createdAt: (item.data as Record<string, unknown>)?.createdAt as string,\n        updatedAt: (item.data as Record<string, unknown>)?.updatedAt as string,\n        currentPhase: (item.data as Record<string, unknown>)\n          ?.currentPhase as string,\n        sku: (item.data as Record<string, unknown>)?.sku as string,\n        p2Status: (item.data as Record<string, unknown>)?.p2Status as string,\n        toolId: (item.data as Record<string, unknown>)?.toolId as string,\n        supplyId: (item.data as Record<string, unknown>)?.supplyId as string,\n        equipmentId: (item.data as Record<string, unknown>)\n          ?.equipmentId as string,\n        hardwareId: (item.data as Record<string, unknown>)\n          ?.hardwareId as string,\n        serviceProvider: (item.data as Record<string, unknown>)\n          ?.serviceProvider as string,\n        assignedTo: (item.data as Record<string, unknown>)\n          ?.assignedTo as string,\n      },\n    }));\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\itemBarcodeMappingService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DatabaseFunctionResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport { useLoginStore } from '@/stores/useLoginStore';\n\n// Database row interfaces\ninterface DatabaseFunctionResult {\n  success: boolean;\n  message: string;\n  mapping_id?: string;\n}\n\nexport interface BarcodeMapping {\n  id: string;\n  itemId: string;\n  barcodeId: string;\n  barcodeType: 'external' | 'internal' | 'product';\n  isActive: boolean;\n  assignedAt: string;\n  assignedBy: string;\n  facilityId: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface LinkBarcodeResult {\n  success: boolean;\n  message: string;\n  mappingId?: string;\n}\n\nexport interface UnlinkBarcodeResult {\n  success: boolean;\n  message: string;\n}\n\nexport interface ItemByBarcodeResult {\n  itemId: string;\n  itemName: string;\n  category: string;\n  location: string;\n  status: string;\n}\n\nexport class ItemBarcodeMappingService {\n  /**\n   * Link an external barcode ID to an internal item ID\n   * @param itemId - Internal Cliniio item ID (source of truth)\n   * @param barcodeId - External barcode ID that customers buy\n   * @param barcodeType - Type of barcode (external, internal, product)\n   * @returns LinkBarcodeResult\n   */\n  static async linkBarcodeToItem(itemId: string, barcodeValue: string) {\n    const { data, error } = await supabase\n      .from('inventory_items')\n      .update({ barcode: barcodeValue })\n      .eq('id', itemId)\n      .select();\n\n    return { data, error };\n  }\n\n  /**\n   * Unlink a barcode from an item\n   * @param itemId - Internal Cliniio item ID\n   * @param barcodeId - External barcode ID to unlink\n   * @returns UnlinkBarcodeResult\n   */\n  static async unlinkBarcodeFromItem(itemId: string) {\n    const { data, error } = await supabase\n      .from('inventory_items')\n      .update({ barcode: null })\n      .eq('id', itemId)\n      .select();\n\n    return { data, error };\n  }\n\n  /**\n   * Get item information by barcode ID\n   * @param barcodeId - External barcode ID\n   * @returns ItemByBarcodeResult | null\n   */\n  static async getItemByBarcode(barcode: string) {\n    const { data, error } = await supabase\n      .from('inventory_items')\n      .select('*')\n      .eq('barcode', barcode)\n      .limit(1)\n      .single();\n\n    return { data, error };\n  }\n\n  /**\n   * Get all barcode mappings for an item\n   * @param itemId - Internal Cliniio item ID\n   * @returns BarcodeMapping[]\n   */\n  static async getBarcodeMappingsForItem(\n    itemId: string\n  ): Promise<BarcodeMapping[]> {\n    try {\n      const { data, error } = await supabase\n        .from('item_barcode_mappings')\n        .select('*')\n        .eq('item_id', itemId)\n        .eq('is_active', true)\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        throw new Error(`Failed to get barcode mappings: ${error.message}`);\n      }\n\n      return (\n        (data as Record<string, unknown>[])?.map((mapping) => ({\n          id: mapping.id as string,\n          itemId: mapping.item_id as string,\n          barcodeId: mapping.barcode_id as string,\n          barcodeType: mapping.barcode_type as\n            | 'external'\n            | 'internal'\n            | 'product',\n          isActive: mapping.is_active as boolean,\n          assignedAt: mapping.assigned_at as string,\n          assignedBy: mapping.assigned_by as string,\n          facilityId: mapping.facility_id as string,\n          createdAt: mapping.created_at as string,\n          updatedAt: mapping.updated_at as string,\n        })) || []\n      );\n    } catch (error) {\n      console.error('Error getting barcode mappings for item:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check if a barcode is available (not assigned to any item)\n   * @param barcodeId - External barcode ID to check\n   * @returns boolean\n   */\n  static async isBarcodeAvailable(barcodeId: string): Promise<boolean> {\n    try {\n      const authToken = useLoginStore.getState().authToken;\n      if (!authToken) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get current user from Supabase\n      const {\n        data: { user },\n        error: userError,\n      } = await supabase.auth.getUser();\n      if (userError || !user) {\n        throw new Error('Failed to get current user');\n      }\n\n      // Get user profile to get facility_id\n      const { data: userProfile, error: profileError } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      if (profileError || !userProfile) {\n        throw new Error('Failed to get user profile');\n      }\n\n      const facilityId = userProfile.facility_id;\n\n      // Check if barcode is already assigned\n      const { data, error } = await supabase\n        .from('item_barcode_mappings')\n        .select('id')\n        .eq('barcode_id', barcodeId)\n        .eq('facility_id', facilityId as string)\n        .eq('is_active', true)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 is \"not found\"\n        throw new Error(\n          `Failed to check barcode availability: ${error.message}`\n        );\n      }\n\n      // If data exists, barcode is not available\n      return !data;\n    } catch (error) {\n      console.error('Error checking barcode availability:', error);\n      return false;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\leaderboardService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\learningProgressService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\loginApi.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\loginApiService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\loginDataService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\loginQueryService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 75,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useMutation } from '@tanstack/react-query';\nimport { login } from './authService';\nimport { create } from 'zustand';\nimport { useState, useEffect } from 'react';\n\n// Password visibility toggle hook\nexport const usePasswordVisibility = () => {\n  const [passwordVisible, setPasswordVisible] = useState(false);\n\n  const togglePasswordVisibility = () => {\n    setPasswordVisible((prev) => !prev);\n  };\n\n  return { passwordVisible, togglePasswordVisibility };\n};\n\n// Simple validation function without external dependencies\nexport const validateForm = (data: { email: string; password: string }) => {\n  const errors: string[] = [];\n\n  // Email validation\n  if (!data.email || data.email.trim() === '') {\n    errors.push('Email is required');\n  } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\n    errors.push('Invalid email format');\n  }\n\n  // Password validation\n  if (!data.password || data.password.length < 6) {\n    errors.push('Password must be at least 6 characters');\n  }\n\n  return errors.length === 0 ? true : errors;\n};\n\n// Define login credentials type\ninterface LoginCredentials {\n  email: string;\n  password: string;\n}\n\n// Helper function to sanitize input\nconst sanitizeInput = (input: string): string => {\n  return input.replace(/[<>]/g, '').trim();\n};\n\n// Define a login function for React Query\nconst loginMutation = async (credentials: LoginCredentials) => {\n  // Sanitize user input\n  const sanitizedEmail = sanitizeInput(credentials.email);\n  const sanitizedPassword = sanitizeInput(credentials.password);\n\n  // Use the proper login function from authService instead of non-existent API\n  return await login(sanitizedEmail, sanitizedPassword);\n};\n\n// Use React Query's useMutation for login\nexport const useLogin = () => {\n  return useMutation({\n    mutationFn: loginMutation,\n  });\n};\n\nconst loginWithRetry = async (credentials: LoginCredentials) => {\n  try {\n    // Sanitize user input\n    const sanitizedEmail = sanitizeInput(credentials.email);\n    const sanitizedPassword = sanitizeInput(credentials.password);\n\n    return await login(sanitizedEmail, sanitizedPassword);\n  } catch (err) { console.error(err); throw err; }\n    // Implement retry logic if needed\n    throw new Error('Login failed, please try again.');\n  }\n};\n\nexport const useLoginWithRetry = () => {\n  return useMutation({\n    mutationFn: loginWithRetry,\n    retry: 3, // Retry up to 3 times on failure\n    onError: (error: Error) => {\n      console.error('Error logging in:', error);\n    },\n  });\n};\n\n// Handle submit function with security measures\nexport const handleSubmit = async (\n  e: React.FormEvent,\n  formData: { email: string; password: string }\n): Promise<void> => {\n  e.preventDefault();\n  const { email, password } = formData;\n  try {\n    await loginService(email, password);\n    // Handle successful login\n  } catch (err) { console.error(err); throw err; }\n    // Handle error\n  }\n};\n\n// Centralized auth state with persistence\nexport const useAuthStore = create<{\n  token: string | null;\n  setAuthToken: (token: string) => void;\n}>((set) => ({\n  token: localStorage.getItem('authToken') || null,\n  setAuthToken: (token: string) => {\n    localStorage.setItem('authToken', token);\n    set({ token });\n  },\n}));\n\n// Rate limiting hook\nexport const useRateLimit = () => {\n  const [attempts, setAttempts] = useState(0);\n  const [lockedUntil, setLockedUntil] = useState<Date | null>(null);\n\n  useEffect(() => {\n    if (lockedUntil && new Date() < lockedUntil) {\n      // User is locked out\n      return;\n    }\n    if (lockedUntil && new Date() >= lockedUntil) {\n      setAttempts(0);\n      setLockedUntil(null);\n    }\n  }, [lockedUntil]);\n\n  const incrementAttempts = () => {\n    if (attempts + 1 >= 5) {\n      setLockedUntil(new Date(new Date().getTime() + 15 * 60 * 1000)); // Lock for 15 minutes\n    } else {\n      setAttempts(attempts + 1);\n    }\n  };\n\n  return { attempts, lockedUntil, incrementAttempts };\n};\n\nconst loginService = async (email: string, password: string) => {\n  const response = await fetch('/api/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ email, password }),\n  });\n  if (!response.ok) throw new Error('Login failed');\n  return response.json();\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\loginService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\mobileShortcutService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\AlertingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\EnhancedLoggingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\HealthCheckService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\MemoryMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\MetricsCollector.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\MonitoringDashboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\monitoring\\PerformanceMonitor.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 588,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '../../utils/_core/logger';\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: string;\n  timestamp: Date;\n  tags: Record<string, string>;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface PerformanceThreshold {\n  metric: string;\n  warning: number;\n  critical: number;\n  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n}\n\nexport interface PerformanceAlert {\n  id: string;\n  metric: string;\n  value: number;\n  threshold: number;\n  severity: 'warning' | 'critical';\n  message: string;\n  timestamp: Date;\n  resolved: boolean;\n  resolvedAt?: Date;\n}\n\nexport interface SystemHealth {\n  status: 'healthy' | 'degraded' | 'critical';\n  score: number; // 0-100\n  checks: Array<{\n    name: string;\n    status: 'pass' | 'fail' | 'warn';\n    message: string;\n    duration: number;\n  }>;\n  metrics: {\n    cpu: number;\n    memory: number;\n    responseTime: number;\n    errorRate: number;\n    throughput: number;\n  };\n  lastUpdated: Date;\n}\n\nexport interface PerformanceSnapshot {\n  timestamp: Date;\n  metrics: Map<string, number>;\n  health: SystemHealth;\n  alerts: PerformanceAlert[];\n}\n\nexport interface PerformanceTrend {\n  metric: string;\n  trend: 'improving' | 'stable' | 'degrading';\n  changePercent: number;\n  period: string;\n}\n\nexport interface PerformanceInsight {\n  type: 'optimization' | 'warning' | 'critical';\n  title: string;\n  description: string;\n  impact: 'low' | 'medium' | 'high';\n  recommendations: string[];\n}\n\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor;\n  private metrics: Map<string, PerformanceMetric[]> = new Map();\n  private thresholds: PerformanceThreshold[] = [];\n  private alerts: PerformanceAlert[] = [];\n  private healthChecks: Array<\n    () => Promise<{\n      name: string;\n      status: 'pass' | 'fail' | 'warn';\n      message: string;\n      duration: number;\n    }>\n  > = [];\n  private readonly MAX_METRICS_PER_TYPE = 1000;\n  private performanceHistory: Map<string, PerformanceSnapshot[]> = new Map();\n  private alertSubscribers: Array<(alert: PerformanceAlert) => void> = [];\n  private monitoringInterval: NodeJS.Timeout | null = null;\n  private isMonitoring = false;\n\n  private constructor() {\n    this.initializeDefaultThresholds();\n    this.initializeHealthChecks();\n    this.startContinuousMonitoring();\n  }\n\n  static getInstance(): PerformanceMonitor {\n    if (!PerformanceMonitor.instance) {\n      PerformanceMonitor.instance = new PerformanceMonitor();\n    }\n    return PerformanceMonitor.instance;\n  }\n\n  /**\n   * Record a performance metric\n   */\n  recordMetric(\n    name: string,\n    value: number,\n    unit: string,\n    tags: Record<string, string> = {},\n    metadata?: Record<string, unknown>\n  ): void {\n    const metric: PerformanceMetric = {\n      name,\n      value,\n      unit,\n      timestamp: new Date(),\n      tags,\n      metadata,\n    };\n\n    // Store metric\n    if (!this.metrics.has(name)) {\n      this.metrics.set(name, []);\n    }\n\n    const metricList = this.metrics.get(name)!;\n    metricList.push(metric);\n\n    // Keep only recent metrics\n    if (metricList.length > this.MAX_METRICS_PER_TYPE) {\n      metricList.splice(0, metricList.length - this.MAX_METRICS_PER_TYPE);\n    }\n\n    // Check thresholds\n    this.checkThresholds(metric);\n\n    logger.debug(`Performance metric recorded: ${name}=${value}${unit}`, {\n      tags,\n      metadata,\n    });\n  }\n\n  /**\n   * Record response time\n   */\n  recordResponseTime(\n    operation: string,\n    duration: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('response_time', duration, 'ms', {\n      operation,\n      ...tags,\n    });\n  }\n\n  /**\n   * Record error rate\n   */\n  recordErrorRate(\n    service: string,\n    rate: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('error_rate', rate, 'percent', {\n      service,\n      ...tags,\n    });\n  }\n\n  /**\n   * Record throughput\n   */\n  recordThroughput(\n    operation: string,\n    count: number,\n    period: number = 60, // seconds\n    tags: Record<string, string> = {}\n  ): void {\n    const rate = count / period;\n    this.recordMetric('throughput', rate, 'ops/sec', {\n      operation,\n      period: period.toString(),\n      ...tags,\n    });\n  }\n\n  /**\n   * Record memory usage\n   */\n  recordMemoryUsage(\n    type: 'heap' | 'rss' | 'external',\n    value: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('memory_usage', value, 'bytes', {\n      type,\n      ...tags,\n    });\n  }\n\n  /**\n   * Record database query performance\n   */\n  recordDatabaseQuery(\n    query: string,\n    duration: number,\n    rowsAffected: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('db_query_duration', duration, 'ms', {\n      query: query.substring(0, 50), // Truncate for storage\n      ...tags,\n    });\n\n    this.recordMetric('db_query_rows', rowsAffected, 'count', {\n      query: query.substring(0, 50),\n      ...tags,\n    });\n  }\n\n  /**\n   * Record component mount time\n   */\n  recordComponentMount(\n    componentName: string,\n    duration: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('component_mount_time', duration, 'ms', {\n      component: componentName,\n      ...tags,\n    });\n  }\n\n  /**\n   * Record authentication performance\n   */\n  recordAuthentication(\n    duration: number,\n    success: boolean,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('authentication_time', duration, 'ms', {\n      success: success.toString(),\n      ...tags,\n    });\n  }\n\n  /**\n   * Record data fetch performance\n   */\n  recordDataFetch(\n    operation: string,\n    duration: number,\n    success: boolean,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('data_fetch_time', duration, 'ms', {\n      operation,\n      success: success.toString(),\n      ...tags,\n    });\n  }\n\n  /**\n   * Record navigation performance\n   */\n  recordNavigation(\n    from: string,\n    to: string,\n    duration: number,\n    tags: Record<string, string> = {}\n  ): void {\n    this.recordMetric('navigation_time', duration, 'ms', {\n      from,\n      to,\n      ...tags,\n    });\n  }\n\n  /**\n   * Get metrics for a specific name\n   */\n  getMetrics(name: string, limit: number = 100): PerformanceMetric[] {\n    const metricList = this.metrics.get(name) || [];\n    return metricList.slice(-limit);\n  }\n\n  /**\n   * Get all metrics\n   */\n  getAllMetrics(): Map<string, PerformanceMetric[]> {\n    return new Map(this.metrics);\n  }\n\n  /**\n   * Get aggregated metrics\n   */\n  getAggregatedMetrics(\n    name: string,\n    period: number = 300000\n  ): {\n    // 5 minutes\n    avg: number;\n    min: number;\n    max: number;\n    count: number;\n    p95: number;\n    p99: number;\n  } {\n    const cutoff = new Date(Date.now() - period);\n    const metricList = this.metrics.get(name) || [];\n    const recentMetrics = metricList.filter((m) => m.timestamp > cutoff);\n\n    if (recentMetrics.length === 0) {\n      return { avg: 0, min: 0, max: 0, count: 0, p95: 0, p99: 0 };\n    }\n\n    const values = recentMetrics.map((m) => m.value).sort((a, b) => a - b);\n    const sum = values.reduce((a, b) => a + b, 0);\n\n    return {\n      avg: sum / values.length,\n      min: values[0],\n      max: values[values.length - 1],\n      count: values.length,\n      p95: values[Math.floor(values.length * 0.95)],\n      p99: values[Math.floor(values.length * 0.99)],\n    };\n  }\n\n  /**\n   * Get system health status\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    const checks = await Promise.all(\n      this.healthChecks.map(async (check) => {\n        const checkStart = Date.now();\n        try {\n          const result = await check();\n          return {\n            ...result,\n            duration: Date.now() - checkStart,\n          };\n        } catch (error) {\n          return {\n            name: 'unknown',\n            status: 'fail' as const,\n            message: error instanceof Error ? error.message : 'Unknown error',\n            duration: Date.now() - checkStart,\n          };\n        }\n      })\n    );\n\n    const failedChecks = checks.filter((c) => c.status === 'fail').length;\n    const warningChecks = checks.filter((c) => c.status === 'warn').length;\n    const totalChecks = checks.length;\n\n    let status: 'healthy' | 'degraded' | 'critical' = 'healthy';\n    if (failedChecks > 0) {\n      status = failedChecks > totalChecks / 2 ? 'critical' : 'degraded';\n    } else if (warningChecks > 0) {\n      status = 'degraded';\n    }\n\n    const score = Math.max(0, 100 - failedChecks * 50 - warningChecks * 25);\n\n    // Get current metrics\n    const responseTime = this.getAggregatedMetrics('response_time').avg;\n    const errorRate = this.getAggregatedMetrics('error_rate').avg;\n    const throughput = this.getAggregatedMetrics('throughput').avg;\n\n    return {\n      status,\n      score,\n      checks,\n      metrics: {\n        cpu: 0, // Would be populated by system monitoring\n        memory: this.getAggregatedMetrics('memory_usage').avg,\n        responseTime,\n        errorRate,\n        throughput,\n      },\n      lastUpdated: new Date(),\n    };\n  }\n\n  /**\n   * Get active alerts\n   */\n  getActiveAlerts(): PerformanceAlert[] {\n    return this.alerts.filter((alert) => !alert.resolved);\n  }\n\n  /**\n   * Resolve an alert\n   */\n  resolveAlert(alertId: string): void {\n    const alert = this.alerts.find((a) => a.id === alertId);\n    if (alert) {\n      alert.resolved = true;\n      alert.resolvedAt = new Date();\n      logger.info(`Alert resolved: ${alertId}`, alert);\n    }\n  }\n\n  /**\n   * Add a health check\n   */\n  addHealthCheck(\n    check: () => Promise<{\n      name: string;\n      status: 'pass' | 'fail' | 'warn';\n      message: string;\n      duration: number;\n    }>\n  ): void {\n    this.healthChecks.push(check);\n  }\n\n  /**\n   * Set performance thresholds\n   */\n  setThresholds(thresholds: PerformanceThreshold[]): void {\n    this.thresholds = thresholds;\n    logger.info('Performance thresholds updated', { thresholds });\n  }\n\n  /**\n   * Check thresholds for a metric\n   */\n  private checkThresholds(metric: PerformanceMetric): void {\n    const relevantThresholds = this.thresholds.filter(\n      (t) => t.metric === metric.name\n    );\n\n    for (const threshold of relevantThresholds) {\n      let shouldAlert = false;\n      let severity: 'warning' | 'critical' = 'warning';\n\n      switch (threshold.operator) {\n        case 'gt':\n          shouldAlert = metric.value > threshold.warning;\n          severity = metric.value > threshold.critical ? 'critical' : 'warning';\n          break;\n        case 'lt':\n          shouldAlert = metric.value < threshold.warning;\n          severity = metric.value < threshold.critical ? 'critical' : 'warning';\n          break;\n        case 'gte':\n          shouldAlert = metric.value >= threshold.warning;\n          severity =\n            metric.value >= threshold.critical ? 'critical' : 'warning';\n          break;\n        case 'lte':\n          shouldAlert = metric.value <= threshold.warning;\n          severity =\n            metric.value <= threshold.critical ? 'critical' : 'warning';\n          break;\n        case 'eq':\n          shouldAlert = metric.value === threshold.warning;\n          severity =\n            metric.value === threshold.critical ? 'critical' : 'warning';\n          break;\n      }\n\n      if (shouldAlert) {\n        this.createAlert(metric, threshold, severity);\n      }\n    }\n  }\n\n  /**\n   * Create a performance alert\n   */\n  private createAlert(\n    metric: PerformanceMetric,\n    threshold: PerformanceThreshold,\n    severity: 'warning' | 'critical'\n  ): void {\n    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const alert: PerformanceAlert = {\n      id: alertId,\n      metric: metric.name,\n      value: metric.value,\n      threshold: threshold.warning,\n      severity,\n      message: `${metric.name} ${threshold.operator} ${threshold.warning} (current: ${metric.value})`,\n      timestamp: new Date(),\n      resolved: false,\n    };\n\n    // Check if similar alert already exists\n    const existingAlert = this.alerts.find(\n      (a) =>\n        a.metric === alert.metric &&\n        a.severity === alert.severity &&\n        !a.resolved &&\n        Date.now() - a.timestamp.getTime() < 300000 // 5 minutes\n    );\n\n    if (!existingAlert) {\n      this.alerts.push(alert);\n      logger.warn(`Performance alert: ${alert.message}`, alert);\n      this.notifyAlertSubscribers(alert);\n    }\n  }\n\n  /**\n   * Initialize default thresholds\n   */\n  private initializeDefaultThresholds(): void {\n    this.thresholds = [\n      {\n        metric: 'response_time',\n        warning: 1000,\n        critical: 5000,\n        operator: 'gt',\n      },\n      {\n        metric: 'component_mount_time',\n        warning: 1000,\n        critical: 3000,\n        operator: 'gt',\n      },\n      {\n        metric: 'authentication_time',\n        warning: 2000,\n        critical: 5000,\n        operator: 'gt',\n      },\n      {\n        metric: 'data_fetch_time',\n        warning: 2000,\n        critical: 5000,\n        operator: 'gt',\n      },\n      {\n        metric: 'navigation_time',\n        warning: 1000,\n        critical: 3000,\n        operator: 'gt',\n      },\n      {\n        metric: 'error_rate',\n        warning: 5,\n        critical: 10,\n        operator: 'gt',\n      },\n      {\n        metric: 'memory_usage',\n        warning: 200 * 1024 * 1024, // 200MB\n        critical: 500 * 1024 * 1024, // 500MB\n        operator: 'gt',\n      },\n    ];\n  }\n\n  /**\n   * Initialize default health checks\n   */\n  private initializeHealthChecks(): void {\n    // Database connectivity check\n    this.addHealthCheck(async () => {\n      try {\n        const start = Date.now();\n        // This would be a real database ping\n        const duration = Date.now() - start;\n        return {\n          name: 'database',\n          status: 'pass',\n          message: 'Database connection healthy',\n          duration,\n        };\n      } catch (err) { console.error(err); throw err; }\n        return {\n          name: 'database',\n          status: 'fail',\n          message: 'Database connection failed',\n          duration: 0,\n        };\n      }\n    });\n\n    // Memory usage check\n    this.addHealthCheck(async () => {\n      try {\n        const memoryUsage = this.getAggregatedMetrics('memory_usage');\n        const isHealthy = memoryUsage.avg < 200 * 1024 * 1024; // 200MB\n        return {\n          name: 'memory',\n          status: isHealthy ? 'pass' : 'warn',\n          message: `Memory usage: ${Math.round(memoryUsage.avg / 1024 / 1024)}MB`,\n          duration: 0,\n        };\n      } catch (err) { console.error(err); throw err; }\n        return {\n          name: 'memory',\n          status: 'fail',\n          message: 'Memory check failed',\n          duration: 0,\n        };\n      }\n    });\n  }\n\n  /**\n   * Start continuous monitoring\n   */\n  private startContinuousMonitoring(): void {\n    if (this.isMonitoring) return;\n\n    // Only start monitoring in production or when explicitly enabled\n    const isDevelopment = import.meta.env.DEV;\n    const enableMonitoring =\n      import.meta.env.VITE_ENABLE_PERFORMANCE_MONITORING === 'true';\n\n    if (isDevelopment && !enableMonitoring) {\n      console.log('Performance monitoring disabled in development mode');\n      return;\n    }\n\n    this.isMonitoring = true;\n    this.monitoringInterval = setInterval(() => {\n      this.capturePerformanceSnapshot();\n    }, 30000); // Capture snapshot every 30 seconds\n  }\n\n  /**\n   * Stop continuous monitoring\n   */\n  stopMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n    this.isMonitoring = false;\n  }\n\n  /**\n   * Capture a performance snapshot\n   */\n  private async capturePerformanceSnapshot(): Promise<void> {\n    try {\n      const health = await this.getSystemHealth();\n      const activeAlerts = this.getActiveAlerts();\n\n      const snapshot: PerformanceSnapshot = {\n        timestamp: new Date(),\n        metrics: new Map(),\n        health,\n        alerts: activeAlerts,\n      };\n\n      // Capture current metrics\n      for (const [metricName, metrics] of Array.from(this.metrics.entries())) {\n        if (metrics.length > 0) {\n          const latest = metrics[metrics.length - 1];\n          snapshot.metrics.set(metricName, latest.value);\n        }\n      }\n\n      // Store snapshot\n      const key = 'performance_snapshot';\n      if (!this.performanceHistory.has(key)) {\n        this.performanceHistory.set(key, []);\n      }\n\n      const history = this.performanceHistory.get(key)!;\n      history.push(snapshot);\n\n      // Keep only last 100 snapshots\n      if (history.length > 100) {\n        history.splice(0, history.length - 100);\n      }\n\n      logger.debug('Performance snapshot captured', {\n        timestamp: snapshot.timestamp,\n        metricsCount: snapshot.metrics.size,\n        alertsCount: activeAlerts.length,\n      });\n    } catch (error) {\n      logger.error('Failed to capture performance snapshot:', error);\n    }\n  }\n\n  /**\n   * Get performance trends\n   */\n  getPerformanceTrends(\n    metricName: string,\n    period: number = 300000\n  ): PerformanceTrend[] {\n    const trends: PerformanceTrend[] = [];\n    const cutoff = new Date(Date.now() - period);\n    const metricList = this.metrics.get(metricName) || [];\n    const recentMetrics = metricList.filter((m) => m.timestamp > cutoff);\n\n    if (recentMetrics.length < 2) {\n      return trends;\n    }\n\n    const values = recentMetrics.map((m) => m.value);\n    const firstHalf = values.slice(0, Math.floor(values.length / 2));\n    const secondHalf = values.slice(Math.floor(values.length / 2));\n\n    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n    const changePercent = ((secondAvg - firstAvg) / firstAvg) * 100;\n\n    let trend: 'improving' | 'stable' | 'degrading' = 'stable';\n    if (Math.abs(changePercent) > 10) {\n      trend = changePercent < 0 ? 'improving' : 'degrading';\n    }\n\n    trends.push({\n      metric: metricName,\n      trend,\n      changePercent: Math.round(changePercent * 100) / 100,\n      period: `${Math.round(period / 60000)} minutes`,\n    });\n\n    return trends;\n  }\n\n  /**\n   * Get performance insights\n   */\n  getPerformanceInsights(): PerformanceInsight[] {\n    const insights: PerformanceInsight[] = [];\n    const health = this.getSystemHealthSync();\n\n    // Check for critical issues\n    if (health.status === 'critical') {\n      insights.push({\n        type: 'critical',\n        title: 'System Critical',\n        description: 'System is in critical state with multiple failures',\n        impact: 'high',\n        recommendations: [\n          'Check system resources immediately',\n          'Review error logs for root cause',\n          'Consider scaling resources',\n        ],\n      });\n    }\n\n    // Check for performance degradation\n    const responseTimeTrend = this.getPerformanceTrends('response_time')[0];\n    if (responseTimeTrend && responseTimeTrend.trend === 'degrading') {\n      insights.push({\n        type: 'warning',\n        title: 'Response Time Degradation',\n        description: `Response time has increased by ${responseTimeTrend.changePercent}%`,\n        impact: 'medium',\n        recommendations: [\n          'Optimize database queries',\n          'Check for memory leaks',\n          'Review caching strategies',\n        ],\n      });\n    }\n\n    // Check for memory issues\n    const memoryTrend = this.getPerformanceTrends('memory_usage')[0];\n    if (memoryTrend && memoryTrend.trend === 'degrading') {\n      insights.push({\n        type: 'warning',\n        title: 'Memory Usage Increasing',\n        description: `Memory usage has increased by ${memoryTrend.changePercent}%`,\n        impact: 'medium',\n        recommendations: [\n          'Check for memory leaks',\n          'Optimize data structures',\n          'Consider garbage collection tuning',\n        ],\n      });\n    }\n\n    // Check for optimization opportunities\n    const avgResponseTime = this.getAggregatedMetrics('response_time').avg;\n    if (avgResponseTime > 1000) {\n      insights.push({\n        type: 'optimization',\n        title: 'Response Time Optimization',\n        description: `Average response time is ${avgResponseTime.toFixed(2)}ms`,\n        impact: 'low',\n        recommendations: [\n          'Implement response caching',\n          'Optimize API endpoints',\n          'Consider CDN implementation',\n        ],\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Subscribe to performance alerts\n   */\n  subscribeToAlerts(callback: (alert: PerformanceAlert) => void): () => void {\n    this.alertSubscribers.push(callback);\n\n    // Return unsubscribe function\n    return () => {\n      const index = this.alertSubscribers.indexOf(callback);\n      if (index > -1) {\n        this.alertSubscribers.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Get performance history\n   */\n  getPerformanceHistory(metricName?: string): PerformanceSnapshot[] {\n    if (metricName) {\n      return this.performanceHistory.get(metricName) || [];\n    }\n    return this.performanceHistory.get('performance_snapshot') || [];\n  }\n\n  /**\n   * Get system health synchronously (cached)\n   */\n  private getSystemHealthSync(): SystemHealth {\n    const responseTime = this.getAggregatedMetrics('response_time').avg;\n    const errorRate = this.getAggregatedMetrics('error_rate').avg;\n    const memory = this.getAggregatedMetrics('memory_usage').avg;\n\n    // Simple health calculation\n    let score = 100;\n    if (responseTime > 1000) score -= 20;\n    if (errorRate > 5) score -= 30;\n    if (memory > 500 * 1024 * 1024) score -= 20;\n\n    let status: 'healthy' | 'degraded' | 'critical' = 'healthy';\n    if (score < 50) status = 'critical';\n    else if (score < 80) status = 'degraded';\n\n    return {\n      status,\n      score: Math.max(0, score),\n      checks: [],\n      metrics: {\n        cpu: 0,\n        memory,\n        responseTime,\n        errorRate,\n        throughput: this.getAggregatedMetrics('throughput').avg,\n      },\n      lastUpdated: new Date(),\n    };\n  }\n\n  /**\n   * Notify alert subscribers\n   */\n  private notifyAlertSubscribers(alert: PerformanceAlert): void {\n    this.alertSubscribers.forEach((callback) => {\n      try {\n        callback(alert);\n      } catch (error) {\n        logger.error('Error in alert subscriber:', error);\n      }\n    });\n  }\n}\n\n// Singleton instance\nexport const performanceMonitor = PerformanceMonitor.getInstance();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\packagingService.ts",
    "messages": [
      {
        "ruleId": "no-inner-declarations",
        "severity": 2,
        "message": "Move function declaration to function body root.",
        "line": 211,
        "column": 7,
        "nodeType": "FunctionDeclaration",
        "messageId": "moveDeclToRoot",
        "endLine": 215,
        "endColumn": 8
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\nimport { useLoginStore } from '../stores/useLoginStore';\nimport { SupabaseAuthService } from './supabase/authService';\nimport { ToolService } from './tools/ToolService';\n\n/**\n * Safe type conversion utilities to prevent data loss\n */\nconst safeString = (value: unknown): string => {\n  return typeof value === 'string' ? value : '';\n};\n\nconst safeNumber = (value: unknown): number => {\n  return typeof value === 'number' ? value : 0;\n};\n\nconst safeBoolean = (value: unknown): boolean => {\n  return typeof value === 'boolean' ? value : false;\n};\n\nconst safeDate = (value: unknown): Date | undefined => {\n  if (typeof value === 'string') {\n    const date = new Date(value);\n    return isNaN(date.getTime()) ? undefined : date;\n  }\n  return undefined;\n};\n\nexport interface PackageInfo {\n  packageType: string;\n  packageSize: string;\n  notes: string;\n}\n\nexport interface Tool {\n  id: string;\n  name: string;\n  barcode: string;\n  type: string;\n  category: string;\n  currentPhase: string;\n  status: 'available' | 'maintenance' | 'retired' | 'in_cycle' | 'problem';\n  lastSterilized?: string;\n  sterilizationCount: number;\n  cycleCount: number;\n  location: string;\n  manufacturer: string;\n  model: string;\n  serialNumber: string;\n  maintenanceDueDate: Date | null;\n  notes: string;\n  metadata: Record<string, unknown>;\n}\n\nexport interface SterilizationBatch {\n  id: string;\n  packageId: string;\n  batchName: string;\n  batchType: string;\n  status: string;\n  packageType: string;\n  packageSize: string;\n  chemicalIndicatorAdded: boolean;\n  packagedBy: string;\n  packagedAt: Date;\n  totalItems: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface PackagingResult {\n  success: boolean;\n  message: string;\n  batch?: SterilizationBatch;\n  packageId?: string;\n}\n\nexport class PackagingService {\n  /**\n   * Get tools ready for packaging (completed sterilization)\n   */\n  static async getToolsReadyForPackaging(): Promise<Tool[]> {\n    const maxRetries = 3;\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        // Get current user from custom auth store\n        const authToken = useLoginStore.getState().authToken;\n        if (!authToken) {\n          if (attempt < maxRetries) {\n            // Wait before retrying (exponential backoff)\n            await new Promise((resolve) => setTimeout(resolve, attempt * 500));\n            continue;\n          }\n          throw new Error('User not authenticated');\n        }\n\n        // Get current user and facility from Supabase\n        const {\n          data: { user },\n          error: authError,\n        } = await supabase.auth.getUser();\n        if (authError || !user) {\n          throw new Error('User not authenticated');\n        }\n\n        // Get user's facility ID from users table\n        const { data: userData, error: userError } = await supabase\n          .from('users')\n          .select('facility_id')\n          .eq('id', user.id)\n          .single();\n\n        if (userError || !userData) {\n          throw new Error('User facility not found');\n        }\n\n        // Get tools ready for packaging using real facility ID\n        const { data: tools, error } = await supabase\n          .from('tools')\n          .select('*')\n          .eq('facility_id', userData.facility_id)\n          .eq('status', 'ready_for_packaging');\n\n        if (error) {\n          throw new Error(`Failed to fetch tools: ${error.message}`);\n        }\n\n        const typedTools = tools as Record<string, unknown>[] | null;\n\n        return (typedTools || []).map((tool) => {\n          const typedTool = tool as Record<string, unknown>;\n          return {\n            id: safeString(typedTool.tool_id),\n            name: safeString(typedTool.tool_name),\n            barcode: safeString(typedTool.barcode),\n            type: safeString(typedTool.tool_type),\n            category: safeString(typedTool.category) || 'general',\n            currentPhase: safeString(typedTool.current_phase),\n            status:\n              (safeString(typedTool.current_phase) as\n                | 'available'\n                | 'maintenance'\n                | 'retired'\n                | 'in_cycle'\n                | 'problem') || 'available',\n            lastSterilized: safeString(typedTool.last_sterilized) || undefined,\n            sterilizationCount: safeNumber(typedTool.sterilization_count),\n            cycleCount: safeNumber(typedTool.cycle_count),\n            location: '',\n            manufacturer: '',\n            model: '',\n            serialNumber: '',\n            maintenanceDueDate: null,\n            notes: '',\n            metadata: {},\n          };\n        });\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Unknown error');\n\n        // If this is the last attempt, throw the error\n        if (attempt === maxRetries) {\n          console.error(\n            `Error fetching tools ready for packaging (attempt ${attempt}/${maxRetries}):`,\n            error\n          );\n          throw lastError;\n        }\n\n        // Wait before retrying\n        await new Promise((resolve) => setTimeout(resolve, attempt * 500));\n      }\n    }\n\n    // This should never be reached, but just in case\n    throw lastError || new Error('Failed to fetch tools after all retries');\n  }\n\n  /**\n   * Create a new package with tools\n   */\n  static async createPackage(\n    toolIds: string[],\n    packageInfo: PackageInfo,\n    operatorName: string\n  ): Promise<PackagingResult> {\n    try {\n      // Get current user from custom auth store\n      const authToken = useLoginStore.getState().authToken;\n      if (!authToken) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get current user's facility ID and user ID\n      const { FacilityService } = await import('@/services/facilityService');\n      const facilityId = await FacilityService.getCurrentFacilityId();\n\n      // Get current user ID from auth\n      const {\n        data: { user },\n        error: authError,\n      } = await supabase.auth.getUser();\n      if (authError || !user) {\n        throw new Error('User not authenticated');\n      }\n      const userId = user.id;\n\n      // Generate unique package ID\n      function generatePackageId(facility_id: string): string {\n        const timestamp = Date.now().toString(36).toUpperCase();\n        const shortId = Math.random().toString(36).substr(2, 4).toUpperCase();\n        return `PKG-${facility_id.slice(0, 4).toUpperCase()}-${timestamp}-${shortId}`;\n      }\n\n      const packageId = generatePackageId(facilityId);\n\n      // Create the batch/package\n      const { data: batch, error: batchError } = await supabase\n        .from('sterilization_batches')\n        .insert({\n          facility_id: facilityId,\n          batch_name: `Package ${packageId}`,\n          batch_type: 'routine',\n          status: 'packaged',\n          package_id: packageId,\n          package_type: packageInfo.packageType,\n          package_size: packageInfo.packageSize,\n          chemical_indicator_added: true, // Assuming CI is always added\n          packaged_by: userId,\n          packaged_at: new Date().toISOString(),\n          total_items: toolIds.length,\n          notes: packageInfo.notes,\n        })\n        .select()\n        .single();\n\n      if (batchError) {\n        throw new Error(`Failed to create package: ${batchError.message}`);\n      }\n\n      const typedBatch = batch as Record<string, unknown>;\n\n      // Add tools to the batch\n      const batchItems = toolIds.map((toolId) => ({\n        batch_id: typedBatch.id as string,\n        tool_id: toolId,\n        item_name: 'Tool', // Will be updated with actual tool name\n        item_type: 'sterilization_tool',\n        quantity: 1,\n        package_type: packageInfo.packageType,\n        package_configuration: {\n          package_size: packageInfo.packageSize,\n          notes: packageInfo.notes,\n        },\n      }));\n\n      const { error: itemsError } = await supabase\n        .from('sterilization_batches')\n        .insert(batchItems);\n\n      if (itemsError) {\n        // Clean up the batch if adding items fails\n        await supabase\n          .from('sterilization_batches')\n          .delete()\n          .eq('id', typedBatch.id as string);\n        throw new Error(\n          `Failed to add tools to package: ${itemsError.message}`\n        );\n      }\n\n      // Update tool status to indicate they're packaged\n      // Update status using ToolService for each tool\n      const toolUpdatePromises = toolIds.map((toolId) =>\n        ToolService.updateToolStatus(toolId, 'in_cycle')\n      );\n      await Promise.all(toolUpdatePromises);\n\n      // Update additional fields that ToolService doesn't handle yet\n      await ToolService.touchTools(toolIds);\n\n      // Get current user and facility from auth service\n      const { user: currentUser } = await SupabaseAuthService.getCurrentUser();\n      const currentFacility = currentUser\n        ? { id: currentUser.facility_id }\n        : null;\n\n      // Create audit log entry\n      await supabase.from('audit_logs').insert({\n        user_id: currentUser?.id || 'unknown',\n        facility_id: currentFacility?.id || 'unknown',\n        module: 'sterilization',\n        action: 'package_created',\n        table_name: 'sterilization_batches',\n        record_id: typedBatch.id as string,\n        old_values: {},\n        new_values: {\n          package_id: packageId,\n          package_type: packageInfo.packageType,\n          total_items: toolIds.length,\n          status: 'packaged',\n        },\n        metadata: {\n          package_id: packageId,\n          tool_count: toolIds.length,\n          operator_name: operatorName,\n          package_info: packageInfo,\n        },\n      });\n\n      const sterilizationBatch: SterilizationBatch = {\n        id: safeString(typedBatch.id),\n        packageId: safeString(typedBatch.package_id),\n        batchName: safeString(typedBatch.batch_name),\n        batchType: safeString(typedBatch.batch_type),\n        status: safeString(typedBatch.status),\n        packageType: safeString(typedBatch.package_type),\n        packageSize: safeString(typedBatch.package_size),\n        chemicalIndicatorAdded: safeBoolean(\n          typedBatch.chemical_indicator_added\n        ),\n        packagedBy: safeString(typedBatch.packaged_by),\n        packagedAt: safeDate(typedBatch.packaged_at) || new Date(),\n        totalItems: safeNumber(typedBatch.total_items),\n        createdAt: safeDate(typedBatch.created_at) || new Date(),\n        updatedAt: safeDate(typedBatch.updated_at) || new Date(),\n      };\n\n      return {\n        success: true,\n        message: `Package ${packageId} created successfully with ${toolIds.length} tools`,\n        batch: sterilizationBatch,\n        packageId: safeString(packageId),\n      };\n    } catch (error) {\n      console.error('Error creating package:', error);\n      return {\n        success: false,\n        message:\n          error instanceof Error ? error.message : 'Failed to create package',\n      };\n    }\n  }\n\n  /**\n   * Get package by ID\n   */\n  static async getPackageById(\n    packageId: string\n  ): Promise<SterilizationBatch | null> {\n    try {\n      const { data: batch, error } = await supabase\n        .from('sterilization_batches')\n        .select('*')\n        .eq('package_id', packageId)\n        .single();\n\n      if (error || !batch) {\n        return null;\n      }\n\n      const typedBatch = batch as Record<string, unknown>;\n\n      return {\n        id: safeString(typedBatch.id),\n        packageId: safeString(typedBatch.package_id),\n        batchName: safeString(typedBatch.batch_name),\n        batchType: safeString(typedBatch.batch_type),\n        status: safeString(typedBatch.status),\n        packageType: safeString(typedBatch.package_type),\n        packageSize: safeString(typedBatch.package_size),\n        chemicalIndicatorAdded: safeBoolean(\n          typedBatch.chemical_indicator_added\n        ),\n        packagedBy: safeString(typedBatch.packaged_by),\n        packagedAt: safeDate(typedBatch.packaged_at) || new Date(),\n        totalItems: safeNumber(typedBatch.total_items),\n        createdAt: safeDate(typedBatch.created_at) || new Date(),\n        updatedAt: safeDate(typedBatch.updated_at) || new Date(),\n      };\n    } catch (error) {\n      console.error('Error fetching package:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get tools in a package\n   */\n  static async getToolsInPackage(packageId: string): Promise<Tool[]> {\n    try {\n      const { data: batch, error: batchError } = await supabase\n        .from('sterilization_batches')\n        .select('id')\n        .eq('package_id', packageId)\n        .single();\n\n      if (batchError || !batch) {\n        throw new Error('Package not found');\n      }\n\n      const typedBatch = batch as Record<string, unknown>;\n\n      const { data: batchItems, error: itemsError } = await supabase\n        .from('sterilization_batches')\n        .select(\n          `\n          tool_id,\n          sterilization_tools (\n            id,\n            tool_name,\n            barcode,\n            tool_type,\n            status,\n            last_sterilized,\n            sterilization_count,\n            location,\n            manufacturer,\n            model,\n            serial_number,\n            maintenance_due_date,\n            notes,\n            metadata\n          )\n        `\n        )\n        .eq('batch_id', typedBatch.id as string);\n\n      if (itemsError) {\n        throw new Error(`Failed to fetch package tools: ${itemsError.message}`);\n      }\n\n      return (batchItems || []).map((item) => {\n        const typedItem = item as Record<string, unknown>;\n        const tool = typedItem.sterilization_tools as Record<\n          string,\n          unknown\n        > | null;\n\n        if (!tool) {\n          throw new Error('Tool data not found');\n        }\n\n        return {\n          id: tool.id as string,\n          name: tool.tool_name as string,\n          barcode: tool.barcode as string,\n          type: tool.tool_type as string,\n          category: (tool.category as string) || 'general',\n          currentPhase: tool.status as string,\n          status:\n            (tool.status as\n              | 'available'\n              | 'maintenance'\n              | 'retired'\n              | 'in_cycle'\n              | 'problem') || 'available',\n          location: tool.location as string,\n          manufacturer: tool.manufacturer as string,\n          model: tool.model as string,\n          serialNumber: tool.serial_number as string,\n          sterilizationCount: (tool.sterilization_count as number) || 0,\n          cycleCount: (tool.cycle_count as number) || 0,\n          lastSterilized: tool.last_sterilized as string | undefined,\n          maintenanceDueDate: tool.maintenance_due_date\n            ? new Date(tool.maintenance_due_date as string)\n            : null,\n          notes: (tool.notes as string) || '',\n          metadata: (tool.metadata as Record<string, unknown>) || {},\n        };\n      });\n    } catch (error) {\n      console.error('Error fetching package tools:', error);\n      throw error;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\rateLimitService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\rateLimiting\\AIRateLimiter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\rateLimiting\\DistributedRateLimiter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\realtimeCleanupService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\realtimeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\realtime\\SubscriptionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\retry\\OptimizedRetryService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\secureAuthService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ',' expected.",
        "line": 133,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport {\n  sanitizeInput,\n  detectSuspiciousInput,\n  generateSecureToken,\n  csrfProtection,\n} from '@/utils/securityUtils';\n\n// Helper function to validate password strength\nconst validatePasswordStrength = (\n  password: string\n): { isValid: boolean; score: number; feedback: string[] } => {\n  const feedback: string[] = [];\n  let score = 0;\n\n  if (password.length >= 8) score += 1;\n  else feedback.push('Password must be at least 8 characters long');\n\n  if (/[a-z]/.test(password)) score += 1;\n  else feedback.push('Password must contain at least one lowercase letter');\n\n  if (/[A-Z]/.test(password)) score += 1;\n  else feedback.push('Password must contain at least one uppercase letter');\n\n  if (/\\d/.test(password)) score += 1;\n  else feedback.push('Password must contain at least one number');\n\n  if (/[^A-Za-z0-9]/.test(password)) score += 1;\n  else feedback.push('Password must contain at least one special character');\n\n  return {\n    isValid: score >= 4,\n    score,\n    feedback,\n  };\n};\nimport { isDevelopment } from '@/lib/getEnv';\n\ninterface Session {\n  id: string;\n  createdAt: number;\n  expiresAt: number;\n  userId: string;\n}\n\ninterface User {\n  id: string;\n  email: string;\n  role?: string;\n}\n\nexport interface SecureLoginCredentials {\n  email: string;\n  password: string;\n  csrfToken?: string;\n  rememberMe?: boolean;\n  deviceFingerprint?: string;\n}\n\nexport interface SecureLoginResponse {\n  success: boolean;\n  session?: Session;\n  user?: User;\n  error?: string;\n  securityWarnings?: string[];\n  requiresMFA?: boolean;\n  mfaToken?: string;\n}\n\nexport interface SecurityAuditLog {\n  event: string;\n  userId?: string;\n  email: string;\n  ipAddress?: string;\n  userAgent: string;\n  timestamp: string;\n  success: boolean;\n  securityFlags: string[];\n  metadata: Record<string, unknown>;\n}\n\nclass SecureAuthService {\n  private rateLimiter: Map<\n    string,\n    { attempts: number; lastAttempt: number; blocked: boolean }\n  > = new Map();\n  private sessionStore = new Map<\n    string,\n    { session: Session; lastActivity: number }\n  >();\n  private readonly SESSION_TIMEOUT = 8 * 60 * 60 * 1000; // 8 hours\n  private readonly INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n  private readonly MAX_LOGIN_ATTEMPTS = 5;\n  private readonly RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes\n  private readonly BLOCK_DURATION = 30 * 60 * 1000; // 30 minutes\n  private cleanupInterval: NodeJS.Timeout | null = null;\n  private isInitialized = false;\n\n  constructor() {\n    this.initialize();\n  }\n\n  /**\n   * Initialize the service with proper cleanup and SSR safety\n   */\n  private initialize(): void {\n    if (this.isInitialized) return;\n\n    // Only initialize cleanup in browser environment\n    if (typeof window !== 'undefined') {\n      this.startCleanupInterval();\n    }\n\n    this.isInitialized = true;\n  }\n\n  /**\n   * Start cleanup interval with proper error handling\n   */\n  private startCleanupInterval(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    this.cleanupInterval = setInterval(\n      () => {\n        try {\n          this.cleanupExpiredSessions();\n          this.cleanupRateLimiter();\n        } catch (err) { console.error(err); throw err; }\n          console.error('Cleanup interval error');\n        }\n      },\n      5 * 60 * 1000\n    ); // 5 minutes\n  }\n\n  /**\n   * Clean up rate limiter data\n   */\n  private cleanupRateLimiter(): void {\n    const now = Date.now();\n    for (const [key, data] of this.rateLimiter.entries()) {\n      if (now - data.lastAttempt > this.RATE_LIMIT_WINDOW) {\n        this.rateLimiter.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Check if rate limiting allows the request\n   */\n  private isRateLimitAllowed(identifier: string): boolean {\n    const now = Date.now();\n    const data = this.rateLimiter.get(identifier);\n\n    if (!data) return true;\n\n    // Check if still blocked\n    if (data.blocked && now - data.lastAttempt < this.BLOCK_DURATION) {\n      return false;\n    }\n\n    // Reset if block period expired\n    if (data.blocked && now - data.lastAttempt >= this.BLOCK_DURATION) {\n      this.rateLimiter.delete(identifier);\n      return true;\n    }\n\n    // Check if within rate limit window\n    if (now - data.lastAttempt < this.RATE_LIMIT_WINDOW) {\n      return data.attempts < this.MAX_LOGIN_ATTEMPTS;\n    }\n\n    // Reset if outside rate limit window\n    this.rateLimiter.delete(identifier);\n    return true;\n  }\n\n  /**\n   * Record a rate limit attempt\n   */\n  private recordRateLimitAttempt(identifier: string): void {\n    const now = Date.now();\n    const data = this.rateLimiter.get(identifier);\n\n    if (data) {\n      data.attempts++;\n      data.lastAttempt = now;\n      if (data.attempts >= this.MAX_LOGIN_ATTEMPTS) {\n        data.blocked = true;\n      }\n    } else {\n      this.rateLimiter.set(identifier, {\n        attempts: 1,\n        lastAttempt: now,\n        blocked: false,\n      });\n    }\n  }\n\n  /**\n   * Secure login with comprehensive security checks\n   */\n  async secureLogin(\n    credentials: SecureLoginCredentials\n  ): Promise<SecureLoginResponse> {\n    const startTime = performance.now();\n    const securityWarnings: string[] = [];\n    const securityFlags: string[] = [];\n\n    try {\n      // 1. Input sanitization and validation\n      const sanitizedEmail = sanitizeInput(credentials.email, 'email');\n      if (!sanitizedEmail) {\n        this.logSecurityEvent('login_attempt', credentials.email, false, [\n          'invalid_email_format',\n        ]);\n        return { success: false, error: 'Invalid email format' };\n      }\n\n      // 2. Check for suspicious input\n      const emailThreats = detectSuspiciousInput(credentials.email);\n      const passwordThreats = detectSuspiciousInput(credentials.password);\n\n      if (emailThreats.isSuspicious || passwordThreats.isSuspicious) {\n        const threats = [...emailThreats.threats, ...passwordThreats.threats];\n        this.logSecurityEvent(\n          'login_attempt',\n          credentials.email,\n          false,\n          ['suspicious_input'],\n          {\n            threats,\n          }\n        );\n        return {\n          success: false,\n          error: 'Suspicious input detected',\n          securityWarnings: threats,\n        };\n      }\n\n      // 3. Rate limiting check\n      const rateLimitKey = `${sanitizedEmail}:${await this.getClientIP()}`;\n      if (!this.isRateLimitAllowed(rateLimitKey)) {\n        this.logSecurityEvent('login_attempt', sanitizedEmail, false, [\n          'rate_limited',\n        ]);\n        return {\n          success: false,\n          error: 'Too many login attempts. Please try again later.',\n        };\n      }\n\n      // 4. CSRF protection (if token provided)\n      if (credentials.csrfToken) {\n        const storedToken = csrfProtection.getStoredToken();\n        if (\n          !csrfProtection.validateToken(\n            credentials.csrfToken,\n            storedToken || ''\n          )\n        ) {\n          this.logSecurityEvent('login_attempt', sanitizedEmail, false, [\n            'csrf_violation',\n          ]);\n          return { success: false, error: 'Invalid security token' };\n        }\n      }\n\n      // 5. Password strength validation\n      const passwordValidation = validatePasswordStrength(credentials.password);\n      if (!passwordValidation.isValid) {\n        securityWarnings.push('Weak password detected');\n        securityFlags.push('weak_password');\n      }\n\n      // 6. Attempt authentication with Supabase\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email: sanitizedEmail,\n        password: credentials.password,\n      });\n\n      if (error) {\n        // Record failed attempt\n        this.recordRateLimitAttempt(rateLimitKey);\n\n        // Log security event\n        this.logSecurityEvent(\n          'login_failure',\n          sanitizedEmail,\n          false,\n          ['auth_failed'],\n          {\n            error: error.message,\n            code: error.status,\n          }\n        );\n\n        return { success: false, error: error.message };\n      }\n\n      if (!data.session || !data.user) {\n        this.logSecurityEvent('login_failure', sanitizedEmail, false, [\n          'no_session',\n        ]);\n        return {\n          success: false,\n          error: 'Authentication failed - no session returned',\n        };\n      }\n\n      // 7. Success - record successful login\n      // Reset rate limiter (simplified for now)\n\n      // 8. Session security checks\n      const sessionId = generateSecureToken(16);\n\n      // Store session securely\n      this.sessionStore.set(sessionId, {\n        session: {\n          id: sessionId,\n          createdAt: Date.now(),\n          expiresAt: Date.now() + this.SESSION_TIMEOUT,\n          userId: data.user?.id || '',\n        },\n        lastActivity: Date.now(),\n      });\n\n      // 9. Check if MFA is required\n      const requiresMFA = await this.checkMFARequirement();\n      if (requiresMFA) {\n        const mfaToken = generateSecureToken(32);\n        // Store MFA token temporarily\n        this.sessionStore.set(mfaToken, {\n          session: {\n            id: mfaToken,\n            createdAt: Date.now(),\n            expiresAt: Date.now() + this.SESSION_TIMEOUT,\n            userId: data.user?.id || '',\n          },\n          lastActivity: Date.now(),\n        });\n\n        this.logSecurityEvent(\n          'login_success',\n          sanitizedEmail,\n          true,\n          ['mfa_required'],\n          {\n            sessionId,\n            requiresMFA: true,\n          }\n        );\n\n        return {\n          success: true,\n          requiresMFA: true,\n          mfaToken,\n          securityWarnings,\n        };\n      }\n\n      // 10. Log successful login\n      this.logSecurityEvent(\n        'login_success',\n        sanitizedEmail,\n        true,\n        securityFlags,\n        {\n          sessionId,\n          loginTime: performance.now() - startTime,\n          requiresMFA: false,\n        }\n      );\n\n      return {\n        success: true,\n        session: {\n          id: sessionId,\n          createdAt: Date.now(),\n          expiresAt: Date.now() + this.SESSION_TIMEOUT,\n          userId: data.user?.id || '',\n        },\n        user: data.user\n          ? {\n              id: data.user.id,\n              email: data.user.email || '',\n              role: data.user.role,\n            }\n          : undefined,\n        securityWarnings,\n      };\n    } catch (error) {\n      console.error('Secure login error:', error);\n      this.logSecurityEvent(\n        'login_error',\n        credentials.email,\n        false,\n        ['unexpected_error'],\n        {\n          error,\n        }\n      );\n\n      return {\n        success: false,\n        error: 'An unexpected error occurred during login',\n        securityWarnings,\n      };\n    }\n  }\n\n  /**\n   * Verify MFA token and complete authentication\n   */\n  async verifyMFA(\n    mfaToken: string,\n    mfaCode: string\n  ): Promise<SecureLoginResponse> {\n    try {\n      const sessionData = this.sessionStore.get(mfaToken);\n      if (!sessionData) {\n        return { success: false, error: 'Invalid or expired MFA token' };\n      }\n\n      // Verify MFA code (implement your MFA verification logic here)\n      const isValidMFA = await this.verifyMFACode(mfaCode);\n\n      if (!isValidMFA) {\n        this.logSecurityEvent('mfa_failure', '', false, ['invalid_mfa_code']);\n        return { success: false, error: 'Invalid MFA code' };\n      }\n\n      // MFA successful - complete authentication\n      const sessionId = mfaToken;\n      this.sessionStore.set(sessionId, sessionData);\n      this.sessionStore.delete(mfaToken);\n\n      this.logSecurityEvent('mfa_success', '', true, ['mfa_completed'], {\n        sessionId,\n      });\n\n      return {\n        success: true,\n        session: {\n          id: sessionId,\n          createdAt: Date.now(),\n          expiresAt: Date.now() + this.SESSION_TIMEOUT,\n          userId: sessionData.session.userId,\n        },\n        user: { id: sessionData.session.userId, email: '' }, // Email not available in Session interface\n      };\n    } catch (err) { console.error(err); throw err; }\n      console.error('MFA verification error');\n      return { success: false, error: 'MFA verification failed' };\n    }\n  }\n\n  /**\n   * Secure logout with session cleanup\n   */\n  async secureLogout(sessionId: string): Promise<void> {\n    try {\n      const sessionData = this.sessionStore.get(sessionId);\n      if (sessionData) {\n        // Log logout event\n        this.logSecurityEvent('logout', '', true, ['user_initiated'], {\n          sessionId,\n          sessionAge: Date.now() - sessionData.session.createdAt,\n        });\n\n        // Clean up session\n        this.sessionStore.delete(sessionId);\n\n        // Sign out from Supabase\n        await supabase.auth.signOut();\n      }\n    } catch (err) { console.error(err); throw err; }\n      console.error('Secure logout error');\n    }\n  }\n\n  /**\n   * Validate session and check for security issues\n   */\n  validateSession(sessionId: string): { isValid: boolean; warnings: string[] } {\n    const warnings: string[] = [];\n    const sessionData = this.sessionStore.get(sessionId);\n\n    if (!sessionData) {\n      return { isValid: false, warnings: ['Session not found'] };\n    }\n\n    const now = Date.now();\n    const sessionAge = now - sessionData.session.createdAt;\n    const inactivityTime = now - sessionData.lastActivity;\n\n    // Check session timeout\n    if (sessionAge > this.SESSION_TIMEOUT) {\n      this.sessionStore.delete(sessionId);\n      return { isValid: false, warnings: ['Session expired'] };\n    }\n\n    // Check inactivity timeout\n    if (inactivityTime > this.INACTIVITY_TIMEOUT) {\n      this.sessionStore.delete(sessionId);\n      return { isValid: false, warnings: ['Session inactive for too long'] };\n    }\n\n    // Update last activity\n    sessionData.lastActivity = now;\n\n    // Check for suspicious activity\n    if (sessionAge > 4 * 60 * 60 * 1000) {\n      // 4 hours\n      warnings.push('Session has been active for a long time');\n    }\n\n    return { isValid: true, warnings };\n  }\n\n  /**\n   * Refresh session with security checks\n   */\n  async refreshSession(\n    sessionId: string\n  ): Promise<{ success: boolean; session?: Session | null; error?: string }> {\n    try {\n      const sessionData = this.sessionStore.get(sessionId);\n      if (!sessionData) {\n        return { success: false, error: 'Session not found' };\n      }\n\n      // Validate current session\n      const validation = this.validateSession(sessionId);\n      if (!validation.isValid) {\n        return { success: false, error: 'Session validation failed' };\n      }\n\n      // Refresh Supabase session\n      const { error } = await supabase.auth.refreshSession();\n      if (error) {\n        this.logSecurityEvent(\n          'session_refresh_failure',\n          '', // Email not available in Session interface\n          false,\n          ['refresh_failed'],\n          { error }\n        );\n        return { success: false, error: error.message };\n      }\n\n      // Update session data\n      // Cannot assign to session property as it doesn't exist\n      sessionData.lastActivity = Date.now();\n\n      this.logSecurityEvent('session_refresh_success', '', true, [\n        'refresh_success',\n      ]);\n\n      return { success: true, session: undefined };\n    } catch (error) {\n      console.error('Session refresh error:', error);\n      return { success: false, error: 'Session refresh failed' };\n    }\n  }\n\n  /**\n   * Check if user requires MFA\n   */\n  private async checkMFARequirement(): Promise<boolean> {\n    try {\n      // Check if MFA is enabled for the user\n      const {\n        data: { user },\n      } = await supabase.auth.getUser();\n      if (!user) return false;\n\n      // Check user metadata for MFA requirement\n      const requiresMFA = user.user_metadata?.requires_mfa === true;\n      const isAdmin = user.user_metadata?.role === 'admin';\n\n      // Require MFA for admin users or if explicitly set\n      return requiresMFA || isAdmin;\n    } catch (error) {\n      console.error('Error checking MFA requirement:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Verify MFA code\n   */\n  private async verifyMFACode(code: string): Promise<boolean> {\n    try {\n      // Basic validation\n      if (!code || code.length < 6) return false;\n\n      // In a real implementation, you would:\n      // 1. Verify TOTP codes using a library like speakeasy\n      // 2. Verify SMS codes from your SMS service\n      // 3. Check against stored MFA secrets\n\n      // For now, implement basic TOTP-like validation\n      // This is a simplified example - use proper TOTP libraries in production\n      const isValidFormat = /^\\d{6}$/.test(code);\n      if (!isValidFormat) return false;\n\n      // In production, implement proper TOTP verification:\n      // const totp = speakeasy.totp.verify({\n      //   secret: userMfaSecret,\n      //   encoding: 'base32',\n      //   token: code,\n      //   window: 2\n      // });\n\n      // For demo purposes, accept any 6-digit code\n      // In production, remove this and implement proper verification\n      return true;\n    } catch (error) {\n      console.error('Error verifying MFA code:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get client IP address with proper fallbacks\n   */\n  private async getClientIP(): Promise<string> {\n    try {\n      // In a real implementation, this would get the client IP from headers\n      // For client-side usage, we can use a combination of factors\n      if (typeof window !== 'undefined') {\n        // Use a combination of factors for client identification\n        const userAgent = navigator.userAgent;\n        const language = navigator.language;\n        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n        // Create a pseudo-IP based on client characteristics\n        // In production, this should be replaced with actual IP from server headers\n        const clientFingerprint = btoa(\n          `${userAgent}:${language}:${timezone}`\n        ).slice(0, 16);\n        return clientFingerprint;\n      }\n\n      // Server-side fallback\n      return '127.0.0.1';\n    } catch (error) {\n      console.error('Error getting client IP:', error);\n      return 'unknown';\n    }\n  }\n\n  /**\n   * Log security events with SSR safety\n   */\n  private logSecurityEvent(\n    event: string,\n    email: string,\n    success: boolean,\n    securityFlags: string[],\n    metadata: Record<string, unknown> = {}\n  ): void {\n    try {\n      const auditLog: SecurityAuditLog = {\n        event,\n        email,\n        userAgent: this.getUserAgent(),\n        timestamp: new Date().toISOString(),\n        success,\n        securityFlags,\n        metadata,\n      };\n\n      // Log to console in development\n      if (isDevelopment()) {\n        console.log('[SECURITY_AUDIT]', auditLog);\n      }\n\n      // In production, send to your audit logging service\n      // await this.sendToAuditService(auditLog);\n    } catch (error) {\n      console.error('Error logging security event:', error);\n    }\n  }\n\n  /**\n   * Get user agent with SSR safety\n   */\n  private getUserAgent(): string {\n    try {\n      if (typeof window !== 'undefined' && navigator?.userAgent) {\n        return navigator.userAgent;\n      }\n      return 'unknown';\n    } catch (err) { console.error(err); throw err; }\n      return 'unknown';\n    }\n  }\n\n  /**\n   * Clean up expired sessions\n   */\n  cleanupExpiredSessions(): void {\n    const now = Date.now();\n    for (const [key, sessionData] of this.sessionStore.entries()) {\n      const sessionAge = now - sessionData.session.createdAt;\n      const inactivityTime = now - sessionData.lastActivity;\n\n      if (\n        sessionAge > this.SESSION_TIMEOUT ||\n        inactivityTime > this.INACTIVITY_TIMEOUT\n      ) {\n        this.sessionStore.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get security statistics\n   */\n  getSecurityStats(): {\n    activeSessions: number;\n    totalSessions: number;\n    rateLimitStatus: Record<string, unknown>;\n  } {\n    return {\n      activeSessions: this.sessionStore.size,\n      totalSessions: this.sessionStore.size, // In a real app, this would track total sessions\n      rateLimitStatus: {\n        activeBlocks: Array.from(this.rateLimiter.values()).filter(\n          (r) => r.blocked\n        ).length,\n        totalAttempts: Array.from(this.rateLimiter.values()).reduce(\n          (sum, r) => sum + r.attempts,\n          0\n        ),\n      },\n    };\n  }\n\n  /**\n   * Cleanup method for proper resource management\n   */\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    this.sessionStore.clear();\n    this.rateLimiter.clear();\n    this.isInitialized = false;\n  }\n}\n\nexport const secureAuthService = new SecureAuthService();\n\n// Cleanup on page unload (browser only)\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    secureAuthService.destroy();\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\security\\AccessControlService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\security\\ComplianceService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\security\\DataEncryptionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\security\\SecurityAuditService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\security\\SecurityMonitoringService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\statsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\BatchTrackingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\SterilizationCycleService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'phaseEntries' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 167,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'phaseEntries' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 281,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 281,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../../lib/supabaseClient';\nimport { useLoginStore } from '../../stores/useLoginStore';\nimport { TransactionManager } from './TransactionManager';\nimport { ErrorHandler } from '../error/ErrorHandler';\nimport { ToolService, ToolRow } from '@/services/tools/ToolService';\n\nasync function getCurrentFacilityId(): Promise<string> {\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n  if (!user) throw new Error('User not authenticated');\n\n  const { data: userData, error } = await supabase\n    .from('users')\n    .select('facility_id')\n    .eq('id', user.id)\n    .single();\n\n  if (error || !userData) throw new Error('Failed to get user facility');\n  return userData.facility_id;\n}\n\n/**\n * Safe type conversion utilities to prevent data loss\n */\nconst safeString = (value: unknown): string => {\n  return typeof value === 'string' ? value : '';\n};\n\nconst safeNumber = (value: unknown): number => {\n  return typeof value === 'number' ? value : 0;\n};\n\nconst safeDate = (value: unknown): Date | undefined => {\n  if (typeof value === 'string') {\n    const date = new Date(value);\n    return isNaN(date.getTime()) ? undefined : date;\n  }\n  return undefined;\n};\n\nexport interface SterilizationPhase {\n  name: string;\n  duration: number;\n  temperature?: number;\n  pressure?: number;\n  order: number;\n  title: string;\n}\n\nexport interface SterilizationCycle {\n  id: string;\n  cycleId: string;\n  facilityId: string;\n  cycleType: string;\n  status: string;\n  startTime: Date;\n  endTime?: Date;\n  temperatureCelsius?: number;\n  pressurePsi?: number;\n  cycleName?: string;\n  notes?: string;\n  createdBy: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateCycleResult {\n  success: boolean;\n  message: string;\n  cycle?: SterilizationCycle;\n  cycleId?: string;\n}\n\n/**\n * Sterilization Cycle Service - Handles cycle creation and management\n */\nexport class SterilizationCycleService {\n  // Define the standard sterilization phases\n  private static readonly PHASES: SterilizationPhase[] = [\n    { name: 'bath1', order: 1, title: 'Bath 1', duration: 300 },\n    { name: 'bath2', order: 2, title: 'Bath 2', duration: 300 },\n    { name: 'drying', order: 3, title: 'Drying', duration: 600 },\n    { name: 'autoclave', order: 4, title: 'Autoclave', duration: 1800 },\n    { name: 'packaging', order: 5, title: 'Packaging', duration: 900 },\n  ];\n\n  /**\n   * Create a new sterilization cycle and assign tools to it using transactions\n   */\n  static async createCycleWithTransaction(\n    toolIds: string[],\n    cycleType: string = 'routine',\n    notes?: string\n  ): Promise<CreateCycleResult> {\n    const context = ErrorHandler.createContext('createCycleWithTransaction');\n\n    return ErrorHandler.handleDatabaseError(async () => {\n      const authToken = useLoginStore.getState().authToken;\n      if (!authToken) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get current user from Supabase\n      const {\n        data: { user },\n        error: userError,\n      } = await supabase.auth.getUser();\n      if (userError || !user) {\n        throw new Error('Failed to get current user');\n      }\n\n      // Get user profile to get facility_id\n      const { data: userProfile, error: profileError } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      if (profileError || !userProfile) {\n        throw new Error('Failed to get user profile');\n      }\n\n      const facilityId = userProfile.facility_id;\n      const userId = user.id;\n\n      // Generate unique cycle ID\n      const cycleId = `CYCLE-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const now = new Date().toISOString();\n\n      // Use transaction to create cycle with all related data\n      const result = await TransactionManager.createSterilizationCycle({\n        cycle_type: cycleType,\n        facility_id: facilityId,\n        user_id: userId,\n        tools: toolIds.map((toolId) => ({\n          tool_id: toolId,\n          tool_name: `Tool ${toolId}`,\n          location: 'Bath 1',\n          status: 'in_cycle',\n        })),\n        audit_entries: [\n          {\n            action: 'cycle_created',\n            details: {\n              cycle_id: cycleId,\n              cycle_type: cycleType,\n              tool_count: toolIds.length,\n              notes: notes || `Cycle created for ${toolIds.length} tools`,\n            },\n            user_id: userId,\n            facility_id: facilityId,\n          },\n        ],\n      });\n\n      if (!result.success) {\n        throw new Error(result.error || 'Failed to create sterilization cycle');\n      }\n\n      const cycle = result.data?.cycle;\n      if (!cycle) {\n        throw new Error('No cycle data returned from transaction');\n      }\n\n      // Create cycle phases\n      const phaseEntries = this.PHASES.map((phase) => ({\n        cycle_id: cycle.id,\n        phase_name: phase.name,\n        phase_order: phase.order,\n        phase_status: phase.name === 'bath1' ? 'running' : 'pending',\n        start_time: phase.name === 'bath1' ? now : null,\n        phase_data: {\n          title: phase.title,\n          description: `${phase.title} phase of sterilization cycle`,\n        },\n      }));\n\n      // Cycle phases table does not exist - skipping phase creation\n      const phasesError = null;\n\n      if (phasesError) {\n        throw new Error(\n          `Failed to create cycle phases: ${phasesError.message}`\n        );\n      }\n\n      // Update all tools with the cycle ID and status\n      await ToolService.updateToolsCyclePhase(\n        toolIds,\n        'in_cycle',\n        cycle.id,\n        'bath1'\n      );\n\n      return {\n        success: true,\n        cycle: {\n          id: cycle.id,\n          cycleId: cycleId,\n          facilityId: facilityId,\n          cycleType: cycleType,\n          status: 'bath1',\n          startTime: new Date(now),\n          cycleName: `Bath 1 Cycle ${cycleId}`,\n          notes: notes || `Cycle created for ${toolIds.length} tools`,\n          createdBy: userId,\n          createdAt: new Date(now),\n          updatedAt: new Date(now),\n        },\n        message: `Successfully created sterilization cycle with ${toolIds.length} tools`,\n      };\n    }, context);\n  }\n\n  /**\n   * Create a new sterilization cycle and assign tools to it (legacy method)\n   */\n  static async createCycleAndAssignTools(\n    toolIds: string[],\n    cycleType: string = 'routine',\n    notes?: string\n  ): Promise<CreateCycleResult> {\n    try {\n      const authToken = useLoginStore.getState().authToken;\n      if (!authToken) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get current user from Supabase\n      const {\n        data: { user },\n        error: userError,\n      } = await supabase.auth.getUser();\n      if (userError || !user) {\n        throw new Error('Failed to get current user');\n      }\n\n      // Get user profile to get facility_id\n      const { data: userProfile, error: profileError } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      if (profileError || !userProfile) {\n        throw new Error('Failed to get user profile');\n      }\n\n      const facilityId = userProfile.facility_id;\n      const userId = user.id;\n\n      // Generate unique cycle ID\n      const cycleId = `CYCLE-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const now = new Date().toISOString();\n\n      // Create the sterilization cycle\n      const { data: cycle, error: cycleError } = await supabase\n        .from('sterilization_cycles')\n        .insert({\n          facility_id: facilityId,\n          cycle_type: cycleType,\n          status: 'bath1',\n          start_time: now,\n          cycle_name: `Bath 1 Cycle ${cycleId}`,\n          notes: notes || `Cycle created for ${toolIds.length} tools`,\n          created_by: userId,\n        })\n        .select()\n        .single();\n\n      if (cycleError) {\n        throw new Error(\n          `Failed to create sterilization cycle: ${cycleError.message}`\n        );\n      }\n\n      const typedCycle = cycle as Record<string, unknown>;\n\n      // Create cycle phases\n      const phaseEntries = this.PHASES.map((phase) => ({\n        cycle_id: typedCycle.id as string,\n        phase_name: phase.name,\n        phase_order: phase.order,\n        phase_status: phase.name === 'bath1' ? 'running' : 'pending',\n        start_time: phase.name === 'bath1' ? now : null,\n        phase_data: {\n          title: phase.title,\n          description: `${phase.title} phase of sterilization cycle`,\n        },\n      }));\n\n      // Cycle phases table does not exist - skipping phase creation\n      const phasesError = null;\n\n      if (phasesError) {\n        // Clean up the cycle if phase creation fails\n        await supabase\n          .from('sterilization_cycles')\n          .delete()\n          .eq('id', typedCycle.id as string)\n          .eq('facility_id', facilityId);\n        throw new Error(\n          `Failed to create cycle phases: ${phasesError.message}`\n        );\n      }\n\n      // Update all tools with the cycle ID and status\n      try {\n        await ToolService.updateToolsCyclePhase(\n          toolIds,\n          'in_cycle',\n          typedCycle.id as string,\n          'bath1'\n        );\n      } catch (toolsError) {\n        // Clean up the cycle if tool update fails\n        await supabase\n          .from('sterilization_cycles')\n          .delete()\n          .eq('id', typedCycle.id as string)\n          .eq('facility_id', facilityId);\n        throw new Error(\n          `Failed to assign tools to cycle: ${toolsError instanceof Error ? toolsError.message : 'Unknown error'}`\n        );\n      }\n\n      // Create audit log entries for each tool\n      const auditEntries = toolIds.map((toolId) => ({\n        user_id: userId,\n        facility_id: facilityId,\n        module: 'sterilization',\n        action: 'tool_assigned_to_cycle',\n        table_name: 'sterilization_tools',\n        record_id: toolId,\n        old_values: { status: 'available', current_phase: 'available' },\n        new_values: {\n          status: 'in_cycle',\n          current_phase: 'bath1',\n          current_cycle_id: typedCycle.id as string,\n        },\n        metadata: {\n          cycle_id: typedCycle.id as string,\n          cycle_name: typedCycle.cycle_name as string,\n          cycle_type: cycleType,\n        },\n      }));\n\n      const { error: auditError } = await supabase\n        .from('audit_logs')\n        .insert(auditEntries);\n\n      if (auditError) {\n        console.warn('Failed to create audit logs:', auditError);\n      }\n\n      // Create audit log for cycle creation\n      await supabase.from('audit_logs').insert({\n        user_id: userId,\n        facility_id: facilityId,\n        module: 'sterilization',\n        action: 'cycle_created',\n        table_name: 'sterilization_cycles',\n        record_id: typedCycle.id as string,\n        old_values: {},\n        new_values: {\n          cycle_id: cycleId,\n          cycle_type: cycleType,\n          status: 'bath1',\n          tool_count: toolIds.length,\n        },\n        metadata: {\n          cycle_id: typedCycle.id as string,\n          cycle_name: typedCycle.cycle_name as string,\n          tool_ids: toolIds,\n        },\n      });\n\n      const sterilizationCycle: SterilizationCycle = {\n        id: safeString(typedCycle.id),\n        cycleId: safeString(typedCycle.cycle_id),\n        facilityId: safeString(typedCycle.facility_id),\n        cycleType: safeString(typedCycle.cycle_type),\n        status: safeString(typedCycle.status),\n        startTime: safeDate(typedCycle.start_time) || new Date(),\n        endTime: safeDate(typedCycle.end_time),\n        temperatureCelsius:\n          safeNumber(typedCycle.temperature_celsius) || undefined,\n        pressurePsi: safeNumber(typedCycle.pressure_psi) || undefined,\n        cycleName: safeString(typedCycle.cycle_name) || undefined,\n        notes: safeString(typedCycle.notes) || undefined,\n        createdBy: safeString(typedCycle.created_by),\n        createdAt: safeDate(typedCycle.created_at) || new Date(),\n        updatedAt: safeDate(typedCycle.updated_at) || new Date(),\n      };\n\n      return {\n        success: true,\n        message: `Sterilization cycle created successfully. ${toolIds.length} tool(s) assigned to cycle ${cycleId}`,\n        cycle: sterilizationCycle,\n        cycleId: cycleId,\n      };\n    } catch (error) {\n      console.error('Error creating sterilization cycle:', error);\n      return {\n        success: false,\n        message:\n          error instanceof Error\n            ? error.message\n            : 'Failed to create sterilization cycle',\n      };\n    }\n  }\n\n  /**\n   * Get cycle by ID\n   */\n  static async getCycleById(\n    cycleId: string\n  ): Promise<SterilizationCycle | null> {\n    try {\n      const facilityId = await getCurrentFacilityId();\n      const { data: cycle, error } = await supabase\n        .from('sterilization_cycles')\n        .select('*')\n        .eq('id', cycleId)\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (error || !cycle) {\n        return null;\n      }\n\n      const typedCycle = cycle as Record<string, unknown>;\n\n      return {\n        id: safeString(typedCycle.id),\n        cycleId: safeString(typedCycle.cycle_id),\n        facilityId: safeString(typedCycle.facility_id),\n        cycleType: safeString(typedCycle.cycle_type),\n        status: safeString(typedCycle.status),\n        startTime: safeDate(typedCycle.start_time) || new Date(),\n        endTime: safeDate(typedCycle.end_time),\n        temperatureCelsius:\n          safeNumber(typedCycle.temperature_celsius) || undefined,\n        pressurePsi: safeNumber(typedCycle.pressure_psi) || undefined,\n        cycleName: safeString(typedCycle.cycle_name) || undefined,\n        notes: safeString(typedCycle.notes) || undefined,\n        createdBy: safeString(typedCycle.created_by),\n        createdAt: safeDate(typedCycle.created_at) || new Date(),\n        updatedAt: safeDate(typedCycle.updated_at) || new Date(),\n      };\n    } catch (error) {\n      console.error('Error fetching cycle:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Complete cycle and return tools to inventory\n   */\n  static async completeCycle(\n    cycleId: string,\n    autoclaveReceiptId?: string\n  ): Promise<{ success: boolean; message: string }> {\n    try {\n      const authToken = useLoginStore.getState().authToken;\n      if (!authToken) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get current user from Supabase\n      const {\n        data: { user },\n        error: userError,\n      } = await supabase.auth.getUser();\n      if (userError || !user) {\n        throw new Error('Failed to get current user');\n      }\n\n      const userId = user.id;\n      const now = new Date().toISOString();\n\n      // Get cycle\n      const facilityId = await getCurrentFacilityId();\n      const { data: cycle, error: cycleError } = await supabase\n        .from('sterilization_cycles')\n        .select('*')\n        .eq('id', cycleId)\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (cycleError || !cycle) {\n        throw new Error('Cycle not found');\n      }\n\n      const typedCycle = cycle as Record<string, unknown>;\n\n      // Complete final phase - cycle_phases table does not exist\n      const phaseError = null;\n\n      if (phaseError) {\n        throw new Error(\n          `Failed to complete final phase: ${phaseError.message}`\n        );\n      }\n\n      // Update cycle to completed\n      const { error: cycleUpdateError } = await supabase\n        .from('sterilization_cycles')\n        .update({\n          status: 'completed',\n          end_time: now,\n          updated_at: now,\n        })\n        .eq('id', cycleId)\n        .eq('facility_id', facilityId);\n\n      if (cycleUpdateError) {\n        throw new Error(\n          `Failed to complete cycle: ${cycleUpdateError.message}`\n        );\n      }\n\n      // Return all tools to available status\n      const facilityId = await getCurrentFacilityId();\n      const { data: tools, error: toolsError } = await supabase\n        .from('tools')\n        .select('id, name')\n        .eq('current_cycle_id', cycleId)\n        .eq('facility_id', facilityId);\n\n      if (toolsError) {\n        throw new Error(`Failed to get cycle tools: ${toolsError.message}`);\n      }\n\n      if (tools && tools.length > 0) {\n        const toolIds = tools.map((tool) => tool.id);\n\n        // Update status using ToolService for each tool\n        const toolUpdatePromises = toolIds.map((toolId) =>\n          ToolService.updateToolStatus(toolId, 'available')\n        );\n        await Promise.all(toolUpdatePromises);\n\n        // Update additional fields that ToolService doesn't handle yet\n        await ToolService.clearCycleAssignment(toolIds, 'available');\n      }\n\n      // Create audit log for cycle completion\n      await supabase.from('audit_logs').insert({\n        user_id: userId,\n        facility_id: typedCycle.facility_id as string,\n        module: 'sterilization',\n        action: 'cycle_completed',\n        table_name: 'sterilization_cycles',\n        record_id: cycleId,\n        old_values: { status: typedCycle.status as string },\n        new_values: { status: 'completed', end_time: now },\n        metadata: {\n          cycle_id: cycleId,\n          tools_returned: tools?.length || 0,\n          autoclave_receipt_id: autoclaveReceiptId,\n        },\n      });\n\n      return {\n        success: true,\n        message: `Cycle completed successfully. ${tools?.length || 0} tool(s) returned to inventory.`,\n      };\n    } catch (error) {\n      console.error('Error completing cycle:', error);\n      return {\n        success: false,\n        message:\n          error instanceof Error ? error.message : 'Failed to complete cycle',\n      };\n    }\n  }\n}\n\nexport async function loadDirtyToolsForCycle(): Promise<ToolRow[]> {\n  try {\n    const dirtyTools = await ToolService.getToolsByStatus('dirty');\n    return dirtyTools;\n  } catch (error) {\n    console.error('Failed to load dirty tools:', error);\n    return [];\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\SterilizationPhaseService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\SterilizationToolService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\TransactionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\sterilizationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\sterilization\\types\\sterilizationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\tableService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\taskService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\timerBackupService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\timerEventService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\timerWorkerService.ts",
    "messages": [
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 62,
        "column": 45,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 63,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [1774, 1783], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 96,
        "column": 43,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 97,
        "endColumn": 8,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [2720, 2727], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      },
      {
        "ruleId": "no-empty",
        "severity": 2,
        "message": "Empty block statement.",
        "line": 110,
        "column": 41,
        "nodeType": "BlockStatement",
        "messageId": "unexpected",
        "endLine": 111,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "suggestComment",
            "data": { "type": "block" },
            "fix": { "range": [3005, 3010], "text": " /* empty */ " },
            "desc": "Add comment inside empty block statement."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "interface TimerWorkerConfig {\n  updateInterval?: number;\n  enableDebugLogging?: boolean;\n  fallbackToMainThread?: boolean;\n}\n\ninterface TimerWorkerInstance {\n  worker: Worker | null;\n  isSupported: boolean;\n  error: Error | null;\n}\n\nclass TimerWorkerService {\n  private static instances = new Map<string, TimerWorkerInstance>();\n  private static config: TimerWorkerConfig = {\n    updateInterval: 100,\n    enableDebugLogging: process.env.NODE_ENV === 'development',\n    fallbackToMainThread: true,\n  };\n\n  static configure(config: Partial<TimerWorkerConfig>) {\n    this.config = { ...this.config, ...config };\n  }\n\n  static createWorker(id: string): TimerWorkerInstance {\n    // Check if worker already exists\n    if (this.instances.has(id)) {\n      return this.instances.get(id)!;\n    }\n\n    let worker: Worker | null = null;\n    let error: Error | null = null;\n    let isSupported = false;\n\n    try {\n      // Check if Web Workers are supported\n      if (typeof Window !== 'undefined' && 'Worker' in window) {\n        worker = new Worker(\n          new URL('../workers/timerWorker.ts', import.meta.url),\n          {\n            type: 'module',\n          }\n        );\n\n        // Set up error handling\n        worker.onerror = (event) => {\n          error = new Error(`Timer Worker Error: ${event.message}`);\n          if (this.config.enableDebugLogging) {\n            console.error('Timer Worker Error:', event);\n          }\n        };\n\n        worker.onmessageerror = (event) => {\n          error = new Error(`Timer Worker Message Error: ${event.toString()}`);\n          if (this.config.enableDebugLogging) {\n            console.error('Timer Worker Message Error:', event);\n          }\n        };\n\n        isSupported = true;\n\n        if (this.config.enableDebugLogging) {\n        }\n      } else {\n        error = new Error('Web Workers not supported in this environment');\n        if (this.config.enableDebugLogging) {\n          console.warn('Web Workers not supported, will use fallback timer');\n        }\n      }\n    } catch (err) {\n      error =\n        err instanceof Error ? err : new Error('Failed to create Timer Worker');\n      if (this.config.enableDebugLogging) {\n        console.warn('Failed to create Timer Worker:', err);\n      }\n    }\n\n    const instance: TimerWorkerInstance = {\n      worker,\n      isSupported,\n      error,\n    };\n\n    this.instances.set(id, instance);\n    return instance;\n  }\n\n  static getWorker(id: string): TimerWorkerInstance | null {\n    return this.instances.get(id) || null;\n  }\n\n  static terminateWorker(id: string): void {\n    const instance = this.instances.get(id);\n    if (instance?.worker) {\n      instance.worker.terminate();\n      if (this.config.enableDebugLogging) {\n      }\n    }\n    this.instances.delete(id);\n  }\n\n  static terminateAllWorkers(): void {\n    this.instances.forEach((instance) => {\n      if (instance.worker) {\n        instance.worker.terminate();\n      }\n    });\n    this.instances.clear();\n\n    if (this.config.enableDebugLogging) {\n    }\n  }\n\n  static isWorkerSupported(id: string): boolean {\n    const instance = this.instances.get(id);\n    return instance?.isSupported || false;\n  }\n\n  static getWorkerError(id: string): Error | null {\n    const instance = this.instances.get(id);\n    return instance?.error || null;\n  }\n\n  static getActiveWorkerCount(): number {\n    return this.instances.size;\n  }\n\n  static getWorkerStats(): {\n    total: number;\n    supported: number;\n    withErrors: number;\n  } {\n    let supported = 0;\n    let withErrors = 0;\n\n    this.instances.forEach((instance) => {\n      if (instance.isSupported) supported++;\n      if (instance.error) withErrors++;\n    });\n\n    return {\n      total: this.instances.size,\n      supported,\n      withErrors,\n    };\n  }\n\n  // Performance monitoring\n  static measureTimerAccuracy(\n    expectedInterval: number,\n    actualInterval: number\n  ): number {\n    const deviation = Math.abs(actualInterval - expectedInterval);\n    const accuracy = Math.max(0, 100 - (deviation / expectedInterval) * 100);\n    return Math.round(accuracy * 100) / 100; // Round to 2 decimal places\n  }\n\n  // Memory management\n  static cleanupUnusedWorkers(): void {\n    this.instances.forEach((instance, id) => {\n      // This is a simplified cleanup - in a real implementation,\n      // you'd track when workers were last used\n      if (instance.worker && !instance.isSupported) {\n        this.terminateWorker(id);\n      }\n    });\n  }\n}\n\n// Cleanup on page unload\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    TimerWorkerService.terminateAllWorkers();\n  });\n}\n\nexport default TimerWorkerService;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\toolService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'findError' is defined but never used.",
        "line": 89,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 89,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '../lib/supabaseClient';\nimport { Tool } from '../types/supabase';\nimport { Json } from '../types/supabase';\nimport { ToolService } from './tools/ToolService';\n\nexport interface ToolScanResult {\n  success: boolean;\n  message: string;\n  tool?: Tool;\n}\n\n// Define proper types for Supabase operations\n// Note: These types are defined for future use and consistency\n// type SupabaseClientType = SupabaseClient<Database>;\n// type SupabaseError = {\n//   message: string;\n//   details?: string;\n//   hint?: string;\n//   code?: string;\n// };\n\n// Define types for database table operations\ninterface ToolRow {\n  id: string;\n  tool_name: string;\n  barcode: string;\n  category?: string; // Made optional as it may not exist in database\n  tool_type?: string;\n  status:\n    | 'available'\n    | 'in_cycle'\n    | 'maintenance'\n    | 'retired'\n    | 'problem'\n    | 'quarantine';\n  location?: string;\n  sterilization_count: number;\n  last_sterilized?: string;\n  notes?: string;\n  facility_id: string;\n  current_cycle_id?: string;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface SterilizationCycleRow {\n  id: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  completed_at?: string;\n}\n\ninterface AuditLogInsert {\n  user_id?: string;\n  facility_id: string;\n  module: string;\n  action: string;\n  table_name: string;\n  record_id: string;\n  old_values: Json;\n  new_values: Json;\n  metadata: Json;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport class ToolService {\n  /**\n   * Scan a tool by barcode and update its status to 'in_cycle' (dirty)\n   */\n  static async scanToolForCleanWorkflow(\n    barcode: string,\n    operatorId?: string\n  ): Promise<ToolScanResult> {\n    try {\n      // First, find the tool by barcode and status\n      let tool;\n      try {\n        tool = await ToolService.getToolByBarcodeAndStatus(\n          barcode,\n          'available'\n        );\n\n        if (!tool) {\n          return {\n            success: false,\n            message: `Tool with barcode \"${barcode}\" not found or not available for sterilization.`,\n          };\n        }\n      } catch (findError) {\n        return {\n          success: false,\n          message: `Tool with barcode \"${barcode}\" not found or not available for sterilization.`,\n        };\n      }\n\n      // Check if tool is in 'complete' phase (ready to be marked as dirty)\n      if (tool.current_cycle_id) {\n        // Get the current cycle status\n        const { data: cycle } = await supabase\n          .from('sterilization_cycles')\n          .select('status')\n          .eq('id', tool.current_cycle_id)\n          .single();\n\n        if (cycle?.status !== 'completed') {\n          return {\n            success: false,\n            message: `Tool \"${(tool as ToolRow).tool_name}\" is not ready for clean workflow. Current cycle status: ${cycle?.status || 'unknown'}`,\n          };\n        }\n      }\n\n      // Update tool status to 'in_cycle' (dirty) and set current_cycle_id to null\n      const updatedTool = await ToolService.updateToolStatus(\n        (tool as ToolRow).id,\n        'in_cycle'\n      );\n\n      // Update additional fields that ToolService doesn't handle yet\n      await ToolService.clearCycleAssignment(\n        [(tool as ToolRow).id],\n        'in_cycle'\n      );\n\n      // Update last_sterilized separately since clearCycleAssignment doesn't handle it\n      await ToolService.markAsSterilized((tool as ToolRow).id);\n\n      // Create audit log entry\n      const auditLogData: AuditLogInsert = {\n        user_id: operatorId,\n        facility_id: (tool as ToolRow).facility_id,\n        module: 'sterilization',\n        action: 'tool_scanned_clean_workflow',\n        table_name: 'sterilization_tools',\n        record_id: (tool as ToolRow).id,\n        old_values: {\n          status: 'available',\n          current_cycle_id: (tool as ToolRow).current_cycle_id,\n        } as Json,\n        new_values: {\n          status: 'in_cycle',\n          current_cycle_id: null,\n        } as Json,\n        metadata: {\n          barcode: barcode,\n          workflow: 'clean',\n          previous_phase: 'complete',\n          new_phase: 'dirty',\n        } as Json,\n      };\n\n      await supabase.from('audit_logs').insert(auditLogData);\n\n      // Convert to Tool format\n      const toolData = updatedTool as ToolRow;\n      const sterilizationTool: Tool = {\n        id: toolData.id,\n        name: toolData.tool_name,\n        barcode: toolData.barcode,\n        category: toolData.category || 'general',\n        type: toolData.tool_type,\n        currentPhase: 'failed', // This represents 'dirty' in the UI\n        status: toolData.status as\n          | 'available'\n          | 'maintenance'\n          | 'retired'\n          | 'in_cycle'\n          | 'problem',\n        location: toolData.location,\n        cycleCount: toolData.sterilization_count || 0,\n        lastSterilized: toolData.last_sterilized,\n        notes: toolData.notes,\n      };\n\n      return {\n        success: true,\n        message: `Successfully scanned tool \"${toolData.tool_name}\" and marked as dirty. Ready for sterilization.`,\n        tool: sterilizationTool,\n      };\n    } catch (error) {\n      console.error('Error scanning tool for clean workflow:', error);\n      return {\n        success: false,\n        message: 'An unexpected error occurred while scanning the tool.',\n      };\n    }\n  }\n\n  /**\n   * Scan a tool by barcode and mark it as having a problem\n   * This is part of the Clean Workflow - tool was scanned but found to be unusable\n   */\n  static async scanToolForProblemWorkflow(\n    barcode: string,\n    problemType: string,\n    problemNotes: string,\n    operatorId?: string\n  ): Promise<ToolScanResult> {\n    try {\n      // Find the tool by barcode (any status)\n      const { data: tool, error: findError } = await supabase\n        .from('tools')\n        .select('*')\n        .eq('barcode', barcode)\n        .single();\n\n      if (findError || !tool) {\n        return {\n          success: false,\n          message: `Tool with barcode \"${barcode}\" not found in system.`,\n        };\n      }\n\n      // Get the last sterilization cycle for process improvement analysis\n      let lastCycleInfo: SterilizationCycleRow | null = null;\n      if (tool.current_cycle_id) {\n        const { data: cycle } = await supabase\n          .from('sterilization_cycles')\n          .select('*')\n          .eq('id', tool.current_cycle_id)\n          .single();\n        lastCycleInfo = cycle as SterilizationCycleRow;\n      }\n\n      // Update tool status to 'quarantine' (problem)\n      const updatedTool = await ToolService.updateToolStatus(\n        (tool as ToolRow).id,\n        'quarantine'\n      );\n\n      // Update additional fields that ToolService doesn't handle yet\n      await ToolService.clearCycleAssignment(\n        [(tool as ToolRow).id],\n        'quarantine'\n      );\n\n      // Update notes separately since clearCycleAssignment doesn't handle it\n      const { error: updateError } = await supabase\n        .from('tools')\n        .update({\n          updated_at: new Date().toISOString(),\n          notes: `PROBLEM: ${problemType} - ${problemNotes}`,\n        })\n        .eq('id', (tool as ToolRow).id);\n\n      if (updateError) {\n        console.error('Failed to update tool status:', updateError);\n        return {\n          success: false,\n          message: 'Failed to update tool status. Please try again.',\n        };\n      }\n\n      // Create comprehensive audit log for process improvement\n      const toolData = tool as ToolRow;\n      const auditLogData: AuditLogInsert = {\n        user_id: operatorId,\n        facility_id: toolData.facility_id,\n        module: 'sterilization',\n        action: 'tool_scanned_problem_workflow',\n        table_name: 'sterilization_tools',\n        record_id: toolData.id,\n        old_values: {\n          status: toolData.status,\n          current_cycle_id: toolData.current_cycle_id,\n          sterilization_count: toolData.sterilization_count,\n          last_sterilized: toolData.last_sterilized,\n        } as Json,\n        new_values: {\n          status: 'quarantine',\n          current_cycle_id: null,\n          notes: `PROBLEM: ${problemType} - ${problemNotes}`,\n        } as Json,\n        metadata: {\n          barcode: barcode,\n          workflow: 'problem',\n          problem_type: problemType,\n          problem_notes: problemNotes,\n          previous_phase: 'clean_workflow_scan',\n          new_phase: 'quarantine',\n          last_cycle_id: toolData.current_cycle_id,\n          last_cycle_status: lastCycleInfo?.status,\n          last_cycle_completed: lastCycleInfo?.completed_at,\n          sterilization_count_at_problem: toolData.sterilization_count,\n          process_improvement_flag: true,\n          inspection_quality_issue:\n            problemType.includes('damage') ||\n            problemType.includes('inspection'),\n          cleaning_quality_issue:\n            problemType.includes('cleaning') ||\n            problemType.includes('contamination'),\n        } as Json,\n      };\n\n      await supabase.from('audit_logs').insert(auditLogData);\n\n      // Convert to Tool format\n      const updatedToolData = updatedTool as ToolRow;\n      const sterilizationTool: Tool = {\n        id: updatedToolData.id,\n        name: updatedToolData.tool_name,\n        barcode: updatedToolData.barcode,\n        category: updatedToolData.category || 'general',\n        type: updatedToolData.tool_type,\n        currentPhase: 'quarantine',\n        status: updatedToolData.status as\n          | 'available'\n          | 'maintenance'\n          | 'retired'\n          | 'in_cycle'\n          | 'problem',\n        location: updatedToolData.location,\n        cycleCount: updatedToolData.sterilization_count || 0,\n        lastSterilized: updatedToolData.last_sterilized,\n        notes: updatedToolData.notes,\n      };\n\n      return {\n        success: true,\n        message: `Tool \"${updatedToolData.tool_name}\" marked as problem (${problemType}). Process improvement data collected.`,\n        tool: sterilizationTool,\n      };\n    } catch (error) {\n      console.error('Error scanning tool for problem workflow:', error);\n      return {\n        success: false,\n        message:\n          'An unexpected error occurred while processing the problem tool.',\n      };\n    }\n  }\n\n  /**\n   * Get all available tools for a facility\n   */\n  static async getAvailableTools(facilityId: string): Promise<Tool[]> {\n    try {\n      const facilityTools = await ToolService.getToolsByFacilityAndStatus(\n        facilityId,\n        'available'\n      );\n      // Sort since ToolService doesn't handle sorting yet\n      const sortedTools = facilityTools.sort((a, b) =>\n        (a.tool_name || '').localeCompare(b.tool_name || '')\n      );\n\n      return sortedTools.map((tool): Tool => {\n        const toolData = tool as ToolRow;\n        return {\n          id: toolData.id,\n          name: toolData.tool_name,\n          barcode: toolData.barcode,\n          category: toolData.category || 'general',\n          type: toolData.tool_type,\n          currentPhase: toolData.current_cycle_id ? 'complete' : 'available',\n          status: toolData.status as\n            | 'available'\n            | 'maintenance'\n            | 'retired'\n            | 'in_cycle'\n            | 'problem',\n          location: toolData.location,\n          cycleCount: toolData.sterilization_count || 0,\n          lastSterilized: toolData.last_sterilized,\n          notes: toolData.notes,\n        };\n      });\n    } catch (error) {\n      console.error('Error fetching available tools:', error);\n      return [];\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\tools\\ToolService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Tool' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 3,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from '@/lib/supabaseClient';\nimport { Database } from '@/types/supabase';\nimport { Tool, ToolStatus } from '@/types/toolTypes';\n\ntype ToolRow = Database['public']['Tables']['tools']['Row'];\n\n// Helper functions for tenant and audit stamping\nasync function getCurrentUserId(): Promise<string> {\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n  if (!user) throw new Error('User not authenticated');\n  return user.id;\n}\n\nasync function getCurrentFacilityId(): Promise<string> {\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n  if (!user) throw new Error('User not authenticated');\n\n  const { data: userData, error } = await supabase\n    .from('users')\n    .select('facility_id')\n    .eq('id', user.id)\n    .single();\n\n  if (error || !userData) throw new Error('Failed to get user facility');\n  return userData.facility_id;\n}\n\nexport const ToolService = {\n  async getToolByBarcode(barcode: string): Promise<ToolRow | null> {\n    const facilityId = await getCurrentFacilityId();\n    const { data, error } = await supabase\n      .from('tools')\n      .select('*')\n      .eq('barcode', barcode)\n      .eq('facility_id', facilityId)\n      .maybeSingle();\n\n    if (error) {\n      console.error('ToolService.getToolByBarcode error:', error);\n      return null;\n    }\n\n    return data;\n  },\n\n  async getToolsByStatus(status: ToolStatus): Promise<ToolRow[]> {\n    const facilityId = await getCurrentFacilityId();\n    const { data, error } = await supabase\n      .from('tools')\n      .select('*')\n      .eq('status', status)\n      .eq('facility_id', facilityId);\n\n    if (error) {\n      console.error('ToolService.getToolsByStatus error:', error);\n      return [];\n    }\n\n    return data || [];\n  },\n\n  async updateToolStatus(toolId: string, status: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        status,\n        facility_id: await getCurrentFacilityId(),\n        updated_by: await getCurrentUserId(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', toolId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n\n  async getToolByBarcodeAndStatus(barcode: string, status: string) {\n    const facilityId = await getCurrentFacilityId();\n    const { data, error } = await supabase\n      .from('tools')\n      .select('*')\n      .eq('barcode', barcode)\n      .eq('status', status)\n      .eq('facility_id', facilityId)\n      .single();\n    if (error) throw error;\n    return data;\n  },\n\n  async getToolsByFacilityAndStatus(facilityId: string, status: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .select('*')\n      .eq('facility_id', facilityId)\n      .eq('status', status);\n    if (error) throw error;\n    return data;\n  },\n\n  async getToolsByStatuses(statuses: string[]) {\n    const facilityId = await getCurrentFacilityId();\n    const { data, error } = await supabase\n      .from('tools')\n      .select('*')\n      .in('status', statuses)\n      .eq('facility_id', facilityId);\n    if (error) throw error;\n    return data;\n  },\n\n  async updateToolsStatus(toolIds: string[], status: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        status,\n        facility_id: await getCurrentFacilityId(),\n        updated_by: await getCurrentUserId(),\n        updated_at: new Date().toISOString(),\n      })\n      .in('id', toolIds)\n      .select();\n    if (error) throw error;\n    return data;\n  },\n\n  async updateToolsCyclePhase(\n    toolIds: string[],\n    status: string,\n    cycleId: string,\n    phase: string\n  ) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        status,\n        current_cycle_id: cycleId,\n        current_phase: phase,\n        facility_id: await getCurrentFacilityId(),\n        updated_by: await getCurrentUserId(),\n        updated_at: new Date().toISOString(),\n      })\n      .in('id', toolIds)\n      .select();\n    if (error) throw error;\n    return data;\n  },\n\n  async clearCycleAssignment(toolIds: string[], status: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        status,\n        current_cycle_id: null,\n        current_phase: null,\n        facility_id: await getCurrentFacilityId(),\n        updated_by: await getCurrentUserId(),\n        updated_at: new Date().toISOString(),\n      })\n      .in('id', toolIds)\n      .select();\n    if (error) throw error;\n    return data;\n  },\n\n  async markAsSterilized(toolId: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        last_sterilized: new Date().toISOString(),\n        updated_by: await getCurrentUserId(),\n        facility_id: await getCurrentFacilityId(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', toolId)\n      .select()\n      .single();\n    if (error) throw error;\n    return data;\n  },\n\n  async updateToolPhase(toolId: string, phase: string) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        current_phase: phase,\n        updated_by: await getCurrentUserId(),\n        facility_id: await getCurrentFacilityId(),\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', toolId)\n      .select()\n      .single();\n    if (error) throw error;\n    return data;\n  },\n\n  async touchTools(toolIds: string[]) {\n    const { data, error } = await supabase\n      .from('tools')\n      .update({\n        updated_by: await getCurrentUserId(),\n        facility_id: await getCurrentFacilityId(),\n        updated_at: new Date().toISOString(),\n      })\n      .in('id', toolIds)\n      .select();\n    if (error) throw error;\n    return data;\n  },\n\n  // Add more methods like:\n  // - insertTool()\n  // - archiveTool()\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\trackedToolsService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\usageTrackingService.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 56,
        "column": 2,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "interface UsageData {\n  itemId: string;\n  usageCount: number;\n  lastUsed: Date;\n  searchCount: number;\n  favoriteCount: number;\n  trackCount: number;\n}\n\nclass UsageTrackingService {\n  private static instance: UsageTrackingService;\n  private usageData: Map<string, UsageData> = new Map();\n  private readonly STORAGE_KEY = 'inventory_usage_data';\n\n  private constructor() {\n    this.loadUsageData();\n  }\n\n  static getInstance(): UsageTrackingService {\n    if (!UsageTrackingService.instance) {\n      UsageTrackingService.instance = new UsageTrackingService();\n    }\n    return UsageTrackingService.instance;\n  }\n\n  private loadUsageData(): void {\n    try {\n      const stored = localStorage.getItem(this.STORAGE_KEY);\n      if (stored) {\n        const data = JSON.parse(stored) as Record<string, unknown>;\n        // Convert date strings back to Date objects\n        const convertedData = Object.fromEntries(\n          Object.entries(data).map(([key, value]) => {\n            const typedValue = value as { lastUsed: string } & Record<\n              string,\n              unknown\n            >;\n            return [\n              key,\n              {\n                ...typedValue,\n                lastUsed: new Date(typedValue.lastUsed),\n              },\n            ];\n          })\n        );\n        this.usageData = new Map(\n          Object.entries(convertedData) as [string, UsageData][]\n        );\n      }\n    } catch (err) { console.error(err); throw err; }\n      console.warn('Failed to load usage data:');\n    }\n  }\n\n  private saveUsageData(): void {\n    try {\n      const data = Object.fromEntries(this.usageData);\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n    } catch (err) { console.error(err); throw err; }\n      console.warn('Failed to save usage data:');\n    }\n  }\n\n  private getOrCreateUsageData(itemId: string): UsageData {\n    const existing = this.usageData.get(itemId);\n    if (!existing) {\n      const newData: UsageData = {\n        itemId,\n        usageCount: 0,\n        lastUsed: new Date(),\n        searchCount: 0,\n        favoriteCount: 0,\n        trackCount: 0,\n      };\n      this.usageData.set(itemId, newData);\n      return newData;\n    }\n    return existing;\n  }\n\n  // Track when an item is viewed/accessed\n  trackItemView(itemId: string): void {\n    const data = this.getOrCreateUsageData(itemId);\n    data.usageCount += 1;\n    data.lastUsed = new Date();\n    this.saveUsageData();\n  }\n\n  // Track when an item is searched for\n  trackItemSearch(itemId: string): void {\n    const data = this.getOrCreateUsageData(itemId);\n    data.searchCount += 1;\n    data.lastUsed = new Date();\n    this.saveUsageData();\n  }\n\n  // Track when an item is favorited\n  trackItemFavorite(itemId: string): void {\n    const data = this.getOrCreateUsageData(itemId);\n    data.favoriteCount += 1;\n    data.lastUsed = new Date();\n    this.saveUsageData();\n  }\n\n  // Track when an item is tracked\n  trackItemTrack(itemId: string): void {\n    const data = this.getOrCreateUsageData(itemId);\n    data.trackCount += 1;\n    data.lastUsed = new Date();\n    this.saveUsageData();\n  }\n\n  // Calculate smart score for an item\n  calculateSmartScore(itemId: string): number {\n    const data = this.usageData.get(itemId);\n    if (!data) return 0;\n\n    const now = new Date();\n\n    // Ensure lastUsed is a valid Date object\n    let lastUsed: Date;\n    try {\n      lastUsed =\n        data.lastUsed instanceof Date ? data.lastUsed : new Date(data.lastUsed);\n      if (isNaN(lastUsed.getTime())) {\n        lastUsed = new Date(); // Fallback to current date if invalid\n      }\n    } catch (err) { console.error(err); throw err; }\n      lastUsed = new Date(); // Fallback to current date if error\n    }\n\n    const daysSinceLastUsed =\n      (now.getTime() - lastUsed.getTime()) / (1000 * 60 * 60 * 24);\n\n    // Base score from usage count\n    let score = data.usageCount * 10;\n\n    // Bonus for recent usage (items used in last 7 days get bonus)\n    if (daysSinceLastUsed <= 7) {\n      score += 50;\n    }\n\n    // Bonus for search frequency\n    score += data.searchCount * 5;\n\n    // Bonus for being favorited\n    score += data.favoriteCount * 20;\n\n    // Bonus for being tracked\n    score += data.trackCount * 15;\n\n    // Decay for old items (items not used in 30+ days get penalty)\n    if (daysSinceLastUsed > 30) {\n      score *= 0.8;\n    }\n\n    return Math.round(score);\n  }\n\n  // Get smart ranking for a list of items\n  getSmartRanking<\n    T extends {\n      toolId?: string;\n      supplyId?: string;\n      equipmentId?: string;\n      hardwareId?: string;\n      data?: Record<string, unknown>;\n    },\n  >(items: T[]): T[] {\n    return [...items].sort((a, b) => {\n      const aId =\n        a.toolId ||\n        a.supplyId ||\n        a.equipmentId ||\n        a.hardwareId ||\n        a.data?.toolId ||\n        a.data?.supplyId ||\n        a.data?.equipmentId ||\n        a.data?.hardwareId ||\n        '';\n      const bId =\n        b.toolId ||\n        b.supplyId ||\n        b.equipmentId ||\n        b.hardwareId ||\n        b.data?.toolId ||\n        b.data?.supplyId ||\n        b.data?.equipmentId ||\n        b.data?.hardwareId ||\n        '';\n\n      const aScore = this.calculateSmartScore(aId as string);\n      const bScore = this.calculateSmartScore(bId as string);\n\n      return bScore - aScore; // Higher scores first\n    });\n  }\n\n  // Get usage statistics for debugging\n  getUsageStats(): Record<string, UsageData> {\n    return Object.fromEntries(this.usageData);\n  }\n\n  // Clear all usage data (for testing/reset)\n  clearUsageData(): void {\n    this.usageData.clear();\n    localStorage.removeItem(this.STORAGE_KEY);\n  }\n}\n\nexport const usageTrackingService = UsageTrackingService.getInstance();\nexport type { UsageData };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\userSessionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\users\\userTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\vercelAIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\workflowRealtimeService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\services\\workflowService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\setupTests.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\shared\\transformers\\BaseTransformer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\EnvironmentalCleaningStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\checklistStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\homeStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createInventoryDataStoreSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createInventoryFilterSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createInventoryModalStoreSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createInventoryPaginationSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createInventoryUIStoreSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventorySlices\\createScanModalSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventoryStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventory\\createInventoryFiltersSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\inventory\\createInventoryUIStateSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\roomStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\actions\\cycleActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\actions\\phaseActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\actions\\toolActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\batchCodeSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\batchManagementSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\batchSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\biFailureSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\biWorkflowSlice.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ')' expected.",
        "line": 392,
        "column": 27,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  BIWorkflowSliceCreator,\n  ActivityLogItem,\n} from './types/biWorkflowTypes';\nimport { createBITestSlice } from './slices/biTestSlice';\nimport { createBIFailureSlice } from './biFailureSlice';\nimport {\n  getBIComplianceStatus,\n  getBIFailureRiskLevel,\n  getActivitySummary,\n} from './utils/computedValues';\nimport { BITestService } from '../../services/bi/BITestService';\nimport { BIFailureIncidentService } from '../../services/bi/BIFailureIncidentService';\nimport { supabase } from '../../lib/supabaseClient';\nimport { FacilityService } from '../../services/facilityService';\n\n/**\n * Create BI Workflow Slice\n */\nexport const createBIWorkflowSlice: BIWorkflowSliceCreator = (\n  set,\n  get,\n  store\n) => ({\n  // BI Test Management Actions - Delegated to biTestSlice\n  ...createBITestSlice(set, get, store),\n\n  // BI Failure Management Actions - Delegated to biFailureSlice\n  ...createBIFailureSlice(set, get, store),\n\n  // Activity Log Actions\n  addActivity: (activity) => {\n    const newActivity: ActivityLogItem = {\n      ...activity,\n      id: `activity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    };\n\n    set((state) => ({\n      activityLog: [newActivity, ...state.activityLog].slice(0, 50), // Keep last 50 activities\n    }));\n  },\n\n  clearActivityLog: () => set({ activityLog: [] }),\n\n  loadActivityLog: async () => {\n    set({ activityLogLoading: true });\n\n    try {\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        throw new Error('No facility ID available');\n      }\n\n      const { data: activityLog, error } = await supabase\n        .from('bi_activity_log')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .order('created_at', { ascending: false })\n        .limit(100);\n\n      if (error) {\n        throw error;\n      }\n\n      // Transform the data to match ActivityLogItem interface\n      const transformedActivityLog: ActivityLogItem[] = (activityLog || []).map(\n        (item: Record<string, unknown>) => ({\n          id:\n            (item.id as string) ||\n            `activity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          type: ((item.type as string) || 'general') as\n            | 'bi-test'\n            | 'bi-failure'\n            | 'cycle-complete'\n            | 'tool-quarantine'\n            | 'regulatory-notification'\n            | 'tool-200-scans'\n            | 'bath-1-change'\n            | 'bath-2-change'\n            | 'autoclave-cycle-started'\n            | 'tool-problem-flagged'\n            | 'batch-id-created',\n          title: (item.title as string) || 'Activity',\n          time: new Date(\n            (item.created_at as string) || new Date().toISOString()\n          ),\n          color: (item.color as string) || 'blue',\n          description:\n            (item.data &&\n            typeof item.data === 'object' &&\n            'description' in item.data\n              ? (item.data.description as string)\n              : '') || '',\n          metadata: (item.metadata as Record<string, unknown>) || {},\n        })\n      );\n\n      set({\n        activityLog: transformedActivityLog,\n        activityLogLoading: false,\n      });\n    } catch (error) {\n      console.error('Failed to load activity log:', error);\n      set({\n        activityLogLoading: false,\n        syncError: 'Failed to load activity log',\n      });\n    }\n  },\n\n  // Compliance Settings Actions\n  setEnforceBI: async (value) => {\n    set({ enforceBI: value });\n    get().addPendingChange({\n      type: 'settings',\n      data: { enforceBI: value },\n    });\n    await get().syncWithSupabase();\n  },\n\n  setEnforceCI: async (value) => {\n    set({ enforceCI: value });\n    get().addPendingChange({\n      type: 'settings',\n      data: { enforceCI: value },\n    });\n    await get().syncWithSupabase();\n  },\n\n  setAllowOverrides: async (value) => {\n    set({ allowOverrides: value });\n    get().addPendingChange({\n      type: 'settings',\n      data: { allowOverrides: value },\n    });\n    await get().syncWithSupabase();\n  },\n\n  toggleEnforceBI: async () => {\n    const { enforceBI } = get();\n    await get().setEnforceBI(!enforceBI);\n  },\n\n  toggleEnforceCI: async () => {\n    const { enforceCI } = get();\n    await get().setEnforceCI(!enforceCI);\n  },\n\n  loadComplianceSettings: async () => {\n    set({ complianceSettingsLoading: true });\n\n    try {\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        throw new Error('No facility ID available');\n      }\n\n      const { data: complianceSettings, error } = await supabase\n        .from('facility_compliance_settings')\n        .select('*')\n        .eq('facility_id', facilityId)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        // PGRST116 = no rows returned\n        throw error;\n      }\n\n      if (complianceSettings) {\n        set({\n          enforceBI: Boolean(complianceSettings.enforce_bi),\n          enforceCI: Boolean(complianceSettings.enforce_ci),\n          allowOverrides: Boolean(complianceSettings.allow_overrides),\n          complianceSettingsLoading: false,\n        });\n      } else {\n        // Set default values if no settings found\n        set({\n          enforceBI: true,\n          enforceCI: true,\n          allowOverrides: false,\n          complianceSettingsLoading: false,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to load compliance settings:', error);\n      set({\n        complianceSettingsLoading: false,\n        syncError: 'Failed to load compliance settings',\n      });\n    }\n  },\n\n  // Synchronization Actions\n  syncWithSupabase: async () => {\n    set({ isSyncing: true, syncError: null });\n\n    try {\n      const facilityId = await FacilityService.getCurrentFacilityId();\n      if (!facilityId) {\n        throw new Error('No facility ID available');\n      }\n\n      // Process pending changes\n      const { pendingChanges } = get();\n\n      for (const change of pendingChanges) {\n        try {\n          switch (change.type) {\n            case 'bi-test':\n              // Sync BI test results\n              if (change.data && typeof change.data === 'object') {\n                await BITestService.createBITestResult({\n                  ...(change.data as Record<string, unknown>),\n                  facility_id: facilityId,\n                  result: 'pass', // Add missing required property\n                });\n              }\n              break;\n            case 'bi-failure':\n              // Sync BI failure incidents\n              if (change.data && typeof change.data === 'object') {\n                await BIFailureIncidentService.createIncident({\n                  ...(change.data as Record<string, unknown>),\n                  facility_id: facilityId,\n                  affected_tools_count: 0, // Add missing required property\n                  affected_batch_ids: [], // Add missing required property\n                });\n              }\n              break;\n            case 'settings':\n              // Sync compliance settings\n              if (change.data && typeof change.data === 'object') {\n                const settingsData = change.data as {\n                  enforceBI?: boolean;\n                  enforceCI?: boolean;\n                  allowOverrides?: boolean;\n                };\n                const { error } = await supabase\n                  .from('facility_compliance_settings')\n                  .upsert(\n                    {\n                      facility_id: facilityId,\n                      enforce_bi: settingsData.enforceBI,\n                      enforce_ci: settingsData.enforceCI,\n                      allow_overrides: settingsData.allowOverrides,\n                      updated_at: new Date().toISOString(),\n                    },\n                    {\n                      onConflict: 'facility_id',\n                    }\n                  );\n\n                if (error) {\n                  throw error;\n                }\n              }\n              break;\n          }\n        } catch (error) {\n          console.error(`Failed to sync ${change.type}:`, error);\n          // Continue with other changes even if one fails\n        }\n      }\n\n      set({\n        isSyncing: false,\n        lastSyncTime: new Date(),\n        pendingChanges: [],\n      });\n    } catch (error) {\n      console.error('Sync failed:', error);\n      set({\n        isSyncing: false,\n        syncError: 'Sync failed',\n      });\n    }\n  },\n\n  syncBIFailureFromDatabase: (incident: unknown) => {\n    const typedIncident = incident as {\n      id: string;\n      incident_number: string;\n      failure_date: string;\n      affected_tools_count: number;\n      affected_batch_ids: string[];\n      failure_reason?: string;\n      severity_level: string;\n      status: string;\n      detected_by_operator_id?: string;\n      regulatory_notification_sent?: boolean;\n      regulatory_notification_date?: string;\n      facility_id?: string;\n      regulatory_notification_required?: boolean;\n      created_at?: string;\n      updated_at?: string;\n    };\n    set({\n      biFailureActive: typedIncident.status === 'active',\n      biFailureDetails:\n        typedIncident.status === 'active'\n          ? {\n              id: typedIncident.id,\n              incident_number: typedIncident.incident_number,\n              failure_date: typedIncident.failure_date,\n              affected_tools_count: typedIncident.affected_tools_count,\n              affected_batch_ids: typedIncident.affected_batch_ids,\n              failure_reason: typedIncident.failure_reason,\n              severity_level: typedIncident.severity_level as\n                | 'low'\n                | 'medium'\n                | 'high'\n                | 'critical',\n              status: typedIncident.status as\n                | 'active'\n                | 'in_resolution'\n                | 'resolved'\n                | 'closed',\n              detected_by_operator_id: typedIncident.detected_by_operator_id,\n              regulatory_notification_sent:\n                typedIncident.regulatory_notification_sent || false,\n              regulatory_notification_date:\n                typedIncident.regulatory_notification_date,\n              facility_id: typedIncident.facility_id || '',\n              regulatory_notification_required:\n                typedIncident.regulatory_notification_required || false,\n              created_at: typedIncident.created_at || new Date().toISOString(),\n              updated_at: typedIncident.updated_at || new Date().toISOString(),\n            }\n          : null,\n    });\n  },\n\n  addPendingChange: (change) => {\n    set((state) => ({\n      pendingChanges: [\n        ...state.pendingChanges,\n        {\n          ...change,\n          id: `change-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          timestamp: new Date(),\n        },\n      ],\n    }));\n  },\n\n  clearPendingChanges: () => set({ pendingChanges: [] }),\n\n  retryFailedSync: async () => {\n    await get().syncWithSupabase();\n  },\n\n  // Optimistic Updates Actions\n  addOptimisticUpdate: (key, data) => {\n    const { optimisticUpdates } = get();\n    optimisticUpdates.set(key, data);\n    set({ optimisticUpdates: new Map(optimisticUpdates) });\n  },\n\n  removeOptimisticUpdate: (key) => {\n    const { optimisticUpdates } = get();\n    optimisticUpdates.delete(key);\n    set({ optimisticUpdates: new Map(optimisticUpdates) });\n  },\n\n  clearOptimisticUpdates: () => set({ optimisticUpdates: new Map() }),\n\n  // State Persistence Actions\n  saveStateToLocalStorage: () => {\n    const state = get();\n    const stateToSave = {\n      biTestCompleted: state.biTestCompleted,\n      biTestDate: state.biTestDate,\n      biTestResults: state.biTestResults,\n      nextBITestDue: state.nextBITestDue,\n      lastBITestDate: state.lastBITestDate,\n      biTestPassed: state.biTestPassed,\n      biTestOptedOut: state.biTestOptedOut,\n      enforceBI: state.enforceBI,\n      enforceCI: state.enforceCI,\n      allowOverrides: state.allowOverrides,\n      lastSyncTime: state.lastSyncTime,\n    };\n\n    try {\n      localStorage.setItem('biWorkflowState', JSON.stringify(stateToSave));\n    } catch (err) { console.error(err); throw err; }\n      // Error handling without console logging\n    }\n  },\n\n  loadStateFromLocalStorage: () => {\n    try {\n      const savedState = localStorage.getItem('biWorkflowState');\n      if (savedState) {\n        const parsedState = JSON.parse(savedState);\n        set({\n          biTestCompleted: parsedState.biTestCompleted || false,\n          biTestDate: parsedState.biTestDate || null,\n          biTestResults: parsedState.biTestResults || [],\n          nextBITestDue: parsedState.nextBITestDue\n            ? new Date(parsedState.nextBITestDue)\n            : null,\n          lastBITestDate: parsedState.lastBITestDate || null,\n          biTestPassed: parsedState.biTestPassed || false,\n          biTestOptedOut: parsedState.biTestOptedOut || false,\n          enforceBI:\n            parsedState.enforceBI !== undefined ? parsedState.enforceBI : true,\n          enforceCI:\n            parsedState.enforceCI !== undefined ? parsedState.enforceCI : true,\n          allowOverrides: parsedState.allowOverrides || false,\n          lastSyncTime: parsedState.lastSyncTime\n            ? new Date(parsedState.lastSyncTime)\n            : null,\n        });\n      }\n    } catch (err) { console.error(err); throw err; }\n      // Error handling without console logging\n    }\n  },\n\n  clearLocalStorage: () => {\n    try {\n      localStorage.removeItem('biWorkflowState');\n    } catch (err) { console.error(err); throw err; }\n      // Error handling without console logging\n    }\n  },\n\n  // Computed Values - Delegated to utility functions\n  getBIComplianceStatus: () => getBIComplianceStatus(get()),\n  getBIFailureRiskLevel: () => getBIFailureRiskLevel(get()),\n  getActivitySummary: () => getActivitySummary(get()),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\biologicalIndicatorSlice.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: 'catch' or 'finally' expected.",
        "line": 139,
        "column": 6,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { StateCreator } from 'zustand';\nimport { BITestResult } from '@/types/toolTypes';\nimport { ActivityLogItem } from './types/biWorkflowTypes';\nimport {\n  BITestKitService,\n  BITestKit,\n  TestConditions,\n} from '@/services/bi/BITestKitService';\nimport { BIWorkflowService } from '@/services/biWorkflowService';\nimport { calculateNextBIDue } from '@/utils/calculateNextBIDue';\nimport { supabase } from '@/lib/supabaseClient';\n\nexport interface BiologicalIndicatorState {\n  // Core BI test state\n  biTestCompleted: boolean;\n  biTestDate: string | null;\n  biTestResults: BITestResult[];\n  nextBITestDue: Date | null;\n  lastBITestDate: string | null;\n  biTestPassed: boolean;\n  biTestOptedOut: boolean;\n  activityLog: ActivityLogItem[];\n\n  // Global BI failure state\n  biFailureActive: boolean;\n  biFailureDetails: {\n    id: string;\n    date: Date;\n    affectedToolsCount: number;\n    affectedBatchIds: string[];\n    operator: string;\n  } | null;\n\n  // Actions\n  setBiTestCompleted: (completed: boolean) => void;\n  setBiTestDate: (date: string) => void;\n  recordBITestResult: (result: BITestResult) => Promise<unknown>;\n  setNextBITestDue: (date: Date) => void;\n  setLastBITestDate: (date: string) => void;\n  setBiTestPassed: (value: boolean) => void;\n  setBiTestOptedOut: (optedOut: boolean) => void;\n  resetBIState: () => void;\n  addActivity: (activity: ActivityLogItem) => void;\n  activateBIFailure: (details: {\n    affectedToolsCount: number;\n    affectedBatchIds: string[];\n    operator: string;\n  }) => void;\n  deactivateBIFailure: () => void;\n}\n\nexport const createBiologicalIndicatorSlice: StateCreator<\n  BiologicalIndicatorState,\n  [],\n  [],\n  BiologicalIndicatorState\n> = (set) => ({\n  biTestCompleted: false,\n  biTestDate: null,\n  biTestResults: [],\n  nextBITestDue: null,\n  lastBITestDate: null,\n  biTestPassed: false,\n  biTestOptedOut: false,\n  activityLog: [],\n  biFailureActive: false,\n  biFailureDetails: null,\n\n  setBiTestCompleted: (completed: boolean) =>\n    set({ biTestCompleted: completed }),\n  setBiTestDate: (date: string) => set({ biTestDate: date }),\n  recordBITestResult: async (result: Omit<BITestResult, 'id'>) => {\n    console.log('üî¨ recordBITestResult called with:', result);\n    try {\n      // Get current user and facility from Supabase\n      const {\n        data: { user },\n        error: authError,\n      } = await supabase.auth.getUser();\n      if (authError || !user) {\n        throw new Error('User not authenticated');\n      }\n\n      // Get user's facility ID from users table\n      const { data: userData, error: userError } = await supabase\n        .from('users')\n        .select('facility_id')\n        .eq('id', user.id)\n        .single();\n\n      if (userError || !userData) {\n        throw new Error('User facility not found');\n      }\n\n      // Get available BI test kit from inventory\n      let availableKits: BITestKit[] = [];\n      let selectedKit: BITestKit | null = null;\n      let testConditions: TestConditions | null = null;\n\n      try {\n        availableKits = await BITestKitService.getAvailableKits(\n          userData.facility_id as string\n        );\n        if (availableKits.length > 0) {\n          selectedKit = availableKits[0]; // Use the kit with earliest expiry date\n          testConditions = await BITestKitService.getCurrentTestConditions();\n        }\n      } catch (err) { console.error(err); throw err; }\n        // If no kits available, use default values to restore existing functionality\n        selectedKit = {\n          id: 'default-kit',\n          facility_id: userData.facility_id as string,\n          name: 'Default BI Kit',\n          manufacturer: 'Default Manufacturer',\n          lot_number: 'DEFAULT-001',\n          expiry_date: new Date(\n            Date.now() + 365 * 24 * 60 * 60 * 1000\n          ).toISOString(),\n          incubation_time_minutes: 60,\n          incubation_temperature_celsius: 37,\n          quantity: 1,\n          min_quantity: 1,\n          max_quantity: 100,\n          status: 'active',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        testConditions = {\n          room_temperature_celsius: 22,\n          humidity_percent: 45,\n          equipment_used: 'Default Equipment',\n          operator_id: user.id,\n          facility_id: userData.facility_id as string,\n          test_date: new Date().toISOString(),\n        };\n      }\n\n      // Save to Supabase with real user/facility data\n      const biTestData = {\n        facility_id: userData.facility_id as string,\n        operator_id: user.id,\n        cycle_id: undefined, // Optional: link to specific cycle\n        result: result.status === 'pending' ? 'pass' : result.status,\n        bi_lot_number: selectedKit?.lot_number || '',\n        bi_expiry_date: selectedKit?.expiry_date || '',\n        incubation_time_minutes: selectedKit?.incubation_time_minutes || 60,\n        incubation_temperature_celsius:\n          selectedKit?.incubation_temperature_celsius || 37,\n        test_conditions: testConditions || undefined,\n        failure_reason: result.status === 'fail' ? 'BI test failed' : undefined,\n        skip_reason: result.status === 'skip' ? 'BI test skipped' : undefined,\n        compliance_notes:\n          result.status === 'pass' ? 'BI test passed' : undefined,\n      };\n\n      const savedResult =\n        await BIWorkflowService.createBITestResult(biTestData);\n\n      // Update BI test kit inventory (decrease quantity by 1) - only if we have a real kit\n      if (selectedKit && selectedKit.id !== 'default-kit') {\n        try {\n          await BITestKitService.decrementKitQuantity(selectedKit.id);\n        } catch (err) { console.error(err); throw err; }\n          // Ignore inventory update errors for default kit\n        }\n      }\n\n      // Update local state after successful save\n      set((state) => {\n        const nextDue = calculateNextBIDue(result.date);\n        const activity: ActivityLogItem = {\n          id: `activity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          type: 'bi-test',\n          title: result.passed ? 'BI Test Passed' : 'BI Test Failed',\n          time: result.date,\n          toolCount: 1,\n          color: result.passed ? 'bg-green-500' : 'bg-red-500',\n        };\n        const newResult: BITestResult = {\n          ...result,\n          id: `bi-test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        };\n        return {\n          biTestCompleted: result.passed,\n          biTestDate: result.date.toISOString(),\n          biTestResults: [...state.biTestResults, newResult],\n          lastBITestDate: result.date.toISOString(),\n          nextBITestDue: nextDue,\n          biTestPassed: result.passed,\n          activityLog: [activity, ...state.activityLog].slice(0, 20),\n        };\n      });\n\n      return savedResult;\n    } catch (error: unknown) {\n      console.error('Error recording BI test result:', error);\n      // Still update local state for immediate feedback\n      set((state) => {\n        const nextDue = calculateNextBIDue(result.date);\n        const activity: ActivityLogItem = {\n          id: `activity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n          type: 'bi-test',\n          title: result.passed ? 'BI Test Passed' : 'BI Test Failed',\n          time: result.date,\n          toolCount: 1,\n          color: result.passed ? 'bg-green-500' : 'bg-red-500',\n        };\n        const newResult: BITestResult = {\n          ...result,\n          id: `bi-test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        };\n        return {\n          biTestCompleted: result.passed,\n          biTestDate: result.date.toISOString(),\n          biTestResults: [...state.biTestResults, newResult],\n          lastBITestDate: result.date.toISOString(),\n          nextBITestDue: nextDue,\n          biTestPassed: result.passed,\n          activityLog: [activity, ...state.activityLog].slice(0, 20),\n        };\n      });\n      throw error;\n    }\n  },\n  setNextBITestDue: (date: Date) => set({ nextBITestDue: date }),\n  setLastBITestDate: (date: string) => set({ lastBITestDate: date }),\n  setBiTestPassed: (value: boolean) => set({ biTestPassed: value }),\n  setBiTestOptedOut: (optedOut: boolean) => set({ biTestOptedOut: optedOut }),\n  addActivity: (activity: ActivityLogItem) =>\n    set((state: BiologicalIndicatorState) => {\n      const activityWithId = {\n        ...activity,\n        id:\n          activity.id ||\n          `activity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      };\n      return {\n        activityLog: [activityWithId, ...state.activityLog].slice(0, 20),\n      };\n    }),\n  activateBIFailure: (details: {\n    affectedToolsCount: number;\n    affectedBatchIds: string[];\n    operator: string;\n  }) =>\n    set(() => ({\n      biFailureActive: true,\n      biFailureDetails: {\n        id: `bi-failure-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        date: new Date(),\n        affectedToolsCount: details.affectedToolsCount,\n        affectedBatchIds: details.affectedBatchIds,\n        operator: details.operator,\n      },\n    })),\n  deactivateBIFailure: () =>\n    set(() => ({\n      biFailureActive: false,\n      biFailureDetails: null,\n    })),\n  // New method to sync with Supabase\n  syncBIFailureFromDatabase: (incident: {\n    status: string;\n    failure_date: string;\n    affected_tools_count: number;\n    affected_batch_ids: string[];\n    detected_by_operator_id?: string;\n  }) =>\n    set({\n      biFailureActive: incident.status === 'active',\n      biFailureDetails:\n        incident.status === 'active'\n          ? {\n              id: `bi-failure-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n              date: new Date(incident.failure_date),\n              affectedToolsCount: incident.affected_tools_count,\n              affectedBatchIds: incident.affected_batch_ids,\n              operator: incident.detected_by_operator_id || 'System Alert',\n            }\n          : null,\n    }),\n  resetBIState: () =>\n    set(() => ({\n      biTestCompleted: false,\n      biTestDate: null,\n      biTestResults: [],\n      nextBITestDue: null,\n      lastBITestDate: null,\n      biTestPassed: false,\n      biTestOptedOut: false,\n      activityLog: [],\n      biFailureActive: false,\n      biFailureDetails: null,\n    })),\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\complianceSettingsSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\environmentalCleanAuditSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\environmentalCleanDataSlice.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: ')' expected.",
        "line": 49,
        "column": 18,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { StateCreator } from 'zustand';\nimport {\n  Room,\n  CleaningChecklist,\n  CleaningAnalytics,\n} from '../../pages/EnvironmentalClean/models';\nimport { EnvironmentalCleanService } from '../../pages/EnvironmentalClean/services/EnvironmentalCleanService';\n\nexport interface EnvironmentalCleanDataState {\n  rooms: Room[];\n  checklists: CleaningChecklist[];\n  analytics: CleaningAnalytics;\n  isLoading: boolean;\n  error: string | null;\n  fetchRooms: () => Promise<void>;\n  updateRoomStatus: (roomId: string, status: string) => Promise<void>;\n  fetchChecklists: () => Promise<void>;\n  fetchAnalytics: () => Promise<void>;\n  addAuditLog: (action: string, metadata: Record<string, unknown>) => void;\n}\n\nexport const createEnvironmentalCleanDataSlice: StateCreator<\n  EnvironmentalCleanDataState\n> = (set, get) => ({\n  rooms: [],\n  checklists: [],\n  analytics: {\n    totalRooms: 0,\n    cleanRooms: 0,\n    dirtyRooms: 0,\n    inProgressRooms: 0,\n    cleaningEfficiency: 0,\n    averageCleaningTime: 0,\n    lastUpdated: new Date().toISOString(),\n  },\n  isLoading: false,\n  error: null,\n\n  fetchRooms: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const rooms = await EnvironmentalCleanService.fetchRooms();\n      set({ rooms, isLoading: false });\n    } catch (err) { console.error(err); throw err; }\n      set({ error: 'Failed to fetch rooms', isLoading: false });\n    }\n  },\n\n  updateRoomStatus: async (roomId: string, status: string) => {\n    try {\n      await EnvironmentalCleanService.updateRoomStatus(\n        roomId,\n        status as Room['status']\n      );\n      // Optionally refresh rooms after status update:\n      const rooms = await EnvironmentalCleanService.fetchRooms();\n      set({ rooms });\n      // ADD AUDIT LOG HERE:\n      get().addAuditLog('updateRoomStatus', { roomId, status });\n    } catch (err) { console.error(err); throw err; }\n      set({ error: 'Failed to update room status' });\n    }\n  },\n\n  fetchChecklists: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const checklists = await EnvironmentalCleanService.fetchChecklists();\n      set({ checklists, isLoading: false });\n    } catch (error) {\n      console.error('Failed to fetch checklists:', error);\n      set({ error: 'Failed to fetch checklists', isLoading: false });\n    }\n  },\n\n  fetchAnalytics: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const analytics = await EnvironmentalCleanService.fetchAnalytics();\n      set({ analytics, isLoading: false });\n    } catch (err) { console.error(err); throw err; }\n      set({ error: 'Failed to fetch analytics', isLoading: false });\n    }\n  },\n\n  addAuditLog: () => {\n    // Implementation for audit logging\n    // Debug logging removed for production\n  },\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\environmentalCleanUISlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\environmentalCleaningSlice.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-empty-object-type",
        "severity": 2,
        "message": "An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.",
        "line": 4,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "noEmptyInterface",
        "endLine": 4,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "replaceEmptyInterface",
            "data": { "replacement": "object" },
            "fix": {
              "range": [116, 286],
              "text": "type EnvironmentalCleaningState = object"
            },
            "desc": "Replace empty interface with `object`."
          },
          {
            "messageId": "replaceEmptyInterface",
            "data": { "replacement": "unknown" },
            "fix": {
              "range": [116, 286],
              "text": "type EnvironmentalCleaningState = unknown"
            },
            "desc": "Replace empty interface with `unknown`."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryAnalyticsSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryDataSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryFilterSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryFormSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryModalSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryPaginationSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryUISlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\inventoryUIStateSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\packagingSessionSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\packagingUISlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\slices\\biTestSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\sterilizationCycleSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\toolActionsSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\toolDataSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\toolManagementSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\types\\biWorkflowTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\types\\sterilizationCycleTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\uiStateSlice.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\utils\\computedValues.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\utils\\cycleStatsUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\slices\\utils\\cycleUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\statusTypesStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\sterilizationStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\timerStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\useInventoryModalStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\store\\useInventoryStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\stores\\loginStores.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\stores\\useLoginStore.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\tests\\utils\\passwordStrength.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\QueryOptions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\analyticsTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\batchTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\biWorkflowTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\cleaningSchedule.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\cycleTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\environmentalClean.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\home.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\homeDataTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\homeTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\inventory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\inventoryServiceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\inventoryStrictTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\inventoryTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\layout.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\layoutTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\leaderboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\performanceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\receiptTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\sterilizationAITypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\sterilizationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\supabaseMockTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\supabaseTableTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\supabase_generated.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\task.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\toolTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\types\\utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\barcodeUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\calculation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\deleteOperationUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\filterLocalData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\filterUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\formDataUtils.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 137,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { getDefaultFormData } from '@/utils/inventoryHelpers';\nimport { FormData, InventoryItem } from '@/types/inventoryTypes';\n\nexport interface StoreFormData {\n  item?: string;\n  category?: string;\n  toolId?: string;\n  supplyId?: string;\n  equipmentId?: string;\n  hardwareId?: string;\n  location?: string;\n  cost?: number;\n  p2Status?: string;\n}\n\nexport interface TransformedFormData {\n  itemName: string;\n  category: string;\n  id: string;\n  location: string;\n  purchaseDate: string;\n  vendor: string;\n  cost: string;\n  warranty: string;\n  maintenanceSchedule: string;\n  lastServiced: string;\n  nextDue: string;\n  serviceProvider: string;\n  assignedTo: string;\n  status: string;\n  quantity: string;\n  notes: string;\n}\n\n/**\n * Resolves the correct ID field from store form data\n * @param storeFormData - Form data from store\n * @returns The appropriate ID value\n */\nexport const resolveFormDataId = (storeFormData: StoreFormData): string => {\n  if ('toolId' in storeFormData && storeFormData.toolId)\n    return storeFormData.toolId;\n  if ('supplyId' in storeFormData && storeFormData.supplyId)\n    return storeFormData.supplyId;\n  if ('equipmentId' in storeFormData && storeFormData.equipmentId)\n    return storeFormData.equipmentId;\n  if ('hardwareId' in storeFormData && storeFormData.hardwareId)\n    return storeFormData.hardwareId;\n  return '';\n};\n\n/**\n * Transforms store form data to the format expected by InventoryModalsWrapper\n * @param storeFormData - Form data from store\n * @returns Transformed form data with all required properties\n */\nexport const transformFormDataForModal = (\n  storeFormData: Partial<InventoryItem> | FormData\n): TransformedFormData => {\n  const defaultData = getDefaultFormData();\n\n  // Handle both FormData and Partial<InventoryItem> types\n  const itemName =\n    'itemName' in storeFormData\n      ? storeFormData.itemName\n      : storeFormData.name || storeFormData.item || '';\n  const category = storeFormData.category;\n  const id = storeFormData.id;\n  const location = storeFormData.location || '';\n  const unitCost =\n    typeof (storeFormData as StoreFormData & { unit_cost?: number | string })\n      .unit_cost === 'number'\n      ? (\n          storeFormData as StoreFormData & { unit_cost?: number | string }\n        ).unit_cost?.toString() || '0'\n      : (storeFormData as StoreFormData & { unit_cost?: number | string })\n          .unit_cost || '0';\n  const status =\n    (storeFormData as StoreFormData & { status?: string }).status || '';\n\n  // Helper function to format dates for HTML date inputs\n  const formatDateForInput = (dateString?: string | null): string => {\n    if (!dateString) return '';\n    try {\n      const date = new Date(dateString);\n      if (isNaN(date.getTime())) return '';\n      return date.toISOString().split('T')[0]; // Convert to yyyy-MM-dd format\n    } catch (err) { console.error(err); throw err; }\n      return '';\n    }\n  };\n\n  return {\n    itemName: String(itemName || defaultData.itemName || ''),\n    category: String(category || defaultData.category || ''),\n    id: String(id || defaultData.id || ''),\n    location: String(location || defaultData.location || ''),\n    purchaseDate: formatDateForInput(\n      (storeFormData as Record<string, unknown>)?.createdAt ||\n        defaultData.createdAt\n    ),\n    vendor: String(\n      (storeFormData as Record<string, unknown>)?.supplier ||\n        defaultData.supplier ||\n        ''\n    ),\n    cost: String(unitCost || defaultData.unitCost || 0),\n    warranty: String(\n      (storeFormData as Record<string, unknown>)?.warranty || ''\n    ),\n    maintenanceSchedule: String(\n      (storeFormData as Record<string, unknown>)?.maintenanceSchedule || ''\n    ),\n    lastServiced: formatDateForInput(\n      (storeFormData as Record<string, unknown>)?.lastServiced ||\n        defaultData.updated_at\n    ),\n    nextDue: String((storeFormData as Record<string, unknown>)?.nextDue || ''),\n    serviceProvider: String(\n      (storeFormData as Record<string, unknown>)?.serviceProvider || ''\n    ),\n    assignedTo: String(\n      (storeFormData as Record<string, unknown>)?.assignedTo || ''\n    ),\n    status: String(status || defaultData.status || ''),\n    quantity: String(\n      (storeFormData as Record<string, unknown>)?.quantity ||\n        defaultData.quantity ||\n        1\n    ),\n    notes: String(\n      (storeFormData as Record<string, unknown>)?.notes ||\n        defaultData.notes ||\n        ''\n    ),\n  };\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\formUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\formatting.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\statusUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\Inventory\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\_core\\logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\_core\\realtimeAuditor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\_core\\realtimeMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\abortController.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\auditLogger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\authUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\calculateNextBIDue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\checkBITestDue.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\cspUtils.ts",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 81,
        "column": 0,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Content Security Policy utilities for security hardening\n\nexport const CSP_POLICIES = {\n  // Default CSP for login forms\n  LOGIN_FORM: {\n    'default-src': [\"'self'\"],\n    'script-src': [\"'self'\", \"'unsafe-inline'\"], // Allow inline scripts for React\n    'style-src': [\"'self'\", \"'unsafe-inline'\"], // Allow inline styles for React\n    'img-src': [\"'self'\", 'data:', 'https:'],\n    'font-src': [\"'self'\", 'https:'],\n    'connect-src': [\n      \"'self'\",\n      'https:',\n      'https://*.supabase.co',\n      'wss://*.supabase.co',\n    ],\n    'form-action': [\"'self'\"], // Restrict form submissions\n    'base-uri': [\"'self'\"], // Restrict base URI\n    'object-src': [\"'none'\"], // Block plugins\n    'media-src': [\"'self'\"],\n    'worker-src': [\"'self'\"],\n    'manifest-src': [\"'self'\"],\n    'upgrade-insecure-requests': [], // Force HTTPS\n  },\n\n  // Strict CSP for production\n  PRODUCTION: {\n    'default-src': [\"'self'\"],\n    'script-src': [\"'self'\"], // No unsafe-inline in production\n    'style-src': [\"'self'\"], // No unsafe-inline in production\n    'img-src': [\"'self'\", 'https:'],\n    'font-src': [\"'self'\", 'https:'],\n    'connect-src': [\n      \"'self'\",\n      'https:',\n      'https://*.supabase.co',\n      'wss://*.supabase.co',\n    ],\n\n    'form-action': [\"'self'\"],\n    'base-uri': [\"'self'\"],\n    'object-src': [\"'none'\"],\n    'media-src': [\"'self'\"],\n    'worker-src': [\"'self'\"],\n    'manifest-src': [\"'self'\"],\n    'upgrade-insecure-requests': [],\n  },\n};\n\nexport const generateCSPHeader = (\n  policy: keyof typeof CSP_POLICIES = 'LOGIN_FORM'\n): string => {\n  const selectedPolicy = CSP_POLICIES[policy];\n\n  return Object.entries(selectedPolicy)\n    .map(([directive, sources]) => {\n      if (sources.length === 0) {\n        return directive;\n      }\n      return `${directive} ${sources.join(' ')}`;\n    })\n    .join('; ');\n};\n\nexport const applyCSP = (\n  policy: keyof typeof CSP_POLICIES = 'LOGIN_FORM'\n): void => {\n  if (typeof window === 'undefined') return;\n\n  try {\n    // Add CSP meta tag if not already present\n    if (!document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]')) {\n      const meta = document.createElement('meta');\n      meta.httpEquiv = 'Content-Security-Policy';\n      meta.content = generateCSPHeader(policy);\n      document.head.appendChild(meta);\n    }\n  } catch (err) { console.error(err); throw err; }\n    // Silent fail - CSP is primarily a server-side concern\n  }\n};\n\nexport const validateCSPCompliance = (): boolean => {\n  if (typeof window === 'undefined') return true;\n\n  try {\n    // Check if we're running on HTTPS\n    const isHttps =\n      window.location.protocol === 'https:' ||\n      window.location.hostname === 'localhost' ||\n      window.location.hostname === '127.0.0.1';\n\n    // Check for CSP header\n    const hasCSP = !!document.querySelector(\n      'meta[http-equiv=\"Content-Security-Policy\"]'\n    );\n\n    return isHttps && hasCSP;\n  } catch (err) { console.error(err); throw err; }\n    return false;\n  }\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\database\\TransactionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\deviceDetection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\enhancedGamification.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 251,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 251,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5851, 5854], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5851, 5854], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 257,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 257,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6082, 6085], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6082, 6085], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 313,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 313,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7871, 7874], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7871, 7874], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 319,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 319,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8107, 8110], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8107, 8110], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 379,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 379,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10038, 10041], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10038, 10041], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 433,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 433,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11872, 11875], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11872, 11875], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 440,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 440,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12175, 12178], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12175, 12178], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 506,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 506,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14278, 14281], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14278, 14281], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 567,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 567,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15837, 15840], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15837, 15840], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\errorUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\exportUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\feedback.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\fetchWithProtection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\format.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\formatTime.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\gamification.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\generateTraceabilityCode.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\getRandomBarcode.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\getToolCounts.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\handleTaskCompletion.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\homeContentUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\homeUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\inventoryHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\monitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\notificationUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\queryOptimization.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\rateLimiter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\realtimeCleanup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\sanitizeInput.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\securityChecklist.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\securityHeaders.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\securityMonitoring.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\securityUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\stateValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\statusValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\sterilizationUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\streakExclusionUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\stressTest.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\throttle.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\timerUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\typeGuards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\validateState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\validateTask.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\validateTaskData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\validateTaskId.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\utils\\workflowColorUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\cliniio3.0\\src\\validation\\inventoryValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
