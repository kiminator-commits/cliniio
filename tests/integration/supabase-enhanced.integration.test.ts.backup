// Enhanced Supabase Integration Tests - External Services and Complex Scenarios
// Focused on transactions, triggers, RLS, and external service integrations

import { vi } from 'vitest';

// Mock getEnv before importing components that use it
vi.mock('@/lib/getEnv', async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...actual,
    getEnvVar: (key: string) => {
      if (key === 'VITE_SUPABASE_URL') return 'https://test.supabase.co';
      if (key === 'VITE_SUPABASE_ANON_KEY') return 'test-anon-key';
      return '';
    },
    isDevelopment: () => false,
    isProduction: () => false,
    isBrowser: () => false,
    isNode: () => true,
    getEnvironmentConfig: () => ({
      SUPABASE_URL: 'https://test.supabase.co',
      SUPABASE_ANON_KEY: 'test-anon-key',
      NODE_ENV: 'test',
      DEV: false,
      PROD: false,
      BROWSER: false,
      NODE: true,
    }),
  };
});

// Mock Supabase client with proper factory
vi.mock('@/lib/supabaseClient', () => {
  return {
    supabase: {
      from: vi.fn().mockReturnThis(),
      select: vi.fn().mockReturnThis(),
      insert: vi.fn().mockReturnThis(),
      update: vi.fn().mockReturnThis(),
      delete: vi.fn().mockReturnThis(),
      eq: vi.fn().mockReturnThis(),
      single: vi.fn().mockReturnThis(),
      auth: {
        signInWithPassword: vi.fn().mockResolvedValue({
          data: { user: { id: 'mock-user' } },
          error: null,
        }),
        signOut: vi.fn().mockResolvedValue({ error: null }),
      },
    },
  };
});

import { SupabaseAuthService } from '@/services/supabase/authService';
import { InventoryServiceFacade } from '@/services/inventory/InventoryServiceFacade';

// Import the mock client for test setup
import { supabase as mockSupabaseClient } from '@/lib/supabaseClient';

// Import modular test utilities
import {
  setupTestEnvironment,
  cleanupTestEnvironment,
} from './mocks/supabaseMockFactory';
import { testCredentials } from './fixtures/testData';
import {
  setupMockAuth,
  setupMockSubscription,
  setupMockTable,
  createMockAuthResponse,
  createMockErrorResponse,
  validateErrorResponse,
  simulateNetworkError,
  simulateRateLimit,
  simulatePermissionDenied,
} from './helpers/testHelpers';

describe('Enhanced Supabase Integration Tests - External Services and Complex Scenarios', () => {
  beforeAll(() => {
    setupTestEnvironment();
  });

  beforeEach(() => {
    // Clear all mocks before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    cleanupTestEnvironment();
  });

  describe('Authentication Service - External Service Integration', () => {
    test('should handle network timeouts gracefully', async () => {
      simulateNetworkError(mockSupabaseClient.auth, 'signInWithPassword');

      const result = await SupabaseAuthService.signIn(testCredentials.valid);

      validateErrorResponse(
        result as { error: string; user: null },
        'Network timeout'
      );
      expect(result.user).toBeNull();
    });

    test('should handle rate limiting', async () => {
      simulateRateLimit(mockSupabaseClient.auth, 'signInWithPassword');

      const result = await SupabaseAuthService.signIn(testCredentials.valid);

      validateErrorResponse(
        result as { error: string; user: null },
        'Too many requests'
      );
      expect(result.user).toBeNull();
    });

    test('should handle account lockout scenarios', async () => {
      const lockoutResponse = createMockAuthResponse(
        null,
        null,
        'Account temporarily locked'
      );
      setupMockAuth(mockSupabaseClient, lockoutResponse);

      const result = await SupabaseAuthService.signIn(testCredentials.locked);

      validateErrorResponse(
        result as { error: string; user: null },
        'Account temporarily locked'
      );
      expect(result.user).toBeNull();
    });

    test('should handle password reset flow', async () => {
      const resetResponse = createMockAuthResponse(null, null, null);
      setupMockAuth(mockSupabaseClient, resetResponse);

      const result = await SupabaseAuthService.resetPassword(
        testCredentials.reset.email
      );

      expect(result.error).toBeNull();
      expect(
        mockSupabaseClient.auth.resetPasswordForEmail
      ).toHaveBeenCalledWith(testCredentials.reset.email, {
        redirectTo: 'http://localhost:3000/reset-password',
      });
    });

    test('should handle session refresh scenarios', async () => {
      const mockSession = {
        access_token: 'new-access-token',
        refresh_token: 'refresh-token',
        expires_at: Date.now() + 3600000,
      };

      const sessionResponse = {
        data: { session: mockSession },
        error: null,
      };
      setupMockAuth(mockSupabaseClient, sessionResponse);

      const result = await SupabaseAuthService.getSession();

      expect(result.error).toBeNull();
      expect(result.session).toBeDefined();
    });
  });

  describe('Real-time Subscriptions - External Service Integration', () => {
    test('should handle subscription setup and teardown', async () => {
      setupMockSubscription(mockSupabaseClient);

      // Test subscription setup
      const mockChannel = (
        mockSupabaseClient as {
          channel: (name: string) => { on: vi.Mock; subscribe: vi.Mock };
        }
      ).channel('test-channel');
      expect(mockChannel.on).toBeDefined();
      expect(mockChannel.subscribe).toBeDefined();

      // Test subscription teardown
      const subscription = mockChannel.subscribe();
      expect(subscription.unsubscribe).toBeDefined();
    });

    test('should handle subscription events', async () => {
      setupMockSubscription(mockSupabaseClient);

      const mockChannel = (
        mockSupabaseClient as {
          channel: (name: string) => { on: vi.Mock; subscribe: vi.Mock };
        }
      ).channel('test-channel');
      const mockOn = mockChannel.on;
      const mockSubscribe = mockChannel.subscribe;

      // Test event handling
      mockOn('INSERT', vi.fn());
      expect(mockOn).toHaveBeenCalledWith('INSERT', expect.any(Function));

      // Test subscription
      mockSubscribe();
      expect(mockSubscribe).toHaveBeenCalled();
    });
  });

  describe('Error Handling - External Service Integration', () => {
    test('should handle database connection failures', async () => {
      const mockResponse = createMockErrorResponse(
        'Connection to database failed',
        'PGRST301'
      );
      setupMockTable(mockSupabaseClient, mockResponse);

      const result = await InventoryServiceFacade.getAllItems();

      validateErrorResponse(
        result as { error: string; data: null },
        'Connection to database failed'
      );
      expect(result.data).toBeNull();
    });

    test('should handle permission denied errors', async () => {
      simulatePermissionDenied(mockSupabaseClient);

      const result = await InventoryServiceFacade.getAllItems();

      validateErrorResponse(
        result as { error: string; data: null },
        'Permission denied'
      );
      expect(result.data).toBeNull();
    });

    test('should handle malformed JSON responses', async () => {
      const mockMalformedResponse = createMockAuthResponse(
        { invalidField: 'malformed' },
        null,
        null
      );
      setupMockAuth(mockSupabaseClient, mockMalformedResponse);

      const result = await SupabaseAuthService.signIn(testCredentials.valid);

      expect(result.error).toBeDefined();
      expect(result.user).toBeNull();
    });
  });
});
